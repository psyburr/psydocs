<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>sd-id128</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><style>
    a.headerlink {
      color: #c60f0f;
      font-size: 0.8em;
      padding: 0 4px 0 4px;
      text-decoration: none;
      visibility: hidden;
    }

    a.headerlink:hover {
      background-color: #c60f0f;
      color: white;
    }

    h1:hover > a.headerlink, h2:hover > a.headerlink, h3:hover > a.headerlink, dt:hover > a.headerlink {
      visibility: visible;
    }
  </style><a href="index.html">Index </a>·
  <a href="systemd.directives.html">Directives </a><span style="float:right">systemd 249</span><hr><div class="refentry"><a name="sd-id128"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>sd-id128, SD_ID128_ALLF, SD_ID128_CONST_STR, SD_ID128_FORMAT_STR, SD_ID128_FORMAT_VAL, SD_ID128_MAKE, SD_ID128_MAKE_STR, SD_ID128_MAKE_UUID_STR, SD_ID128_NULL, SD_ID128_UUID_FORMAT_STR, sd_id128_equal, sd_id128_in_set, sd_id128_in_set_sentinel, sd_id128_in_setv, sd_id128_is_allf, sd_id128_is_null, sd_id128_t — APIs for processing 128-bit IDs</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;systemd/sd-id128.h&gt;</pre></div><div class="cmdsynopsis"><p><code class="command">pkg-config --cflags --libs libsystemd</code> </p></div></div><div class="refsect1"><a name="id-1.5"></a><h2 id="Description">Description<a class="headerlink" title="Permalink to this headline" href="SD_ID128_FORMAT_VAL.html#Description">¶</a></h2><p><code class="filename">sd-id128.h</code> provides APIs to process and generate 128-bit ID values. The
    128-bit ID values processed and generated by these APIs are a generalization of OSF UUIDs as defined by
    <a class="ulink" href="https://tools.ietf.org/html/rfc4122" target="_top">RFC 4122</a> but use a simpler string format. These
    functions impose no structure on the used IDs, much unlike OSF UUIDs or Microsoft GUIDs, but are mostly
    compatible with those types of IDs.
    </p><p>See
    <a href="sd_id128_to_string.html#"><span class="citerefentry"><span class="refentrytitle">sd_id128_to_string</span>(3)</span></a>,
    <a href="sd_id128_randomize.html#"><span class="citerefentry"><span class="refentrytitle">sd_id128_randomize</span>(3)</span></a>
    and
    <a href="sd_id128_get_machine.html#"><span class="citerefentry"><span class="refentrytitle">sd_id128_get_machine</span>(3)</span></a>
    for more information about the implemented functions.</p><p>A 128-bit ID is implemented as the following
    union type:</p><pre class="programlisting">typedef union sd_id128 {
  uint8_t bytes[16];
  uint64_t qwords[2];
} sd_id128_t;</pre><p>This union type allows accessing the 128-bit ID as 16
    separate bytes or two 64-bit words. It is generally safer to
    access the ID components by their 8-bit array to avoid endianness
    issues. This union is intended to be passed call-by-value (as
    opposed to call-by-reference) and may be directly manipulated by
    clients.</p><p>A couple of macros are defined to denote and decode 128-bit
    IDs:</p><p><code class="function">SD_ID128_MAKE()</code> may be used to denote a
    constant 128-bit ID in source code. A commonly used idiom is to
    assign a name to a 128-bit ID using this macro:</p><pre class="programlisting">#define SD_MESSAGE_COREDUMP SD_ID128_MAKE(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)</pre><p><code class="constant">SD_ID128_NULL</code> may be used to refer to the 128-bit ID consisting of only
    <code class="constant">NUL</code> bytes (i.e. all bits off).</p><p><code class="constant">SD_ID128_ALLF</code> may be used to refer to the 128-bit ID consisting of only
    <code class="constant">0xFF</code> bytes (i.e. all bits on).</p><p><code class="function">SD_ID128_MAKE_STR()</code> is similar to <code class="function">SD_ID128_MAKE()</code>, but creates a
    <span class="type">const char*</span> expression that can be conveniently used in message formats and such:</p><pre class="programlisting">#include &lt;stdio.h&gt;
#define SD_MESSAGE_COREDUMP_STR SD_ID128_MAKE_STR(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)

int main(int argc, char **argv) {
  puts("Match for coredumps: MESSAGE_ID=" SD_MESSAGE_COREDUMP_STR);
}</pre><p><code class="function">SD_ID128_CONST_STR()</code> may be used to
    convert constant 128-bit IDs into constant strings for output. The
    following example code will output the string
    "fc2e22bc6ee647b6b90729ab34a250b1":</p><pre class="programlisting">int main(int argc, char *argv[]) {
  puts("Match for coredumps: %s", SD_ID128_CONST_STR(SD_MESSAGE_COREDUMP));
}</pre><p><code class="constant">SD_ID128_FORMAT_STR</code> and <code class="function">SD_ID128_FORMAT_VAL()</code> may
    be used to format a 128-bit ID in a
    <a href="http://man7.org/linux/man-pages/man3/printf.3.html"><span class="citerefentry"><span class="refentrytitle">printf</span>(3)</span></a>
    format string, as shown in the following example:</p><pre class="programlisting">int main(int argc, char *argv[]) {
  sd_id128_t id;
  id = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
  printf("The ID encoded in this C file is " SD_ID128_FORMAT_STR ".\n", SD_ID128_FORMAT_VAL(id));
  return 0;
}</pre><p><code class="constant">SD_ID128_UUID_FORMAT_STR</code> and <code class="function">SD_ID128_MAKE_UUID_STR()</code>
    are similar to
    <code class="constant">SD_ID128_FORMAT_STR</code> and <code class="function">SD_ID128_MAKE_STR()</code>,
    but include separating hyphens to conform to the
    "<a class="ulink" href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Format" target="_top">canonical representation</a>".
    They format the string based on <a class="ulink" href="https://tools.ietf.org/html/rfc4122" target="_top">RFC4122</a> Variant 1 rules, i.e. converting from Big
    Endian byte order. This matches behaviour of most other Linux userspace infrastructure. It's probably
    best to avoid UUIDs of other variants, in order to avoid unnecessary ambiguities. All 128-bit IDs
    generated by the sd-id128 APIs strictly conform to Variant 1 Version 4 UUIDs, as per RFC 4122.</p><p>Use <code class="function">sd_id128_equal()</code> to compare two 128-bit IDs:</p><pre class="programlisting">int main(int argc, char *argv[]) {
  sd_id128_t a, b, c;
  a = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
  b = SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e);
  c = a;
  assert(sd_id128_equal(a, c));
  assert(!sd_id128_equal(a, b));
  return 0;
}</pre><p>Use <code class="function">sd_id128_is_null()</code> to check if an 128-bit ID consists of only
    <code class="constant">NUL</code> bytes:</p><pre class="programlisting">assert(sd_id128_is_null(SD_ID128_NULL));</pre><p>Similarly, use <code class="function">sd_id128_is_allf()</code> to check if an 128-bit ID consists of only
    <code class="constant">0xFF</code> bytes (all bits on):</p><pre class="programlisting">assert(sd_id128_is_allf(SD_ID128_ALLF));</pre><p>For convenience, <code class="function">sd_id128_in_set()</code> takes a list of IDs and
    returns true if any are equal to the first argument:</p><pre class="programlisting">int main(int argc, char *argv[]) {
  sd_id12_t a = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
  assert(sd_id128_in_set(a, a));
  assert(sd_id128_in_set(a, a, a));
  assert(!sd_id128_in_set(a));
  assert(!sd_id128_in_set(a,
                          SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e)
                          SD_ID128_MAKE(2f,88,28,5f,9c,44,09,9d,d7,15,77,04,bc,85,7e,e3)
                          SD_ID128_ALLF));
  return 0;
}
</pre><p><code class="function">sd_id128_in_set()</code> is defined as a macro over
    <code class="function">sd_id128_in_set_sentinel()</code>, adding the <code class="constant">SD_ID128_NULL</code>
    sentinel. Since <code class="function">sd_id128_in_set_sentinel()</code> uses <code class="constant">SD_ID128_NULL</code>
    as the sentinel, <code class="constant">SD_ID128_NULL</code> cannot be otherwise placed in the argument list.
    </p><p><code class="function">sd_id128_in_setv()</code> is similar to
    <code class="function">sd_id128_in_set_sentinel()</code>, but takes a <span class="structname">struct varargs</span>
    argument.</p><p>Note that new, randomized IDs may be generated with
    <a href="systemd-id128.html#"><span class="citerefentry"><span class="refentrytitle">systemd-id128</span>(1)</span></a>'s
    <span class="command"><strong>new</strong></span> command.</p></div><div class="refsect1"><a name="id-1.6"></a><h2 id="Notes">Notes<a class="headerlink" title="Permalink to this headline" href="SD_ID128_FORMAT_VAL.html#Notes">¶</a></h2><p><a name="pkgconfig-text"></a>These APIs are implemented as a shared
  library, which can be compiled and linked to with the
  <code class="constant">libsystemd</code> <a href="http://linux.die.net/man/1/pkg-config"><span class="citerefentry"><span class="refentrytitle">pkg-config</span>(1)</span></a>
  file.</p></div><div class="refsect1"><a name="id-1.7"></a><h2 id="See Also">See Also<a class="headerlink" title="Permalink to this headline" href="SD_ID128_FORMAT_VAL.html#See%20Also">¶</a></h2><p>
      <a href="systemd.html#"><span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span></a>,
      <a href="sd_id128_to_string.html#"><span class="citerefentry"><span class="refentrytitle">sd_id128_to_string</span>(3)</span></a>,
      <a href="sd_id128_randomize.html#"><span class="citerefentry"><span class="refentrytitle">sd_id128_randomize</span>(3)</span></a>,
      <a href="sd_id128_get_machine.html#"><span class="citerefentry"><span class="refentrytitle">sd_id128_get_machine</span>(3)</span></a>,
      <a href="http://man7.org/linux/man-pages/man3/printf.3.html"><span class="citerefentry"><span class="refentrytitle">printf</span>(3)</span></a>,
      <a href="journalctl.html#"><span class="citerefentry"><span class="refentrytitle">journalctl</span>(1)</span></a>,
      <a href="sd-journal.html#"><span class="citerefentry"><span class="refentrytitle">sd-journal</span>(7)</span></a>,
      <a href="http://linux.die.net/man/1/pkg-config"><span class="citerefentry"><span class="refentrytitle">pkg-config</span>(1)</span></a>,
      <a href="machine-id.html#"><span class="citerefentry"><span class="refentrytitle">machine-id</span>(5)</span></a>
    </p></div></div></body></html>

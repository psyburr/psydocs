<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>getrlimit(2) — Linux manual pages</title>
  <link rel="stylesheet" type="text/css" href="../stylesheet/manpages.css" />
  
  <link rel="home" href="../index.html" title="getrlimit(2) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve"> </script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>
<body onload="javascript:init()">
  <div class="navheader">
    <table width="100%">
      <tbody>
        <tr>
          <td style="width: 33%" rowspan="1" colspan="1"><a href="../index.html" shape="rect">Linux
          manual pages</a></td>
          <th rowspan="1" colspan="1"><a href="../index2.html" shape="rect">Section 2</a></th>
          <td style="width: 33%" rowspan="1" colspan="1"> </td>
        </tr>
      </tbody>
    </table>
    <hr />
  </div>
  <div class="refentry">
    <a id="getrlimit.2" name="getrlimit.2" shape="rect"> </a>
    <div class="titlepage"> </div>
    <div class="refnamediv">
      <h2>Name</h2>
      <p>getrlimit, setrlimit, prlimit — get/set resource
      limits</p>
    </div>
    <div class="refsynopsisdiv">
      <h2>Synopsis</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;</pre>
      </div>
      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>getrlimit</strong>(</code></td>
            <td rowspan="1" colspan="1">int <var class="pdparam">resource</var>,</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> </td>
            <td rowspan="1" colspan="1">struct rlimit *<var class="pdparam">rlim</var><code>)</code>;</td>
          </tr>
        </table>
        <div class="funcprototype-spacer">
           
        </div>
      </div>
      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>setrlimit</strong>(</code></td>
            <td rowspan="1" colspan="1">int <var class="pdparam">resource</var>,</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> </td>
            <td rowspan="1" colspan="1">const struct rlimit *<var class="pdparam">rlim</var><code>)</code>;</td>
          </tr>
        </table>
        <div class="funcprototype-spacer">
           
        </div>
      </div>
      <div class="funcsynopsis">
        <table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>prlimit</strong>(</code></td>
            <td rowspan="1" colspan="1">pid_t <var class="pdparam">pid</var>,</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> </td>
            <td rowspan="1" colspan="1">int <var class="pdparam">resource</var>,</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> </td>
            <td rowspan="1" colspan="1">const struct rlimit *<var class="pdparam">new_limit</var>,</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"> </td>
            <td rowspan="1" colspan="1">struct rlimit *<var class="pdparam">old_limit</var><code>)</code>;</td>
          </tr>
        </table>
        <div class="funcprototype-spacer">
           
        </div>
      </div>
      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Note">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Note]" src="../stylesheet/note.png" /></td>
            <th align="left" rowspan="1" colspan="1">Note</th>
          </tr>
          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <div class="featuretests">
                <table class="featuretests" style="border-collapse: collapse;">
                  <colgroup span="1">
                    <col span="1" />
                  </colgroup>
                  <thead>
                    <tr>
                      <th style="" rowspan="1" colspan="1">Feature Test Macro Requirements
                      for glibc (see <a class="link" href="../htmlman7/feature_test_macros.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">feature_test_macros</span>(7)</span></a>):</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td style="" rowspan="1" colspan="1"><code class="function">prlimit</code>():</td>
                    </tr>
                    <tr>
                      <td class="featuretestdef" style="" rowspan="1" colspan="1">
                      <code class="constant">_GNU_SOURCE</code></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </td>
          </tr>
        </table>
      </div>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect1" name="getrlimit-2_sect1" shape="rect"> </a>
      <h2>DESCRIPTION</h2>
      <p>The <code class="function">getrlimit</code>() and
      <code class="function">setrlimit</code>() system calls get
      and set resource limits. Each resource has an associated soft
      and hard limit, as defined by the <span class="structname">rlimit</span> structure:</p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <div class="structdef">
            <table class="structdef" style="border-collapse: collapse;">
              <colgroup span="1">
                <col class="c1" span="1" />
                <col class="c2" span="1" />
                <col class="c3" span="1" />
                <col class="c4" span="1" />
                <col class="c5" span="1" />
              </colgroup>
              <tbody>
                <tr>
                  <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">
                  struct</td>
                  <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">rlimit</span> {</td>
                </tr>
                <tr>
                  <td style="" rowspan="1" colspan="1"> </td>
                  <td style="" align="left" rowspan="1" colspan="1"><span class="type">rlim_t</span></td>
                  <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                   </td>
                  <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>rlim_cur</code></em>;</td>
                  <td style="" align="left" rowspan="1" colspan="1">
                    <div class="literallayout">
                      /* Soft limit */
                    </div>
                  </td>
                </tr>
                <tr>
                  <td style="" rowspan="1" colspan="1"> </td>
                  <td style="" align="left" rowspan="1" colspan="1"><span class="type">rlim_t</span></td>
                  <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                   </td>
                  <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>rlim_max</code></em>;</td>
                  <td style="" align="left" rowspan="1" colspan="1">
                    <div class="literallayout">
                      
                      /* Hard limit (ceiling for rlim_cur) */
                    </div>
                  </td>
                </tr>
                <tr>
                  <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                </tr>
              </tbody>
            </table>
          </div>
        </blockquote>
      </div>
      <p>The soft limit is the value that the kernel enforces for
      the corresponding resource. The hard limit acts as a ceiling
      for the soft limit: an unprivileged process may set only its
      soft limit to a value in the range from 0 up to the hard
      limit, and (irreversibly) lower its hard limit. A privileged
      process (under Linux: one with the <code class="constant">CAP_SYS_RESOURCE</code> capability in the initial
      user namespace) may make arbitrary changes to either limit
      value.</p>
      <p>The value <code class="constant">RLIM_INFINITY</code>
      denotes no limit on a resource (both in the structure
      returned by <code class="function">getrlimit</code>() and in
      the structure passed to <code class="function">setrlimit</code>()).</p>
      <p>The <em class="parameter"><code>resource</code></em>
      argument must be one of:</p>
      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><code class="constant">RLIMIT_AS</code></span></dt>
          <dd>
            <p>This is the maximum size of the process's virtual
            memory (address space). The limit is specified in
            bytes, and is rounded down to the system page size.
            This limit affects calls to <a class="link" href="../htmlman2/brk.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">brk</span>(2)</span></a>, <a class="link" href="../htmlman2/mmap.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>, and
            <a class="link" href="../htmlman2/mremap.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mremap</span>(2)</span></a>, which fail
            with the error <span class="errorname">ENOMEM</span>
            upon exceeding this limit. In addition, automatic stack
            expansion fails (and generates a <code class="constant">SIGSEGV</code> that kills the process if no
            alternate stack has been made available via <a class="link" href="../htmlman2/sigaltstack.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sigaltstack</span>(2)</span></a>).
            Since the value is a <span class="type">long</span>, on
            machines with a 32-bit <span class="type">long</span>
            either this limit is at most 2 GiB, or this resource is
            unlimited.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_CORE</code></span></dt>
          <dd>
            <p>This is the maximum size of a <em class="replaceable"><code>core</code></em> file (see
            <a class="link" href="../htmlman5/core.5.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">core</span>(5)</span></a>) in bytes
            that the process may dump. When 0 no core dump files
            are created. When nonzero, larger dumps are truncated
            to this size.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_CPU</code></span></dt>
          <dd>
            <p>This is a limit, in seconds, on the amount of CPU
            time that the process can consume. When the process
            reaches the soft limit, it is sent a <code class="constant">SIGXCPU</code> signal. The default action
            for this signal is to terminate the process. However,
            the signal can be caught, and the handler can return
            control to the main program. If the process continues
            to consume CPU time, it will be sent <code class="constant">SIGXCPU</code> once per second until the
            hard limit is reached, at which time it is sent
            <code class="constant">SIGKILL</code>. (This latter
            point describes Linux behavior. Implementations vary in
            how they treat processes which continue to consume CPU
            time after reaching the soft limit. Portable
            applications that need to catch this signal should
            perform an orderly termination upon first receipt of
            <code class="constant">SIGXCPU</code>.)</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_DATA</code></span></dt>
          <dd>
            <p>This is the maximum size of the process's data
            segment (initialized data, uninitialized data, and
            heap). The limit is specified in bytes, and is rounded
            down to the system page size. This limit affects calls
            to <a class="link" href="../htmlman2/brk.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">brk</span>(2)</span></a>, <a class="link" href="../htmlman2/brk.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span></a>, and (since
            Linux 4.7) <a class="link" href="../htmlman2/mmap.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>, which fail
            with the error <span class="errorname">ENOMEM</span>
            upon encountering the soft limit of this resource.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_FSIZE</code></span></dt>
          <dd>
            <p>This is the maximum size in bytes of files that the
            process may create. Attempts to extend a file beyond
            this limit result in delivery of a <code class="constant">SIGXFSZ</code> signal. By default, this
            signal terminates a process, but a process can catch
            this signal instead, in which case the relevant system
            call (e.g., <a class="link" href="../htmlman2/write.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">write</span>(2)</span></a>, <a class="link" href="../htmlman2/truncate.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">truncate</span>(2)</span></a>) fails
            with the error <span class="errorname">EFBIG</span>.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_LOCKS</code> (Linux 2.4.0 to
          2.4.24)</span></dt>
          <dd>
            <p>This is a limit on the combined number of <a class="link" href="../htmlman2/flock.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">flock</span>(2)</span></a> locks and
            <a class="link" href="../htmlman2/fcntl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fcntl</span>(2)</span></a> leases that
            this process may establish.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_MEMLOCK</code></span></dt>
          <dd>
            <p>This is the maximum number of bytes of memory that
            may be locked into RAM. This limit is in effect rounded
            down to the nearest multiple of the system page size.
            This limit affects <a class="link" href="../htmlman2/mlock.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mlock</span>(2)</span></a>, <a class="link" href="../htmlman2/mlock.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mlockall</span>(2)</span></a>, and the
            <a class="link" href="../htmlman2/mmap.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a> <code class="constant">MAP_LOCKED</code> operation. Since Linux
            2.6.9, it also affects the <a class="link" href="../htmlman2/shmctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">shmctl</span>(2)</span></a>
            <code class="constant">SHM_LOCK</code> operation, where
            it sets a maximum on the total bytes in shared memory
            segments (see <a class="link" href="../htmlman2/shmget.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">shmget</span>(2)</span></a>) that may
            be locked by the real user ID of the calling process.
            The <a class="link" href="../htmlman2/shmctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">shmctl</span>(2)</span></a>
            <code class="constant">SHM_LOCK</code> locks are
            accounted for separately from the per-process memory
            locks established by <a class="link" href="../htmlman2/mlock.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mlock</span>(2)</span></a>, <a class="link" href="../htmlman2/mlock.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mlockall</span>(2)</span></a>, and
            <a class="link" href="../htmlman2/mmap.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a> <code class="constant">MAP_LOCKED</code>; a process can lock bytes
            up to this limit in each of these two categories.</p>
            <p>In Linux kernels before 2.6.9, this limit controlled
            the amount of memory that could be locked by a
            privileged process. Since Linux 2.6.9, no limits are
            placed on the amount of memory that a privileged
            process may lock, and this limit instead governs the
            amount of memory that an unprivileged process may
            lock.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_MSGQUEUE</code> (since Linux
          2.6.8)</span></dt>
          <dd>
            <p>This is a limit on the number of bytes that can be
            allocated for POSIX message queues for the real user ID
            of the calling process. This limit is enforced for
            <a class="link" href="../htmlman3/mq_open.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mq_open</span>(3)</span></a>. Each
            message queue that the user creates counts (until it is
            removed) against this limit according to the
            formula:</p>
            <p>Since Linux 3.5:</p>
            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
        bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +
                min(attr.mq_maxmsg, MQ_PRIO_MAX) *
                      sizeof(struct posix_msg_tree_node)+
                                /* For overhead */
                attr.mq_maxmsg * attr.mq_msgsize;
                                /* For message data */
</pre>
            </div>
            <p>Linux 3.4 and earlier:</p>
            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
        bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +
                                /* For overhead */
                attr.mq_maxmsg * attr.mq_msgsize;
                                /* For message data */
</pre>
            </div>
            <p>where <em class="replaceable"><code>attr</code></em>
            is the <em class="replaceable"><code>mq_attr</code></em> structure
            specified as the fourth argument to <a class="link" href="../htmlman3/mq_open.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mq_open</span>(3)</span></a>, and the
            <em class="replaceable"><code>msg_msg</code></em> and
            <em class="replaceable"><code>posix_msg_tree_node</code></em>
            structures are kernel-internal structures.</p>
            <p>The "overhead" addend in the formula accounts for
            overhead bytes required by the implementation and
            ensures that the user cannot create an unlimited number
            of zero-length messages (such messages nevertheless
            each consume some system memory for bookkeeping
            overhead).</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_NICE</code> (since Linux 2.6.12, but
          see BUGS below)</span></dt>
          <dd>
            <p>This specifies a ceiling to which the process's nice
            value can be raised using <a class="link" href="../htmlman2/getpriority.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">setpriority</span>(2)</span></a> or
            <a class="link" href="../htmlman2/nice.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">nice</span>(2)</span></a>. The actual
            ceiling for the nice value is calculated as
            <span class="emphasis"><em>20 −
            rlim_cur</em></span>. The useful range for this limit
            is thus from 1 (corresponding to a nice value of 19) to
            40 (corresponding to a nice value of −20). This
            unusual choice of range was necessary because negative
            numbers cannot be specified as resource limit values,
            since they typically have special meanings. For
            example, <code class="constant">RLIM_INFINITY</code>
            typically is the same as −1. For more detail on
            the nice value, see <a class="link" href="../htmlman7/sched.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sched</span>(7)</span></a>.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_NOFILE</code></span></dt>
          <dd>
            <p>This specifies a value one greater than the maximum
            file descriptor number that can be opened by this
            process. Attempts (<a class="link" href="../htmlman2/open.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">open</span>(2)</span></a>, <a class="link" href="../htmlman2/pipe.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pipe</span>(2)</span></a>, <a class="link" href="../htmlman2/dup.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">dup</span>(2)</span></a>, etc.) to
            exceed this limit yield the error <span class="errorname">EMFILE</span>. (Historically, this limit
            was named <code class="constant">RLIMIT_OFILE</code> on
            BSD.)</p>
            <p>Since Linux 4.5, this limit also defines the maximum
            number of file descriptors that an unprivileged process
            (one without the <code class="constant">CAP_SYS_RESOURCE</code> capability) may have
            "in flight" to other processes, by being passed across
            UNIX domain sockets. This limit applies to the
            <a class="link" href="../htmlman2/send.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sendmsg</span>(2)</span></a> system
            call. For further details, see <a class="link" href="../htmlman7/unix.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">unix</span>(7)</span></a>.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_NPROC</code></span></dt>
          <dd>
            <p>This is a limit on the number of extant process (or,
            more precisely on Linux, threads) for the real user ID
            of the calling process. So long as the current number
            of processes belonging to this process's real user ID
            is greater than or equal to this limit, <a class="link" href="../htmlman2/fork.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fork</span>(2)</span></a> fails with
            the error <span class="errorname">EAGAIN</span>.</p>
            <p>The <code class="constant">RLIMIT_NPROC</code> limit
            is not enforced for processes that have either the
            <code class="constant">CAP_SYS_ADMIN</code> or the
            <code class="constant">CAP_SYS_RESOURCE</code>
            capability.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_RSS</code></span></dt>
          <dd>
            <p>This is a limit (in bytes) on the process's resident
            set (the number of virtual pages resident in RAM). This
            limit has effect only in Linux 2.4.x, x &lt; 30, and
            there affects only calls to <a class="link" href="../htmlman2/madvise.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">madvise</span>(2)</span></a> specifying
            <code class="constant">MADV_WILLNEED</code>.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_RTPRIO</code> (since Linux 2.6.12, but
          see BUGS)</span></dt>
          <dd>
            <p>This specifies a ceiling on the real-time priority
            that may be set for this process using <a class="link" href="../htmlman2/sched_setscheduler.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sched_setscheduler</span>(2)</span></a>
            and <a class="link" href="../htmlman2/sched_setparam.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sched_setparam</span>(2)</span></a>.</p>
            <p>For further details on real-time scheduling
            policies, see <a class="link" href="../htmlman7/sched.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sched</span>(7)</span></a></p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_RTTIME</code> (since Linux
          2.6.25)</span></dt>
          <dd>
            <p>This is a limit (in microseconds) on the amount of
            CPU time that a process scheduled under a real-time
            scheduling policy may consume without making a blocking
            system call. For the purpose of this limit, each time a
            process makes a blocking system call, the count of its
            consumed CPU time is reset to zero. The CPU time count
            is not reset if the process continues trying to use the
            CPU but is preempted, its time slice expires, or it
            calls <a class="link" href="../htmlman2/sched_yield.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sched_yield</span>(2)</span></a>.</p>
            <p>Upon reaching the soft limit, the process is sent a
            <code class="constant">SIGXCPU</code> signal. If the
            process catches or ignores this signal and continues
            consuming CPU time, then <code class="constant">SIGXCPU</code> will be generated once each
            second until the hard limit is reached, at which point
            the process is sent a <code class="constant">SIGKILL</code> signal.</p>
            <p>The intended use of this limit is to stop a runaway
            real-time process from locking up the system.</p>
            <p>For further details on real-time scheduling
            policies, see <a class="link" href="../htmlman7/sched.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sched</span>(7)</span></a></p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_SIGPENDING</code> (since Linux
          2.6.8)</span></dt>
          <dd>
            <p>This is a limit on the number of signals that may be
            queued for the real user ID of the calling process.
            Both standard and real-time signals are counted for the
            purpose of checking this limit. However, the limit is
            enforced only for <a class="link" href="../htmlman3/sigqueue.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sigqueue</span>(3)</span></a>; it is
            always possible to use <a class="link" href="../htmlman2/kill.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">kill</span>(2)</span></a> to queue one
            instance of any of the signals that are not already
            queued to the process.</p>
          </dd>
          <dt><span class="term"><code class="constant">RLIMIT_STACK</code></span></dt>
          <dd>
            <p>This is the maximum size of the process stack, in
            bytes. Upon reaching this limit, a <code class="constant">SIGSEGV</code> signal is generated. To
            handle this signal, a process must employ an alternate
            signal stack (<a class="link" href="../htmlman2/sigaltstack.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sigaltstack</span>(2)</span></a>).</p>
            <p>Since Linux 2.6.23, this limit also determines the
            amount of space used for the process's command-line
            arguments and environment variables; for details, see
            <a class="link" href="../htmlman2/execve.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">execve</span>(2)</span></a>.</p>
          </dd>
        </dl>
      </div>
      <div class="refsect2">
        <a id="getrlimit-2_sect2" name="getrlimit-2_sect2" shape="rect"> </a>
        <h3>prlimit()</h3>
        <p>The Linux-specific <code class="function">prlimit</code>() system call combines and
        extends the functionality of <code class="function">setrlimit</code>() and <code class="function">getrlimit</code>(). It can be used to both set
        and get the resource limits of an arbitrary process.</p>
        <p>The <em class="parameter"><code>resource</code></em>
        argument has the same meaning as for <code class="function">setrlimit</code>() and <code class="function">getrlimit</code>().</p>
        <p>If the <em class="parameter"><code>new_limit</code></em>
        argument is a not NULL, then the <span class="structname">rlimit</span> structure to which it points is
        used to set new values for the soft and hard limits for
        <em class="parameter"><code>resource</code></em>. If the
        <em class="parameter"><code>old_limit</code></em> argument
        is a not NULL, then a successful call to <code class="function">prlimit</code>() places the previous soft and
        hard limits for <em class="parameter"><code>resource</code></em> in the <span class="structname">rlimit</span> structure pointed to by
        <em class="parameter"><code>old_limit</code></em>.</p>
        <p>The <em class="parameter"><code>pid</code></em> argument
        specifies the ID of the process on which the call is to
        operate. If <em class="parameter"><code>pid</code></em> is
        0, then the call applies to the calling process. To set or
        get the resources of a process other than itself, the
        caller must have the <code class="constant">CAP_SYS_RESOURCE</code> capability in the user
        namespace of the process whose resource limits are being
        changed, or the real, effective, and saved set user IDs of
        the target process must match the real user ID of the
        caller <em class="replaceable"><code>and</code></em> the
        real, effective, and saved set group IDs of the target
        process must match the real group ID of the caller.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect3" name="getrlimit-2_sect3" shape="rect"> </a>
      <h2>RETURN VALUE</h2>
      <p>On success, these system calls return 0. On error,
      −1 is returned, and <code class="varname">errno</code>
      is set to indicate the error.</p>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect4" name="getrlimit-2_sect4" shape="rect"> </a>
      <h2>ERRORS</h2>
      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><span class="errorname">EFAULT</span></span></dt>
          <dd>
            <p>A pointer argument points to a location outside the
            accessible address space.</p>
          </dd>
          <dt><span class="term"><span class="errorname">EINVAL</span></span></dt>
          <dd>
            <p>The value specified in <em class="parameter"><code>resource</code></em> is not valid;
            or, for <code class="function">setrlimit</code>() or
            <code class="function">prlimit</code>(): <em class="replaceable"><code>rlim−&gt;rlim_cur</code></em>
            was greater than <em class="replaceable"><code>rlim−&gt;rlim_max</code></em>.</p>
          </dd>
          <dt><span class="term"><span class="errorname">EPERM</span></span></dt>
          <dd>
            <p>An unprivileged process tried to raise the hard
            limit; the <code class="constant">CAP_SYS_RESOURCE</code> capability is
            required to do this.</p>
          </dd>
          <dt><span class="term"><span class="errorname">EPERM</span></span></dt>
          <dd>
            <p>The caller tried to increase the hard <code class="constant">RLIMIT_NOFILE</code> limit above the maximum
            defined by <code class="filename">/proc/sys/fs/nr_open</code> (see <a class="link" href="../htmlman5/proc.5.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">proc</span>(5)</span></a>)</p>
          </dd>
          <dt><span class="term"><span class="errorname">EPERM</span></span></dt>
          <dd>
            <p>(<code class="function">prlimit</code>()) The
            calling process did not have permission to set limits
            for the process specified by <em class="parameter"><code>pid</code></em>.</p>
          </dd>
          <dt><span class="term"><span class="errorname">ESRCH</span></span></dt>
          <dd>
            <p>Could not find a process with the ID specified in
            <em class="parameter"><code>pid</code></em>.</p>
          </dd>
        </dl>
      </div>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect5" name="getrlimit-2_sect5" shape="rect"> </a>
      <h2>VERSIONS</h2>
      <p>The <code class="function">prlimit</code>() system call is
      available since Linux 2.6.36. Library support is available
      since glibc 2.13.</p>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect6" name="getrlimit-2_sect6" shape="rect"> </a>
      <h2>ATTRIBUTES</h2>
      <p>For an explanation of the terms used in this section, see
      <a class="link" href="../htmlman7/attributes.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">attributes</span>(7)</span></a>.</p>
      <div class="informaltable">
        <table class="informaltable" style="border-collapse: collapse;">
          <colgroup span="1">
            <col class="c0" span="1" />
            <col class="c1" span="1" />
            <col class="c2" span="1" />
          </colgroup>
          <tbody>
            <tr>
              <td style="" align="left" rowspan="1" colspan="1">Interface</td>
              <td style="" align="left" rowspan="1" colspan="1">Attribute</td>
              <td style="" align="left" rowspan="1" colspan="1">Value</td>
            </tr>
            <tr>
              <td style="" align="left" rowspan="1" colspan="1"><code class="literal">getrlimit</code>(), <code class="literal">setrlimit</code>(), <code class="literal">prlimit</code>()</td>
              <td style="" align="left" rowspan="1" colspan="1">Thread safety</td>
              <td style="" align="left" rowspan="1" colspan="1">MT-Safe</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect7" name="getrlimit-2_sect7" shape="rect"> </a>
      <h2>CONFORMING TO</h2>
      <p><code class="function">getrlimit</code>(), <code class="function">setrlimit</code>(): POSIX.1-2001, POSIX.1-2008,
      SVr4, 4.3BSD.</p>
      <p><code class="function">prlimit</code>():
      Linux-specific.</p>
      <p><code class="constant">RLIMIT_MEMLOCK</code> and
      <code class="constant">RLIMIT_NPROC</code> derive from BSD
      and are not specified in POSIX.1; they are present on the
      BSDs and Linux, but on few other implementations.
      <code class="constant">RLIMIT_RSS</code> derives from BSD and
      is not specified in POSIX.1; it is nevertheless present on
      most implementations. <code class="constant">RLIMIT_MSGQUEUE</code>, <code class="constant">RLIMIT_NICE</code>, <code class="constant">RLIMIT_RTPRIO</code>, <code class="constant">RLIMIT_RTTIME</code>, and <code class="constant">RLIMIT_SIGPENDING</code> are Linux-specific.</p>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect8" name="getrlimit-2_sect8" shape="rect"> </a>
      <h2>NOTES</h2>
      <p>A child process created via <a class="link" href="../htmlman2/fork.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fork</span>(2)</span></a> inherits its
      parent's resource limits. Resource limits are preserved
      across <a class="link" href="../htmlman2/execve.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">execve</span>(2)</span></a>.</p>
      <p>Resource limits are per-process attributes that are shared
      by all of the threads in a process.</p>
      <p>Lowering the soft limit for a resource below the process's
      current consumption of that resource will succeed (but will
      prevent the process from further increasing its consumption
      of the resource).</p>
      <p>One can set the resource limits of the shell using the
      built-in <em class="replaceable"><code>ulimit</code></em>
      command (<em class="replaceable"><code>limit</code></em> in
      <span class="citerefentry"><span class="refentrytitle">csh</span>(1)</span>). The shell's resource
      limits are inherited by the processes that it creates to
      execute commands.</p>
      <p>Since Linux 2.6.24, the resource limits of any process can
      be inspected via <code class="filename">/proc/[pid]/limits</code>; see <a class="link" href="../htmlman5/proc.5.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">proc</span>(5)</span></a>.</p>
      <p>Ancient systems provided a <code class="function">vlimit</code>() function with a similar purpose to
      <code class="function">setrlimit</code>(). For backward
      compatibility, glibc also provides <code class="function">vlimit</code>(). All new applications should be
      written using <code class="function">setrlimit</code>().</p>
      <div class="refsect2">
        <a id="getrlimit-2_sect9" name="getrlimit-2_sect9" shape="rect"> </a>
        <h3>C library/kernel ABI differences</h3>
        <p>Since version 2.13, the glibc <code class="function">getrlimit</code>() and <code class="function">setrlimit</code>() wrapper functions no longer
        invoke the corresponding system calls, but instead employ
        <code class="function">prlimit</code>(), for the reasons
        described in BUGS.</p>
        <p>The name of the glibc wrapper function is <code class="function">prlimit</code>(); the underlying system call is
        <code class="function">prlimit64</code>().</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect10" name="getrlimit-2_sect10" shape="rect"> </a>
      <h2>BUGS</h2>
      <p>In older Linux kernels, the <code class="constant">SIGXCPU</code> and <code class="constant">SIGKILL</code> signals delivered when a process
      encountered the soft and hard <code class="constant">RLIMIT_CPU</code> limits were delivered one (CPU)
      second later than they should have been. This was fixed in
      kernel 2.6.8.</p>
      <p>In 2.6.x kernels before 2.6.17, a <code class="constant">RLIMIT_CPU</code> limit of 0 is wrongly treated as
      "no limit" (like <code class="constant">RLIM_INFINITY</code>). Since Linux 2.6.17, setting
      a limit of 0 does have an effect, but is actually treated as
      a limit of 1 second.</p>
      <p>A kernel bug means that <code class="constant">RLIMIT_RTPRIO</code> does not work in kernel
      2.6.12; the problem is fixed in kernel 2.6.13.</p>
      <p>In kernel 2.6.12, there was an off-by-one mismatch between
      the priority ranges returned by <a class="link" href="../htmlman2/getpriority.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">getpriority</span>(2)</span></a> and
      <code class="constant">RLIMIT_NICE</code>. This had the
      effect that the actual ceiling for the nice value was
      calculated as <span class="emphasis"><em>19 −
      rlim_cur</em></span>. This was fixed in kernel 2.6.13.</p>
      <p>Since Linux 2.6.12, if a process reaches its soft
      <code class="constant">RLIMIT_CPU</code> limit and has a
      handler installed for <code class="constant">SIGXCPU</code>,
      then, in addition to invoking the signal handler, the kernel
      increases the soft limit by one second. This behavior repeats
      if the process continues to consume CPU time, until the hard
      limit is reached, at which point the process is killed. Other
      implementations do not change the <code class="constant">RLIMIT_CPU</code> soft limit in this manner, and
      the Linux behavior is probably not standards conformant;
      portable applications should avoid relying on this
      Linux-specific behavior. The Linux-specific <code class="constant">RLIMIT_RTTIME</code> limit exhibits the same
      behavior when the soft limit is encountered.</p>
      <p>Kernels before 2.4.22 did not diagnose the error
      <span class="errorname">EINVAL</span> for <code class="function">setrlimit</code>() when <em class="replaceable"><code>rlim−&gt;rlim_cur</code></em> was
      greater than <em class="replaceable"><code>rlim−&gt;rlim_max</code></em>.</p>
      <p>Linux doesn't return an error when an attempt to set
      <code class="constant">RLIMIT_CPU</code> has failed, for
      compatibility reasons.</p>
      <div class="refsect2">
        <a id="getrlimit-2_sect11" name="getrlimit-2_sect11" shape="rect"> </a>
        <h3>Representation of "large" resource limit values on
        32-bit platforms</h3>
        <p>The glibc <code class="function">getrlimit</code>() and
        <code class="function">setrlimit</code>() wrapper functions
        use a 64-bit <span class="type">rlim_t</span> data type,
        even on 32-bit platforms. However, the <span class="type">rlim_t</span> data type used in the <code class="function">getrlimit</code>() and <code class="function">setrlimit</code>() system calls is a (32-bit)
        <span class="type">unsigned long</span>. Furthermore, in
        Linux, the kernel represents resource limits on 32-bit
        platforms as <span class="type">unsigned long</span>.
        However, a 32-bit data type is not wide enough. The most
        pertinent limit here is <code class="constant">RLIMIT_FSIZE</code>, which specifies the maximum
        size to which a file can grow: to be useful, this limit
        must be represented using a type that is as wide as the
        type used to represent file offsets—that is, as wide
        as a 64-bit <span class="type">off_t</span> (assuming a
        program compiled with <em class="replaceable"><code>_FILE_OFFSET_BITS=64</code></em>).</p>
        <p>To work around this kernel limitation, if a program
        tried to set a resource limit to a value larger than can be
        represented in a 32-bit <span class="type">unsigned
        long</span>, then the glibc <code class="function">setrlimit</code>() wrapper function silently
        converted the limit value to <code class="constant">RLIM_INFINITY</code>. In other words, the
        requested resource limit setting was silently ignored.</p>
        <p>Since version 2.13, glibc works around the limitations
        of the <code class="function">getrlimit</code>() and
        <code class="function">setrlimit</code>() system calls by
        implementing <code class="function">setrlimit</code>() and
        <code class="function">getrlimit</code>() as wrapper
        functions that call <code class="function">prlimit</code>().</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect12" name="getrlimit-2_sect12" shape="rect"> </a>
      <h2>EXAMPLES</h2>
      <p>The program below demonstrates the use of <code class="function">prlimit</code>().</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
#define _GNU_SOURCE
#define _FILE_OFFSET_BITS 64
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/resource.h&gt;

#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)

int
main(int argc, char *argv[])
{
    struct rlimit old, new;
    struct rlimit *newp;
    pid_t pid;

    if (!(argc == 2 || argc == 4)) {
        fprintf(stderr, "Usage: %s &lt;pid&gt; [&lt;new−soft−limit&gt; "
                "&lt;new−hard−limit&gt;]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    pid = atoi(argv[1]);        /* PID of target process */

    newp = NULL;
    if (argc == 4) {
        new.rlim_cur = atoi(argv[2]);
        new.rlim_max = atoi(argv[3]);
        newp = &amp;new;
    }

    /* Set CPU time limit of target process; retrieve and display
       previous limit */

    if (prlimit(pid, RLIMIT_CPU, newp, &amp;old) == −1)
        errExit("prlimit−1");
    printf("Previous limits: soft=%jd; hard=%jd\n",
            (intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);

    /* Retrieve and display new CPU time limit */

    if (prlimit(pid, RLIMIT_CPU, NULL, &amp;old) == −1)
        errExit("prlimit−2");
    printf("New limits: soft=%jd; hard=%jd\n",
            (intmax_t) old.rlim_cur, (intmax_t) old.rlim_max);

    exit(EXIT_SUCCESS);
}
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="getrlimit-2_sect13" name="getrlimit-2_sect13" shape="rect"> </a>
      <h2>SEE ALSO</h2>
      <p><a class="link" href="../htmlman1/prlimit.1.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">prlimit</span>(1)</span></a>, <a class="link" href="../htmlman2/dup.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">dup</span>(2)</span></a>, <a class="link" href="../htmlman2/fcntl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fcntl</span>(2)</span></a>, <a class="link" href="../htmlman2/fork.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fork</span>(2)</span></a>, <a class="link" href="../htmlman2/getrusage.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">getrusage</span>(2)</span></a>, <a class="link" href="../htmlman2/mlock.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mlock</span>(2)</span></a>, <a class="link" href="../htmlman2/mmap.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>, <a class="link" href="../htmlman2/open.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">open</span>(2)</span></a>, <a class="link" href="../htmlman2/quotactl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">quotactl</span>(2)</span></a>, <a class="link" href="../htmlman2/brk.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span></a>, <a class="link" href="../htmlman2/shmctl.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">shmctl</span>(2)</span></a>, <a class="link" href="../htmlman3/malloc.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">malloc</span>(3)</span></a>, <a class="link" href="../htmlman3/sigqueue.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sigqueue</span>(3)</span></a>, <a class="link" href="../htmlman3/ulimit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">ulimit</span>(3)</span></a>, <a class="link" href="../htmlman5/core.5.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">core</span>(5)</span></a>, <a class="link" href="../htmlman7/capabilities.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">capabilities</span>(7)</span></a>, <a class="link" href="../htmlman7/cgroups.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">cgroups</span>(7)</span></a>, <a class="link" href="../htmlman7/credentials.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">credentials</span>(7)</span></a>, <a class="link" href="../htmlman7/signal.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">signal</span>(7)</span></a></p>
    </div>
    <div class="colophon">
      <a id="getrlimit-2_sect14" name="getrlimit-2_sect14" shape="rect"> </a>
      <h2>COLOPHON</h2>
      <p>This page is part of release 5.11 of the Linux <em class="replaceable"><code>man-pages</code></em> project. A
      description of the project, information about reporting bugs,
      and the latest version of this page, can be found at
      https://www.kernel.org/doc/man−pages/.</p>
      <div class="license">
        <table class="license" style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>
          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <div class="literallayout">
                  <br />
                    Copyright (c) 1992 Drew Eckhardt, March 28, 1992<br />

                  and Copyright (c) 2002, 2004, 2005, 2008, 2010 Michael Kerrisk<br />

                  <br />
                  %%%LICENSE_START(VERBATIM)<br />
                  Permission is granted to make and distribute verbatim copies of this<br />

                  manual provided the copyright notice and this permission notice are<br />

                  preserved on all copies.<br />
                  <br />
                  Permission is granted to copy and distribute modified versions of this<br />

                  manual under the conditions for verbatim copying, provided that the<br />

                  entire resulting derived work is distributed under the terms of a<br />

                  permission notice identical to this one.<br />

                  <br />
                  Since the Linux kernel and libraries are constantly changing, this<br />

                  manual page may be incorrect or out-of-date.  The author(s) assume no<br />

                  responsibility for errors or omissions, or for damages resulting from<br />

                  the use of the information contained herein.  The author(s) may not<br />

                  have taken the same level of care in the production of this manual,<br />

                  which is licensed free of charge, as they might when working<br />

                  professionally.<br />
                  <br />
                  Formatted or processed versions of this manual, if unaccompanied by<br />

                  the source, must acknowledge the copyright and authors of this work.<br />

                  %%%LICENSE_END<br />
                  <br />
                  Modified by Michael Haardt &lt;michael<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>moria.de&gt;<br />

                  Modified 1993-07-23 by Rik Faith &lt;faith<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>cs.unc.edu&gt;<br />

                  Modified 1996-01-13 by Arnt Gulbrandsen &lt;agulbra<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>troll.no&gt;<br />

                  Modified 1996-01-22 by aeb, following a remark by<br />

                           Tigran Aivazian &lt;tigran<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>sco.com&gt;<br />

                  Modified 1996-04-14 by aeb, following a remark by<br />

                           Robert Bihlmeyer &lt;robbe<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>orcus.ping.at&gt;<br />

                  Modified 1996-10-22 by Eric S. Raymond &lt;esr<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>thyrsus.com&gt;<br />

                  Modified 2001-05-04 by aeb, following a remark by<br />

                           Håvard Lygre &lt;hklygre<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>online.no&gt;<br />

                  Modified 2001-04-17 by Michael Kerrisk &lt;mtk.manpages<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>gmail.com&gt;<br />

                  Modified 2002-06-13 by Michael Kerrisk &lt;mtk.manpages<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>gmail.com&gt;<br />

                      Added note on nonstandard behavior when SIGCHLD is ignored.<br />

                  Modified 2002-07-09 by Michael Kerrisk &lt;mtk.manpages<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>gmail.com&gt;<br />

                  Enhanced descriptions of 'resource' values<br />

                  Modified 2003-11-28 by aeb, added RLIMIT_CORE<br />

                  Modified 2004-03-26 by aeb, added RLIMIT_AS<br />

                  Modified 2004-06-16 by Michael Kerrisk &lt;mtk.manpages<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>gmail.com&gt;<br />

                      Added notes on CAP_SYS_RESOURCE<br />

                  <br />
                  2004-11-16 -- mtk: the getrlimit.2 page, which formally included<br />

                  coverage of getrusage(2), has been split, so that the latter<br />

                  is now covered in its own getrusage.2.<br />

                  <br />
                  Modified 2004-11-16, mtk: A few other minor changes<br />

                  Modified 2004-11-23, mtk<br />
                  Added notes on RLIMIT_MEMLOCK, RLIMIT_NPROC, and RLIMIT_RSS<br />

                  to "CONFORMING TO"<br />
                  Modified 2004-11-25, mtk<br />
                  Rewrote discussion on RLIMIT_MEMLOCK to incorporate kernel<br />

                  2.6.9 changes.<br />
                  Added note on RLIMIT_CPU error in older kernels<br />

                  2004-11-03, mtk, Added RLIMIT_SIGPENDING<br />

                  2005-07-13, mtk, documented RLIMIT_MSGQUEUE limit.<br />

                  2005-07-28, mtk, Added descriptions of RLIMIT_NICE and RLIMIT_RTPRIO<br />

                  2008-05-07, mtk / Peter Zijlstra, Added description of RLIMIT_RTTIME<br />

                  2010-11-06, mtk: Added documentation of prlimit()<br />
                  
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>pcre2api(3) — Linux manual pages</title>
  <link rel="stylesheet" type="text/css" href="../stylesheet/manpages.css" />
  
  <link rel="home" href="../index.html" title="pcre2api(3) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve"> </script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>
<body onload="javascript:init()">
  <div class="navheader">
    <table width="100%">
      <tbody>
        <tr>
          <td style="width: 33%" rowspan="1" colspan="1"><a href="../index.html" shape="rect">Linux
          manual pages</a></td>
          <th rowspan="1" colspan="1"><a href="../index3.html" shape="rect">Section 3</a></th>
          <td style="width: 33%" rowspan="1" colspan="1"> </td>
        </tr>
      </tbody>
    </table>
    <hr />
  </div>
  <div class="refentry">
    <a id="pcre2api.3" name="pcre2api.3" shape="rect"> </a>
    <div class="titlepage"> </div>
    <div class="refnamediv">
      <h2>Name</h2>
      <p>PCRE2 — Perl-compatible regular expressions (revised
      API) #include &lt;pcre2.h&gt; PCRE2 is a new API for PCRE,
      starting at release 10.0. This document contains a
      description of all its native functions. See the <code class="function">pcre2</code> document for an overview of all the
      PCRE2 documentation. . .</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect1" name="pcre2api-3_sect1" shape="rect"> </a>
      <h2>PCRE2 NATIVE API BASIC FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_code *pcre2_compile(PCRE2_SPTR <code class="function">pattern</code>, PCRE2_SIZE <code class="function">length</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, int *<code class="function">errorcode</code>, PCRE2_SIZE *<em class="replaceable"><code>erroroffset,</code></em></em></span>
<span class="emphasis"><em>  pcre2_compile_context *<code class="function">ccontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_code_free(pcre2_code *<code class="function">code</code>);</em></span>

<span class="emphasis"><em>pcre2_match_data *pcre2_match_data_create(uint32_t <code class="function">ovecsize</code>,</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_match_data *pcre2_match_data_create_from_pattern(</em></span>
<span class="emphasis"><em>  const pcre2_code *<code class="function">code</code>, pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>int pcre2_match(const pcre2_code *<code class="function">code</code>, PCRE2_SPTR <code class="function">subject</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">length</code>, PCRE2_SIZE <code class="function">startoffset</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>);</em></span>

<span class="emphasis"><em>int pcre2_dfa_match(const pcre2_code *<code class="function">code</code>, PCRE2_SPTR <code class="function">subject</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">length</code>, PCRE2_SIZE <code class="function">startoffset</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  int *<code class="function">workspace</code>, PCRE2_SIZE <code class="function">wscount</code>);</em></span>

<span class="emphasis"><em>void pcre2_match_data_free(pcre2_match_data *<code class="function">match_data</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect2" name="pcre2api-3_sect2" shape="rect"> </a>
      <h2>PCRE2 NATIVE API AUXILIARY MATCH FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>PCRE2_SPTR pcre2_get_mark(pcre2_match_data *<code class="function">match_data</code>);</em></span>

<span class="emphasis"><em>uint32_t pcre2_get_ovector_count(pcre2_match_data *<code class="function">match_data</code>);</em></span>

<span class="emphasis"><em>PCRE2_SIZE *pcre2_get_ovector_pointer(pcre2_match_data *<code class="function">match_data</code>);</em></span>

<span class="emphasis"><em>PCRE2_SIZE pcre2_get_startchar(pcre2_match_data *<code class="function">match_data</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect3" name="pcre2api-3_sect3" shape="rect"> </a>
      <h2>PCRE2 NATIVE API GENERAL CONTEXT FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_general_context *pcre2_general_context_create(</em></span>
<span class="emphasis"><em>  void *(*<code class="function">private_malloc</code>)(PCRE2_SIZE, void *),</em></span>
<span class="emphasis"><em>  void (*<code class="function">private_free</code>)(void *, void *), void *<code class="function">memory_data</code>);</em></span>

<span class="emphasis"><em>pcre2_general_context *pcre2_general_context_copy(</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_general_context_free(pcre2_general_context *<code class="function">gcontext</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect4" name="pcre2api-3_sect4" shape="rect"> </a>
      <h2>PCRE2 NATIVE API COMPILE CONTEXT FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_compile_context *pcre2_compile_context_create(</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_compile_context *pcre2_compile_context_copy(</em></span>
<span class="emphasis"><em>  pcre2_compile_context *<code class="function">ccontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_compile_context_free(pcre2_compile_context *<code class="function">ccontext</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_bsr(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_character_tables(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  const uint8_t *<code class="function">tables</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_compile_extra_options(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">extra_options</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_max_pattern_length(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">value</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_newline(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_parens_nest_limit(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_compile_recursion_guard(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">guard_function</code>)(uint32_t, void *), void *<code class="function">user_data</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect5" name="pcre2api-3_sect5" shape="rect"> </a>
      <h2>PCRE2 NATIVE API MATCH CONTEXT FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_match_context *pcre2_match_context_create(</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_match_context *pcre2_match_context_copy(</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_match_context_free(pcre2_match_context *<code class="function">mcontext</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_callout(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">callout_function</code>)(pcre2_callout_block *, void *),</em></span>
<span class="emphasis"><em>  void *<code class="function">callout_data</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_substitute_callout(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">callout_function</code>)(pcre2_substitute_callout_block *, void *),</em></span>
<span class="emphasis"><em>  void *<code class="function">callout_data</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_offset_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">value</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_heap_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_match_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_depth_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect6" name="pcre2api-3_sect6" shape="rect"> </a>
      <h2>PCRE2 NATIVE API STRING EXTRACTION FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_substring_copy_byname(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>, PCRE2_UCHAR *<code class="function">buffer</code>, PCRE2_SIZE *<code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_copy_bynumber(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">number</code>, PCRE2_UCHAR *<code class="function">buffer</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE *<code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>void pcre2_substring_free(PCRE2_UCHAR *<code class="function">buffer</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_get_byname(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>, PCRE2_UCHAR **<code class="function">bufferptr</code>, PCRE2_SIZE *<code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_get_bynumber(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">number</code>, PCRE2_UCHAR **<code class="function">bufferptr</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE *<code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_length_byname(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>, PCRE2_SIZE *<code class="function">length</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_length_bynumber(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">number</code>, PCRE2_SIZE *<code class="function">length</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_nametable_scan(const pcre2_code *<code class="function">code</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>, PCRE2_SPTR *<code class="function">first</code>, PCRE2_SPTR *<code class="function">last</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_number_from_name(const pcre2_code *<code class="function">code</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>);</em></span>

<span class="emphasis"><em>void pcre2_substring_list_free(PCRE2_SPTR *<code class="function">list</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_list_get(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  PCRE2_UCHAR ***<code class="function">listptr</code>, PCRE2_SIZE **<code class="function">lengthsptr</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect7" name="pcre2api-3_sect7" shape="rect"> </a>
      <h2>PCRE2 NATIVE API STRING SUBSTITUTION FUNCTION</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_substitute(const pcre2_code *<code class="function">code</code>, PCRE2_SPTR <code class="function">subject</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">length</code>, PCRE2_SIZE <code class="function">startoffset</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>, PCRE2_SPTR <code class="function">replacementz</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">rlength</code>, PCRE2_UCHAR *<code class="function">outputbuffer</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE *<code class="function">outlengthptr</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect8" name="pcre2api-3_sect8" shape="rect"> </a>
      <h2>PCRE2 NATIVE API JIT FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_jit_compile(pcre2_code *<code class="function">code</code>, uint32_t <code class="function">options</code>);</em></span>

<span class="emphasis"><em>int pcre2_jit_match(const pcre2_code *<code class="function">code</code>, PCRE2_SPTR <code class="function">subject</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">length</code>, PCRE2_SIZE <code class="function">startoffset</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_jit_free_unused_memory(pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_jit_stack *pcre2_jit_stack_create(PCRE2_SIZE <code class="function">startsize</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">maxsize</code>, pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_jit_stack_assign(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  pcre2_jit_callback <code class="function">callback_function</code>, void *<code class="function">callback_data</code>);</em></span>

<span class="emphasis"><em>void pcre2_jit_stack_free(pcre2_jit_stack *<code class="function">jit_stack</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect9" name="pcre2api-3_sect9" shape="rect"> </a>
      <h2>PCRE2 NATIVE API SERIALIZATION FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int32_t pcre2_serialize_decode(pcre2_code **<code class="function">codes</code>,</em></span>
<span class="emphasis"><em>  int32_t <code class="function">number_of_codes</code>, const uint8_t *<code class="function">bytes</code>,</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>int32_t pcre2_serialize_encode(const pcre2_code **<code class="function">codes</code>,</em></span>
<span class="emphasis"><em>  int32_t <code class="function">number_of_codes</code>, uint8_t **<code class="function">serialized_bytes</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE *<code class="function">serialized_size</code>, pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_serialize_free(uint8_t *<code class="function">bytes</code>);</em></span>

<span class="emphasis"><em>int32_t pcre2_serialize_get_number_of_codes(const uint8_t *<code class="function">bytes</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect10" name="pcre2api-3_sect10" shape="rect"> </a>
      <h2>PCRE2 NATIVE API AUXILIARY FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_code *pcre2_code_copy(const pcre2_code *<code class="function">code</code>);</em></span>

<span class="emphasis"><em>pcre2_code *pcre2_code_copy_with_tables(const pcre2_code *<code class="function">code</code>);</em></span>

<span class="emphasis"><em>int pcre2_get_error_message(int <code class="function">errorcode</code>, PCRE2_UCHAR *<code class="function">buffer</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>const uint8_t *pcre2_maketables(pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_maketables_free(pcre2_general_context *<code class="function">gcontext</code>,</em></span>
<span class="emphasis"><em>  const uint8_t *<code class="function">tables</code>);</em></span>

<span class="emphasis"><em>int pcre2_pattern_info(const pcre2_code *<code class="function">code</code>, uint32_t <code class="function">what</code>,</em></span>
<span class="emphasis"><em>  void *<code class="function">where</code>);</em></span>

<span class="emphasis"><em>int pcre2_callout_enumerate(const pcre2_code *<code class="function">code</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">callback</code>)(pcre2_callout_enumerate_block *, void *),</em></span>
<span class="emphasis"><em>  void *<code class="function">user_data</code>);</em></span>

<span class="emphasis"><em>int pcre2_config(uint32_t <code class="function">what</code>, void *<code class="function">where</code>);</em></span>
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect11" name="pcre2api-3_sect11" shape="rect"> </a>
      <h2>PCRE2 NATIVE API OBSOLETE FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_recursion_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_recursion_memory_management(</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  void *(*<code class="function">private_malloc</code>)(PCRE2_SIZE, void *),</em></span>
<span class="emphasis"><em>  void (*<code class="function">private_free</code>)(void *, void *), void *<code class="function">memory_data</code>);</em></span>
</pre>
      </div>
      <p>These functions became obsolete at release 10.30 and are
      retained only for backward compatibility. They should not be
      used in new code. The first is replaced by <code class="function">pcre2_set_depth_limit</code>(); the second is no
      longer needed and has no effect (it always returns zero).</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect12" name="pcre2api-3_sect12" shape="rect"> </a>
      <h2>PCRE2 EXPERIMENTAL PATTERN CONVERSION FUNCTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_convert_context *pcre2_convert_context_create(</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_convert_context *pcre2_convert_context_copy(</em></span>
<span class="emphasis"><em>  pcre2_convert_context *<code class="function">cvcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_convert_context_free(pcre2_convert_context *<code class="function">cvcontext</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_glob_escape(pcre2_convert_context *<code class="function">cvcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">escape_char</code>);</em></span>

<span class="emphasis"><em>int pcre2_set_glob_separator(pcre2_convert_context *<code class="function">cvcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">separator_char</code>);</em></span>

<span class="emphasis"><em>int pcre2_pattern_convert(PCRE2_SPTR <code class="function">pattern</code>, PCRE2_SIZE <code class="function">length</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, PCRE2_UCHAR **<code class="function">buffer</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE *<code class="function">blength</code>, pcre2_convert_context *<code class="function">cvcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_converted_pattern_free(PCRE2_UCHAR *<code class="function">converted_pattern</code>);</em></span>
</pre>
      </div>
      <p>These functions provide a way of converting non-PCRE2
      patterns into patterns that can be processed by <code class="function">pcre2_compile</code>(). This facility is
      experimental and may be changed in future releases. At
      present, "globs" and POSIX basic and extended patterns can be
      converted. Details are given in the <a class="link" href="../htmlman3/pcre2convert.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2convert</span>(3)</span></a>
      documentation.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect13" name="pcre2api-3_sect13" shape="rect"> </a>
      <h2>PCRE2 8-BIT, 16-BIT, AND 32-BIT LIBRARIES</h2>
      <p>There are three PCRE2 libraries, supporting 8-bit, 16-bit,
      and 32-bit code units, respectively. However, there is just
      one header file, <code class="filename">pcre2.h</code>. This
      contains the function prototypes and other definitions for
      all three libraries. One, two, or all three can be installed
      simultaneously. On Unix-like systems the libraries are called
      <em class="replaceable"><code>libpcre2-8</code></em>,
      <em class="replaceable"><code>libpcre2-16</code></em>, and
      <em class="replaceable"><code>libpcre2-32</code></em>, and
      they can also co-exist with the original PCRE libraries.</p>
      <p>Character strings are passed to and from a PCRE2 library
      as a sequence of unsigned integers in code units of the
      appropriate width. Every PCRE2 function comes in three
      different forms, one for each library, for example:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 <code class="function">pcre2_compile_8</code>()
 <code class="function">pcre2_compile_16</code>()
 <code class="function">pcre2_compile_32</code>()
</pre>
      </div>
      <p>There are also three different sets of data types:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 <span class="emphasis"><em>PCRE2_UCHAR8, PCRE2_UCHAR16, PCRE2_UCHAR32</em></span>
 <span class="emphasis"><em>PCRE2_SPTR8,  PCRE2_SPTR16,  PCRE2_SPTR32</em></span>
</pre>
      </div>
      <p>The UCHAR types define unsigned code units of the
      appropriate widths. For example, PCRE2_UCHAR16 is usually
      defined as `uint16_t'. The SPTR types are constant pointers
      to the equivalent UCHAR types, that is, they are pointers to
      vectors of unsigned code units.</p>
      <p>Many applications use only one code unit width. For their
      convenience, macros are defined whose names are the generic
      forms such as <code class="function">pcre2_compile</code>()
      and PCRE2_SPTR. These macros use the value of the macro
      PCRE2_CODE_UNIT_WIDTH to generate the appropriate
      width-specific function and macro names.
      PCRE2_CODE_UNIT_WIDTH is not defined by default. An
      application must define it to be 8, 16, or 32 before
      including <code class="filename">pcre2.h</code> in order to
      make use of the generic names.</p>
      <p>Applications that use more than one code unit width can be
      linked with more than one PCRE2 library, but must define
      PCRE2_CODE_UNIT_WIDTH to be 0 before including <code class="filename">pcre2.h</code>, and then use the real function
      names. Any code that is to be included in an environment
      where the value of PCRE2_CODE_UNIT_WIDTH is unknown should
      also use the real function names. (Unfortunately, it is not
      possible in C code to save and restore the value of a
      macro.)</p>
      <p>If PCRE2_CODE_UNIT_WIDTH is not defined before including
      <code class="filename">pcre2.h</code>, a compiler error
      occurs.</p>
      <p>When using multiple libraries in an application, you must
      take care when processing any particular pattern to use only
      functions from a single library. For example, if you want to
      run a match using a pattern that was compiled with
      <code class="function">pcre2_compile_16</code>(), you must do
      so with <code class="function">pcre2_match_16</code>(), not
      <code class="function">pcre2_match_8</code>() or <code class="function">pcre2_match_32</code>().</p>
      <p>In the function summaries above, and in the rest of this
      document and other PCRE2 documents, functions and data types
      are described using their generic names, without the _8, _16,
      or _32 suffix.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect14" name="pcre2api-3_sect14" shape="rect"> </a>
      <h2>PCRE2 API OVERVIEW</h2>
      <p>PCRE2 has its own native API, which is described in this
      document. There are also some wrapper functions for the 8-bit
      library that correspond to the POSIX regular expression API,
      but they do not give access to all the functionality of
      PCRE2. They are described in the <a class="link" href="../htmlman3/pcre2posix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2posix</span>(3)</span></a>
      documentation. Both these APIs define a set of C function
      calls.</p>
      <p>The native API C data types, function prototypes, option
      values, and error codes are defined in the header file
      <code class="filename">pcre2.h</code>, which also contains
      definitions of PCRE2_MAJOR and PCRE2_MINOR, the major and
      minor release numbers for the library. Applications can use
      these to include support for different releases of PCRE2.</p>
      <p>In a Windows environment, if you want to statically link
      an application program against a non-dll PCRE2 library, you
      must define PCRE2_STATIC before including <code class="filename">pcre2.h</code>.</p>
      <p>The functions <code class="function">pcre2_compile</code>() and <code class="function">pcre2_match</code>() are used for compiling and
      matching regular expressions in a Perl-compatible manner. A
      sample program that demonstrates the simplest way of using
      them is provided in the file called <code class="filename">pcre2demo.c</code> in the PCRE2 source
      distribution. A listing of this program is given in the
      <span class="citerefentry"><span class="refentrytitle">pcre2demo</span>(3)</span> documentation, and
      the <a class="link" href="../htmlman3/pcre2sample.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2sample</span>(3)</span></a>
      documentation describes how to compile and run it.</p>
      <p>The compiling and matching functions recognize various
      options that are passed as bits in an options argument. There
      are also some more complicated parameters such as custom
      memory management functions and resource limits that are
      passed in "contexts" (which are just memory blocks, described
      below). Simple applications do not need to make use of
      contexts.</p>
      <p>Just-in-time (JIT) compiler support is an optional feature
      of PCRE2 that can be built in appropriate hardware
      environments. It greatly speeds up the matching performance
      of many patterns. Programs can request that it be used if
      available by calling <code class="function">pcre2_jit_compile</code>() after a pattern has
      been successfully compiled by <code class="function">pcre2_compile</code>(). This does nothing if JIT
      support is not available.</p>
      <p>More complicated programs might need to make use of the
      specialist functions <code class="function">pcre2_jit_stack_create</code>(), <code class="function">pcre2_jit_stack_free</code>(), and <code class="function">pcre2_jit_stack_assign</code>() in order to
      control the JIT code's memory usage.</p>
      <p>JIT matching is automatically used by <code class="function">pcre2_match</code>() if it is available, unless
      the PCRE2_NO_JIT option is set. There is also a direct
      interface for JIT matching, which gives improved performance
      at the expense of less sanity checking. The JIT-specific
      functions are discussed in the <a class="link" href="../htmlman3/pcre2jit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2jit</span>(3)</span></a>
      documentation.</p>
      <p>A second matching function, <code class="function">pcre2_dfa_match</code>(), which is not
      Perl-compatible, is also provided. This uses a different
      algorithm for the matching. The alternative algorithm finds
      all possible matches (at a given point in the subject), and
      scans the subject just once (unless there are lookaround
      assertions). However, this algorithm does not return captured
      substrings. A description of the two matching algorithms and
      their advantages and disadvantages is given in the <a class="link" href="../htmlman3/pcre2matching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2matching</span>(3)</span></a>
      documentation. There is no JIT support for <code class="function">pcre2_dfa_match</code>().</p>
      <p>In addition to the main compiling and matching functions,
      there are convenience functions for extracting captured
      substrings from a subject string that has been matched by
      <code class="function">pcre2_match</code>(). They are:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 <code class="function">pcre2_substring_copy_byname</code>()
 <code class="function">pcre2_substring_copy_bynumber</code>()
 <code class="function">pcre2_substring_get_byname</code>()
 <code class="function">pcre2_substring_get_bynumber</code>()
 <code class="function">pcre2_substring_list_get</code>()
 <code class="function">pcre2_substring_length_byname</code>()
 <code class="function">pcre2_substring_length_bynumber</code>()
 <code class="function">pcre2_substring_nametable_scan</code>()
 <code class="function">pcre2_substring_number_from_name</code>()
</pre>
      </div>
      <p><code class="function">pcre2_substring_free</code>() and
      <code class="function">pcre2_substring_list_free</code>() are
      also provided, to free memory used for extracted strings. If
      either of these functions is called with a NULL argument, the
      function returns immediately without doing anything.</p>
      <p>The function <code class="function">pcre2_substitute</code>() can be called to match a
      pattern and return a copy of the subject string with
      substitutions for parts that were matched.</p>
      <p>Functions whose names begin with <code class="function">pcre2_serialize_</code> are used for saving
      compiled patterns on disc or elsewhere, and reloading them
      later.</p>
      <p>Finally, there are functions for finding out information
      about a compiled pattern (<code class="function">pcre2_pattern_info</code>()) and about the
      configuration with which PCRE2 was built (<code class="function">pcre2_config</code>()).</p>
      <p>Functions with names ending with <code class="function">_free</code>() are used for freeing memory blocks
      of various sorts. In all cases, if one of these functions is
      called with a NULL argument, it does nothing.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect15" name="pcre2api-3_sect15" shape="rect"> </a>
      <h2>STRING LENGTHS AND OFFSETS</h2>
      <p>The PCRE2 API uses string lengths and offsets into strings
      of code units in several places. These values are always of
      type PCRE2_SIZE, which is an unsigned integer type, currently
      always defined as <span class="type">size_t</span>. The
      largest value that can be stored in such a type (that is
      ~(PCRE2_SIZE)0) is reserved as a special indicator for
      zero-terminated strings and unset offsets. Therefore, the
      longest string that can be handled is one less than this
      maximum.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect16" name="pcre2api-3_sect16" shape="rect"> </a>
      <h2>NEWLINES</h2>
      <p>PCRE2 supports five different conventions for indicating
      line breaks in strings: a single CR (carriage return)
      character, a single LF (linefeed) character, the
      two-character sequence CRLF, any of the three preceding, or
      any Unicode newline sequence. The Unicode newline sequences
      are the three just mentioned, plus the single characters VT
      (vertical tab, U+000B), FF (form feed, U+000C), NEL (next
      line, U+0085), LS (line separator, U+2028), and PS (paragraph
      separator, U+2029).</p>
      <p>Each of the first three conventions is used by at least
      one operating system as its standard newline sequence. When
      PCRE2 is built, a default can be specified. If it is not, the
      default is set to LF, which is the Unix standard. However,
      the newline convention can be changed by an application when
      calling <code class="function">pcre2_compile</code>(), or it
      can be specified by special text at the start of the pattern
      itself; this overrides any other settings. See the <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a> page for
      details of the special character sequences.</p>
      <p>In the PCRE2 documentation the word "newline" is used to
      mean "the character or pair of characters that indicate a
      line break". The choice of newline convention affects the
      handling of the dot, circumflex, and dollar metacharacters,
      the handling of #-comments in /x mode, and, when CRLF is a
      recognized line ending sequence, the match position
      advancement for a non-anchored pattern. There is more detail
      about this in the section on <code class="function">pcre2_match</code>() options below.</p>
      <p>The choice of newline convention does not affect the
      interpretation of the \n or \r escape sequences, nor does it
      affect what \R matches; this has its own separate
      convention.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect17" name="pcre2api-3_sect17" shape="rect"> </a>
      <h2>MULTITHREADING</h2>
      <p>In a multithreaded application it is important to keep
      thread-specific data separate from data that can be shared
      between threads. The PCRE2 library code itself is
      thread-safe: it contains no static or global variables. The
      API is designed to be fairly simple for non-threaded
      applications while at the same time ensuring that
      multithreaded applications can use it.</p>
      <p>There are several different blocks of data that are used
      to pass information between the application and the PCRE2
      libraries.</p>
      <div class="refsect2">
        <a id="pcre2api-3_sect18" name="pcre2api-3_sect18" shape="rect"> </a>
        <h3>The compiled pattern</h3>
        <p>A pointer to the compiled form of a pattern is returned
        to the user when <code class="function">pcre2_compile</code>() is successful. The data
        in the compiled pattern is fixed, and does not change when
        the pattern is matched. Therefore, it is thread-safe, that
        is, the same compiled pattern can be used by more than one
        thread simultaneously. For example, an application can
        compile all its patterns at the start, before forking off
        multiple threads that use them. However, if the
        just-in-time (JIT) optimization feature is being used, it
        needs separate memory stack areas for each thread. See the
        <a class="link" href="../htmlman3/pcre2jit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2jit</span>(3)</span></a> documentation
        for more details.</p>
        <p>In a more complicated situation, where patterns are
        compiled only when they are first needed, but are still
        shared between threads, pointers to compiled patterns must
        be protected from simultaneous writing by multiple threads.
        This is somewhat tricky to do correctly. If you know that
        writing to a pointer is atomic in your environment, you can
        use logic like this:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 Get a read-only (shared) lock (mutex) for pointer
 if (pointer == NULL)
   {
   Get a write (unique) lock for pointer
   if (pointer == NULL) pointer = pcre2_compile(...
   }
 Release the lock
 Use pointer in pcre2_match()
</pre>
        </div>
        <p>Of course, testing for compilation errors should also be
        included in the code.</p>
        <p>The reason for checking the pointer a second time is as
        follows: Several threads may have acquired the shared lock
        and tested the pointer for being NULL, but only one of them
        will be given the write lock, with the rest kept waiting.
        The winning thread will compile the pattern and store the
        result. After this thread releases the write lock, another
        thread will get it, and if it does not retest pointer for
        being NULL, will recompile the pattern and overwrite the
        pointer, creating a memory leak and possibly causing other
        issues.</p>
        <p>In an environment where writing to a pointer may not be
        atomic, the above logic is not sufficient. The thread that
        is doing the compiling may be descheduled after writing
        only part of the pointer, which could cause other threads
        to use an invalid value. Instead of checking the pointer
        itself, a separate "pointer is valid" flag (that can be
        updated atomically) must be used:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 Get a read-only (shared) lock (mutex) for pointer
 if (!pointer_is_valid)
   {
   Get a write (unique) lock for pointer
   if (!pointer_is_valid)
     {
     pointer = pcre2_compile(...
     pointer_is_valid = TRUE
     }
   }
 Release the lock
 Use pointer in pcre2_match()
</pre>
        </div>
        <p>If JIT is being used, but the JIT compilation is not
        being done immediately (perhaps waiting to see if the
        pattern is used often enough), similar logic is required.
        JIT compilation updates a value within the compiled code
        block, so a thread must gain unique write access to the
        pointer before calling <code class="function">pcre2_jit_compile</code>(). Alternatively,
        <code class="function">pcre2_code_copy</code>() or
        <code class="function">pcre2_code_copy_with_tables</code>()
        can be used to obtain a private copy of the compiled code
        before calling the JIT compiler.</p>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect19" name="pcre2api-3_sect19" shape="rect"> </a>
        <h3>Context blocks</h3>
        <p>The next main section below introduces the idea of
        "contexts" in which PCRE2 functions are called. A context
        is nothing more than a collection of parameters that
        control the way PCRE2 operates. Grouping a number of
        parameters together in a context is a convenient way of
        passing them to a PCRE2 function without using lots of
        arguments. The parameters that are stored in contexts are
        in some sense "advanced features" of the API. Many
        straightforward applications will not need to use
        contexts.</p>
        <p>In a multithreaded application, if the parameters in a
        context are values that are never changed, the same context
        can be used by all the threads. However, if any thread
        needs to change any value in a context, it must make its
        own thread-specific copy.</p>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect20" name="pcre2api-3_sect20" shape="rect"> </a>
        <h3>Match blocks</h3>
        <p>The matching functions need a block of memory for
        storing the results of a match. This includes details of
        what was matched, as well as additional information such as
        the name of a (*MARK) setting. Each thread must provide its
        own copy of this memory.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect21" name="pcre2api-3_sect21" shape="rect"> </a>
      <h2>PCRE2 CONTEXTS</h2>
      <p>Some PCRE2 functions have a lot of parameters, many of
      which are used only by specialist applications, for example,
      those that use custom memory management or non-standard
      character tables. To keep function argument lists at a
      reasonable size, and at the same time to keep the API
      extensible, "uncommon" parameters are passed to certain
      functions in a <code class="function">context</code> instead
      of directly. A context is just a block of memory that holds
      the parameter values. Applications that do not need to adjust
      any of the context parameters can pass NULL when a context
      pointer is required.</p>
      <p>There are three different types of context: a general
      context that is relevant for several PCRE2 operations, a
      compile-time context, and a match-time context.</p>
      <div class="refsect2">
        <a id="pcre2api-3_sect22" name="pcre2api-3_sect22" shape="rect"> </a>
        <h3>The general context</h3>
        <p>At present, this context just contains pointers to (and
        data for) external memory management functions that are
        called from several places in the PCRE2 library. The
        context is named `general' rather than specifically
        `memory' because in future other fields may be added. If
        you do not want to supply your own custom memory management
        functions, you do not need to bother with a general
        context. A general context is created by:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_general_context *pcre2_general_context_create(</em></span>
<span class="emphasis"><em>  void *(*<code class="function">private_malloc</code>)(PCRE2_SIZE, void *),</em></span>
<span class="emphasis"><em>  void (*<code class="function">private_free</code>)(void *, void *), void *<code class="function">memory_data</code>);</em></span>
</pre>
        </div>
        <p>The two function pointers specify custom memory
        management functions, whose prototypes are:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 <span class="emphasis"><em>void *private_malloc(PCRE2_SIZE, void *);</em></span>
 <span class="emphasis"><em>void  private_free(void *, void *);</em></span>
</pre>
        </div>
        <p>Whenever code in PCRE2 calls these functions, the final
        argument is the value of <code class="function">memory_data</code>. Either of the first two
        arguments of the creation function may be NULL, in which
        case the system memory management functions <code class="function">malloc</code>() and <code class="function">free</code>() are used. (This is not currently
        useful, as there are no other fields in a general context,
        but in future there might be.) The <code class="function">private_malloc</code>() function is used (if
        supplied) to obtain memory for storing the context, and all
        three values are saved as part of the context.</p>
        <p>Whenever PCRE2 creates a data block of any kind, the
        block contains a pointer to the <code class="function">free</code>() function that matches the
        <code class="function">malloc</code>() function that was
        used. When the time comes to free the block, this function
        is called.</p>
        <p>A general context can be copied by calling:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_general_context *pcre2_general_context_copy(</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>
</pre>
        </div>
        <p>The memory used for a general context should be freed by
        calling:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>void pcre2_general_context_free(pcre2_general_context *<code class="function">gcontext</code>);</em></span>
</pre>
        </div>
        <p>If this function is passed a NULL argument, it returns
        immediately without doing anything.</p>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect23" name="pcre2api-3_sect23" shape="rect"> </a>
        <h3>The compile context</h3>
        <p>A compile context is required if you want to provide an
        external function for stack checking during compilation or
        to change the default values of any of the following
        compile-time parameters:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 What \R matches (Unicode newlines or CR, LF, CRLF only)
 PCRE2's character tables
 The newline character sequence
 The compile time nested parentheses limit
 The maximum length of the pattern string
 The extra options bits (none set by default)
</pre>
        </div>
        <p>A compile context is also required if you are using
        custom memory management. If none of these apply, just pass
        NULL as the context argument of <code class="function">pcre2_compile</code>().</p>
        <p>A compile context is created, copied, and freed by the
        following functions:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_compile_context *pcre2_compile_context_create(</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_compile_context *pcre2_compile_context_copy(</em></span>
<span class="emphasis"><em>  pcre2_compile_context *<code class="function">ccontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_compile_context_free(pcre2_compile_context *<code class="function">ccontext</code>);</em></span>
</pre>
        </div>
        <p>A compile context is created with default values for its
        parameters. These can be changed by calling the following
        functions, which return 0 on success, or
        PCRE2_ERROR_BADDATA if invalid data is detected.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_bsr(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>
</pre>
        </div>
        <p>The value must be PCRE2_BSR_ANYCRLF, to specify that \R
        matches only CR, LF, or CRLF, or PCRE2_BSR_UNICODE, to
        specify that \R matches any Unicode line ending sequence.
        The value is used by the JIT compiler and by the two
        interpreted matching functions, <code class="function">pcre2_match</code>() and <code class="function">pcre2_dfa_match</code>().</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_character_tables(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  const uint8_t *<code class="function">tables</code>);</em></span>
</pre>
        </div>
        <p>The value must be the result of a call to <code class="function">pcre2_maketables</code>(), whose only argument
        is a general context. This function builds a set of
        character tables in the current locale.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_compile_extra_options(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">extra_options</code>);</em></span>
</pre>
        </div>
        <p>As PCRE2 has developed, almost all the 32 option bits
        that are available in the <code class="function">options</code> argument of <code class="function">pcre2_compile</code>() have been used up. To
        avoid running out, the compile context contains a set of
        extra option bits which are used for some newer, assumed
        rarer, options. This function sets those bits. It always
        sets all the bits (either on or off). It does not modify
        any existing setting. The available options are defined in
        the section entitled "Extra compile options" below.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_max_pattern_length(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">value</code>);</em></span>
</pre>
        </div>
        <p>This sets a maximum length, in code units, for any
        pattern string that is compiled with this context. If the
        pattern is longer, an error is generated. This facility is
        provided so that applications that accept patterns from
        external sources can limit their size. The default is the
        largest number that a PCRE2_SIZE variable can hold, which
        is effectively unlimited.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_newline(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>
</pre>
        </div>
        <p>This specifies which characters or character sequences
        are to be recognized as newlines. The value must be one of
        PCRE2_NEWLINE_CR (carriage return only), PCRE2_NEWLINE_LF
        (linefeed only), PCRE2_NEWLINE_CRLF (the two-character
        sequence CR followed by LF), PCRE2_NEWLINE_ANYCRLF (any of
        the above), PCRE2_NEWLINE_ANY (any Unicode newline
        sequence), or PCRE2_NEWLINE_NUL (the NUL character, that is
        a binary zero).</p>
        <p>A pattern can override the value set in the compile
        context by starting with a sequence such as (*CRLF). See
        the <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a> page for
        details.</p>
        <p>When a pattern is compiled with the PCRE2_EXTENDED or
        PCRE2_EXTENDED_MORE option, the newline convention affects
        the recognition of the end of internal comments starting
        with #. The value is saved with the compiled pattern for
        subsequent use by the JIT compiler and by the two
        interpreted matching functions, <code class="function">pcre2_match</code>() and <code class="function">pcre2_dfa_match</code>().</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_parens_nest_limit(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>
</pre>
        </div>
        <p>This parameter adjusts the limit, set when PCRE2 is
        built (default 250), on the depth of parenthesis nesting in
        a pattern. This limit stops rogue patterns using up too
        much system stack when being compiled. The limit applies to
        parentheses of all kinds, not just capturing
        parentheses.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_compile_recursion_guard(pcre2_compile_context *<code class="function">ccontext</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">guard_function</code>)(uint32_t, void *), void *<code class="function">user_data</code>);</em></span>
</pre>
        </div>
        <p>There is at least one application that runs PCRE2 in
        threads with very limited system stack, where running out
        of stack is to be avoided at all costs. The parenthesis
        limit above cannot take account of how much stack is
        actually available during compilation. For a finer control,
        you can supply a function that is called whenever
        <code class="function">pcre2_compile</code>() starts to
        compile a parenthesized part of a pattern. This function
        can check the actual stack size (or anything else that it
        wants to, of course).</p>
        <p>The first argument to the callout function gives the
        current depth of nesting, and the second is user data that
        is set up by the last argument of <code class="function">pcre2_set_compile_recursion_guard</code>(). The
        callout function should return zero if all is well, or
        non-zero to force an error.</p>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect24" name="pcre2api-3_sect24" shape="rect"> </a>
        <h3>The match context</h3>
        <p>A match context is required if you want to:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 Set up a callout function
 Set an offset limit for matching an unanchored pattern
 Change the limit on the amount of heap used when matching
 Change the backtracking match limit
 Change the backtracking depth limit
 Set custom memory management specifically for the match
</pre>
        </div>
        <p>If none of these apply, just pass NULL as the context
        argument of <code class="function">pcre2_match</code>(),
        <code class="function">pcre2_dfa_match</code>(), or
        <code class="function">pcre2_jit_match</code>().</p>
        <p>A match context is created, copied, and freed by the
        following functions:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_match_context *pcre2_match_context_create(</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_match_context *pcre2_match_context_copy(</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_match_context_free(pcre2_match_context *<code class="function">mcontext</code>);</em></span>
</pre>
        </div>
        <p>A match context is created with default values for its
        parameters. These can be changed by calling the following
        functions, which return 0 on success, or
        PCRE2_ERROR_BADDATA if invalid data is detected.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_callout(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">callout_function</code>)(pcre2_callout_block *, void *),</em></span>
<span class="emphasis"><em>  void *<code class="function">callout_data</code>);</em></span>
</pre>
        </div>
        <p>This sets up a callout function for PCRE2 to call at
        specified points during a matching operation. Details are
        given in the <a class="link" href="../htmlman3/pcre2callout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2callout</span>(3)</span></a>
        documentation.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_substitute_callout(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">callout_function</code>)(pcre2_substitute_callout_block *, void *),</em></span>
<span class="emphasis"><em>  void *<code class="function">callout_data</code>);</em></span>
</pre>
        </div>
        <p>This sets up a callout function for PCRE2 to call after
        each substitution made by <code class="function">pcre2_substitute</code>(). Details are given in
        the section entitled "Creating a new string with
        substitutions" below.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_offset_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">value</code>);</em></span>
</pre>
        </div>
        <p>The <code class="function">offset_limit</code> parameter
        limits how far an unanchored search can advance in the
        subject string. The default value is PCRE2_UNSET. The
        <code class="function">pcre2_match</code>() and
        <code class="function">pcre2_dfa_match</code>() functions
        return PCRE2_ERROR_NOMATCH if a match with a starting point
        before or at the given offset is not found. The
        <code class="function">pcre2_substitute</code>() function
        makes no more substitutions.</p>
        <p>For example, if the pattern /abc/ is matched against
        "123abc" with an offset limit less than 3, the result is
        PCRE2_ERROR_NOMATCH. A match can never be found if the
        <code class="function">startoffset</code> argument of
        <code class="function">pcre2_match</code>(), <code class="function">pcre2_dfa_match</code>(), or <code class="function">pcre2_substitute</code>() is greater than the
        offset limit set in the match context.</p>
        <p>When using this facility, you must set the
        PCRE2_USE_OFFSET_LIMIT option when calling <code class="function">pcre2_compile</code>() so that when JIT is in
        use, different code can be compiled. If a match is started
        with a non-default match limit when PCRE2_USE_OFFSET_LIMIT
        is not set, an error is generated.</p>
        <p>The offset limit facility can be used to track progress
        when searching large subject strings or to limit the extent
        of global substitutions. See also the PCRE2_FIRSTLINE
        option, which requires a match to start before or at the
        first newline that follows the start of matching in the
        subject. If this is set with an offset limit, a match must
        occur in the first line and also within the offset limit.
        In other words, whichever limit comes first is used.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_heap_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>
</pre>
        </div>
        <p>The <code class="function">heap_limit</code> parameter
        specifies, in units of kibibytes (1024 bytes), the maximum
        amount of heap memory that <code class="function">pcre2_match</code>() may use to hold
        backtracking information when running an interpretive
        match. This limit also applies to <code class="function">pcre2_dfa_match</code>(), which may use the heap
        when processing patterns with a lot of nested pattern
        recursion or lookarounds or atomic groups. This limit does
        not apply to matching with the JIT optimization, which has
        its own memory control arrangements (see the <a class="link" href="../htmlman3/pcre2jit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2jit</span>(3)</span></a> documentation
        for more details). If the limit is reached, the negative
        error code PCRE2_ERROR_HEAPLIMIT is returned. The default
        limit can be set when PCRE2 is built; if it is not, the
        default is set very large and is essentially
        "unlimited".</p>
        <p>A value for the heap limit may also be supplied by an
        item at the start of a pattern of the form</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*LIMIT_HEAP=ddd)
</pre>
        </div>
        <p>where ddd is a decimal number. However, such a setting
        is ignored unless ddd is less than the limit set by the
        caller of <code class="function">pcre2_match</code>() or,
        if no such limit is set, less than the default.</p>
        <p>The <code class="function">pcre2_match</code>() function
        starts out using a 20KiB vector on the system stack for
        recording backtracking points. The more nested backtracking
        points there are (that is, the deeper the search tree), the
        more memory is needed. Heap memory is used only if the
        initial vector is too small. If the heap limit is set to a
        value less than 21 (in particular, zero) no heap memory
        will be used. In this case, only patterns that do not have
        a lot of nested backtracking can be successfully
        processed.</p>
        <p>Similarly, for <code class="function">pcre2_dfa_match</code>(), a vector on the system
        stack is used when processing pattern recursions,
        lookarounds, or atomic groups, and only if this is not big
        enough is heap memory used. In this case, too, setting a
        value of zero disables the use of the heap.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_match_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>
</pre>
        </div>
        <p>The <code class="function">match_limit</code> parameter
        provides a means of preventing PCRE2 from using up too many
        computing resources when processing patterns that are not
        going to match, but which have a very large number of
        possibilities in their search trees. The classic example is
        a pattern that uses nested unlimited repeats.</p>
        <p>There is an internal counter in <code class="function">pcre2_match</code>() that is incremented each
        time round its main matching loop. If this value reaches
        the match limit, <code class="function">pcre2_match</code>() returns the negative value
        PCRE2_ERROR_MATCHLIMIT. This has the effect of limiting the
        amount of backtracking that can take place. For patterns
        that are not anchored, the count restarts from zero for
        each position in the subject string. This limit also
        applies to <code class="function">pcre2_dfa_match</code>(),
        though the counting is done in a different way.</p>
        <p>When <code class="function">pcre2_match</code>() is
        called with a pattern that was successfully processed by
        <code class="function">pcre2_jit_compile</code>(), the way
        in which matching is executed is entirely different.
        However, there is still the possibility of runaway matching
        that goes on for a very long time, and so the <code class="function">match_limit</code> value is also used in this
        case (but in a different way) to limit how long the
        matching can continue.</p>
        <p>The default value for the limit can be set when PCRE2 is
        built; the default default is 10 million, which handles all
        but the most extreme cases. A value for the match limit may
        also be supplied by an item at the start of a pattern of
        the form</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*LIMIT_MATCH=ddd)
</pre>
        </div>
        <p>where ddd is a decimal number. However, such a setting
        is ignored unless ddd is less than the limit set by the
        caller of <code class="function">pcre2_match</code>() or
        <code class="function">pcre2_dfa_match</code>() or, if no
        such limit is set, less than the default.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_depth_limit(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">value</code>);</em></span>
</pre>
        </div>
        <p>This parameter limits the depth of nested backtracking
        in <code class="function">pcre2_match</code>(). Each time a
        nested backtracking point is passed, a new memory "frame"
        is used to remember the state of matching at that point.
        Thus, this parameter indirectly limits the amount of memory
        that is used in a match. However, because the size of each
        memory "frame" depends on the number of capturing
        parentheses, the actual memory limit varies from pattern to
        pattern. This limit was more useful in versions before
        10.30, where function recursion was used for
        backtracking.</p>
        <p>The depth limit is not relevant, and is ignored, when
        matching is done using JIT compiled code. However, it is
        supported by <code class="function">pcre2_dfa_match</code>(), which uses it to limit
        the depth of nested internal recursive function calls that
        implement atomic groups, lookaround assertions, and pattern
        recursions. This limits, indirectly, the amount of system
        stack that is used. It was more useful in versions before
        10.32, when stack memory was used for local workspace
        vectors for recursive function calls. From version 10.32,
        only local variables are allocated on the stack and as each
        call uses only a few hundred bytes, even a small stack can
        support quite a lot of recursion.</p>
        <p>If the depth of internal recursive function calls is
        great enough, local workspace vectors are allocated on the
        heap from version 10.32 onwards, so the depth limit also
        indirectly limits the amount of heap memory that is used. A
        recursive pattern such as /(.(?2))((?1)|)/, when matched to
        a very long string using <code class="function">pcre2_dfa_match</code>(), can use a great deal
        of memory. However, it is probably better to limit heap
        usage directly by calling <code class="function">pcre2_set_heap_limit</code>().</p>
        <p>The default value for the depth limit can be set when
        PCRE2 is built; if it is not, the default is set to the
        same value as the default for the match limit. If the limit
        is exceeded, <code class="function">pcre2_match</code>() or
        <code class="function">pcre2_dfa_match</code>() returns
        PCRE2_ERROR_DEPTHLIMIT. A value for the depth limit may
        also be supplied by an item at the start of a pattern of
        the form</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*LIMIT_DEPTH=ddd)
</pre>
        </div>
        <p>where ddd is a decimal number. However, such a setting
        is ignored unless ddd is less than the limit set by the
        caller of <code class="function">pcre2_match</code>() or
        <code class="function">pcre2_dfa_match</code>() or, if no
        such limit is set, less than the default.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect25" name="pcre2api-3_sect25" shape="rect"> </a>
      <h2>CHECKING BUILD-TIME OPTIONS</h2>
      <p><span class="emphasis"><em>int pcre2_config(uint32_t
      <code class="function">what</code>, void *<code class="function">where</code>);</em></span></p>
      <p>The function <code class="function">pcre2_config</code>()
      makes it possible for a PCRE2 client to find the value of
      certain configuration parameters and to discover which
      optional features have been compiled into the PCRE2 library.
      The <a class="link" href="../htmlman3/pcre2build.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2build</span>(3)</span></a> documentation
      has more details about these features.</p>
      <p>The first argument for <code class="function">pcre2_config</code>() specifies which information
      is required. The second argument is a pointer to memory into
      which the information is placed. If NULL is passed, the
      function returns the amount of memory that is needed for the
      requested information. For calls that return numerical
      values, the value is in bytes; when requesting these values,
      <code class="function">where</code> should point to
      appropriately aligned memory. For calls that return strings,
      the required length is given in code units, not counting the
      terminating zero.</p>
      <p>When requesting information, the returned value from
      <code class="function">pcre2_config</code>() is non-negative
      on success, or the negative error code PCRE2_ERROR_BADOPTION
      if the value in the first argument is not recognized. The
      following information is available:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_BSR
</pre>
      </div>
      <p>The output is a uint32_t integer whose value indicates
      what character sequences the \R escape sequence matches by
      default. A value of PCRE2_BSR_UNICODE means that \R matches
      any Unicode line ending sequence; a value of
      PCRE2_BSR_ANYCRLF means that \R matches only CR, LF, or CRLF.
      The default can be overridden when a pattern is compiled.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_COMPILED_WIDTHS
</pre>
      </div>
      <p>The output is a uint32_t integer whose lower bits indicate
      which code unit widths were selected when PCRE2 was built.
      The 1-bit indicates 8-bit support, and the 2-bit and 4-bit
      indicate 16-bit and 32-bit support, respectively.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_DEPTHLIMIT
</pre>
      </div>
      <p>The output is a uint32_t integer that gives the default
      limit for the depth of nested backtracking in <code class="function">pcre2_match</code>() or the depth of nested
      recursions, lookarounds, and atomic groups in <code class="function">pcre2_dfa_match</code>(). Further details are
      given with <code class="function">pcre2_set_depth_limit</code>() above.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_HEAPLIMIT
</pre>
      </div>
      <p>The output is a uint32_t integer that gives, in kibibytes,
      the default limit for the amount of heap memory used by
      <code class="function">pcre2_match</code>() or <code class="function">pcre2_dfa_match</code>(). Further details are
      given with <code class="function">pcre2_set_heap_limit</code>() above.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_JIT
</pre>
      </div>
      <p>The output is a uint32_t integer that is set to one if
      support for just-in-time compiling is available; otherwise it
      is set to zero.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_JITTARGET
</pre>
      </div>
      <p>The <code class="function">where</code> argument should
      point to a buffer that is at least 48 code units long. (The
      exact length required can be found by calling <code class="function">pcre2_config</code>() with <code class="function">where</code> set to NULL.) The buffer is filled
      with a string that contains the name of the architecture for
      which the JIT compiler is configured, for example "x86 32bit
      (little endian + unaligned)". If JIT support is not
      available, PCRE2_ERROR_BADOPTION is returned, otherwise the
      number of code units used is returned. This is the length of
      the string, plus one unit for the terminating zero.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_LINKSIZE
</pre>
      </div>
      <p>The output is a uint32_t integer that contains the number
      of bytes used for internal linkage in compiled regular
      expressions. When PCRE2 is configured, the value can be set
      to 2, 3, or 4, with the default being 2. This is the value
      that is returned by <code class="function">pcre2_config</code>(). However, when the 16-bit
      library is compiled, a value of 3 is rounded up to 4, and
      when the 32-bit library is compiled, internal linkages always
      use 4 bytes, so the configured value is not relevant.</p>
      <p>The default value of 2 for the 8-bit and 16-bit libraries
      is sufficient for all but the most massive patterns, since it
      allows the size of the compiled pattern to be up to 65535
      code units. Larger values allow larger regular expressions to
      be compiled by those two libraries, but at the expense of
      slower matching.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_MATCHLIMIT
</pre>
      </div>
      <p>The output is a uint32_t integer that gives the default
      match limit for <code class="function">pcre2_match</code>().
      Further details are given with <code class="function">pcre2_set_match_limit</code>() above.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_NEWLINE
</pre>
      </div>
      <p>The output is a uint32_t integer whose value specifies the
      default character sequence that is recognized as meaning
      "newline". The values are:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE2_NEWLINE_CR       Carriage return (CR)
 PCRE2_NEWLINE_LF       Linefeed (LF)
 PCRE2_NEWLINE_CRLF     Carriage return, linefeed (CRLF)
 PCRE2_NEWLINE_ANY      Any Unicode line ending
 PCRE2_NEWLINE_ANYCRLF  Any of CR, LF, or CRLF
 PCRE2_NEWLINE_NUL      The NUL character (binary zero)
</pre>
      </div>
      <p>The default should normally correspond to the standard
      sequence for your operating system.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_NEVER_BACKSLASH_C
</pre>
      </div>
      <p>The output is a uint32_t integer that is set to one if the
      use of \C was permanently disabled when PCRE2 was built;
      otherwise it is set to zero.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_PARENSLIMIT
</pre>
      </div>
      <p>The output is a uint32_t integer that gives the maximum
      depth of nesting of parentheses (of any kind) in a pattern.
      This limit is imposed to cap the amount of system stack used
      when a pattern is compiled. It is specified when PCRE2 is
      built; the default is 250. This limit does not take into
      account the stack that may already be used by the calling
      application. For finer control over compilation stack usage,
      see <code class="function">pcre2_set_compile_recursion_guard</code>().</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_STACKRECURSE
</pre>
      </div>
      <p>This parameter is obsolete and should not be used in new
      code. The output is a uint32_t integer that is always set to
      zero.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_TABLES_LENGTH
</pre>
      </div>
      <p>The output is a uint32_t integer that gives the length of
      PCRE2's character processing tables in bytes. For details of
      these tables see the section on locale support below.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_UNICODE_VERSION
</pre>
      </div>
      <p>The <code class="function">where</code> argument should
      point to a buffer that is at least 24 code units long. (The
      exact length required can be found by calling <code class="function">pcre2_config</code>() with <code class="function">where</code> set to NULL.) If PCRE2 has been
      compiled without Unicode support, the buffer is filled with
      the text "Unicode not supported". Otherwise, the Unicode
      version string (for example, "8.0.0") is inserted. The number
      of code units used is returned. This is the length of the
      string plus one unit for the terminating zero.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_UNICODE
</pre>
      </div>
      <p>The output is a uint32_t integer that is set to one if
      Unicode support is available; otherwise it is set to zero.
      Unicode support implies UTF support.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_CONFIG_VERSION
</pre>
      </div>
      <p>The <code class="function">where</code> argument should
      point to a buffer that is at least 24 code units long. (The
      exact length required can be found by calling <code class="function">pcre2_config</code>() with <code class="function">where</code> set to NULL.) The buffer is filled
      with the PCRE2 version string, zero-terminated. The number of
      code units used is returned. This is the length of the string
      plus one unit for the terminating zero.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect26" name="pcre2api-3_sect26" shape="rect"> </a>
      <h2>COMPILING A PATTERN</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_code *pcre2_compile(PCRE2_SPTR <code class="function">pattern</code>, PCRE2_SIZE <code class="function">length</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, int *<code class="function">errorcode</code>, PCRE2_SIZE *<em class="replaceable"><code>erroroffset,</code></em></em></span>
<span class="emphasis"><em>  pcre2_compile_context *<code class="function">ccontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_code_free(pcre2_code *<code class="function">code</code>);</em></span>

<span class="emphasis"><em>pcre2_code *pcre2_code_copy(const pcre2_code *<code class="function">code</code>);</em></span>

<span class="emphasis"><em>pcre2_code *pcre2_code_copy_with_tables(const pcre2_code *<code class="function">code</code>);</em></span>
</pre>
      </div>
      <p>The <code class="function">pcre2_compile</code>() function
      compiles a pattern into an internal form. The pattern is
      defined by a pointer to a string of code units and a length
      (in code units). If the pattern is zero-terminated, the
      length can be specified as PCRE2_ZERO_TERMINATED. The
      function returns a pointer to a block of memory that contains
      the compiled pattern and related data, or NULL if an error
      occurred.</p>
      <p>If the compile context argument <code class="function">ccontext</code> is NULL, memory for the compiled
      pattern is obtained by calling <code class="function">malloc</code>(). Otherwise, it is obtained from
      the same memory function that was used for the compile
      context. The caller must free the memory by calling
      <code class="function">pcre2_code_free</code>() when it is no
      longer needed. If <code class="function">pcre2_code_free</code>() is called with a NULL
      argument, it returns immediately, without doing anything.</p>
      <p>The function <code class="function">pcre2_code_copy</code>() makes a copy of the
      compiled code in new memory, using the same memory allocator
      as was used for the original. However, if the code has been
      processed by the JIT compiler (see below), the JIT
      information cannot be copied (because it is
      position-dependent). The new copy can initially be used only
      for non-JIT matching, though it can be passed to <code class="function">pcre2_jit_compile</code>() if required. If
      <code class="function">pcre2_code_copy</code>() is called
      with a NULL argument, it returns NULL.</p>
      <p>The <code class="function">pcre2_code_copy</code>()
      function provides a way for individual threads in a
      multithreaded application to acquire a private copy of shared
      compiled code. However, it does not make a copy of the
      character tables used by the compiled pattern; the new
      pattern code points to the same tables as the original code.
      (See "Locale Support" below for details of these character
      tables.) In many applications the same tables are used
      throughout, so this behaviour is appropriate. Nevertheless,
      there are occasions when a copy of a compiled pattern and the
      relevant tables are needed. The <code class="function">pcre2_code_copy_with_tables</code>() provides this
      facility. Copies of both the code and the tables are made,
      with the new code pointing to the new tables. The memory for
      the new tables is automatically freed when <code class="function">pcre2_code_free</code>() is called for the new
      copy of the compiled code. If <code class="function">pcre2_code_copy_with_tables</code>() is called
      with a NULL argument, it returns NULL.</p>
      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Note">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Note]" src="../stylesheet/note.png" /></td>
            <th align="left" rowspan="1" colspan="1">Note</th>
          </tr>
          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <p>When one of the matching functions is called,
              pointers to the compiled pattern and the subject
              string are set in the match data block so that they
              can be referenced by the substring extraction
              functions after a successful match. After running a
              match, you must not free a compiled pattern or a
              subject string until after all operations on the
              match data block have taken place, unless, in the
              case of the subject string, you have used the
              PCRE2_COPY_MATCHED_SUBJECT option, which is described
              in the section entitled "Option bits for <code class="function">pcre2_match</code>()" below.</p>
            </td>
          </tr>
        </table>
      </div>
      <p>The <code class="function">options</code> argument for
      <code class="function">pcre2_compile</code>() contains
      various bit settings that affect the compilation. It should
      be zero if none of them are required. The available options
      are described below. Some of them (in particular, those that
      are compatible with Perl, but some others as well) can also
      be set and unset from within the pattern (see the detailed
      description in the <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a>
      documentation).</p>
      <p>For those options that can be different in different parts
      of the pattern, the contents of the <code class="function">options</code> argument specifies their settings
      at the start of compilation. The PCRE2_ANCHORED,
      PCRE2_ENDANCHORED, and PCRE2_NO_UTF_CHECK options can be set
      at the time of matching as well as at compile time.</p>
      <p>Some additional options and less frequently required
      compile-time parameters (for example, the newline setting)
      can be provided in a compile context (as described
      above).</p>
      <p>If <code class="function">errorcode</code> or <code class="function">erroroffset</code> is NULL, <code class="function">pcre2_compile</code>() returns NULL immediately.
      Otherwise, the variables to which these point are set to an
      error code and an offset (number of code units) within the
      pattern, respectively, when <code class="function">pcre2_compile</code>() returns NULL because a
      compilation error has occurred. The values are not defined
      when compilation is successful and <code class="function">pcre2_compile</code>() returns a non-NULL
      value.</p>
      <p>There are nearly 100 positive error codes that
      <code class="function">pcre2_compile</code>() may return if
      it finds an error in the pattern. There are also some
      negative error codes that are used for invalid UTF strings
      when validity checking is in force. These are the same as
      given by <code class="function">pcre2_match</code>() and
      <code class="function">pcre2_dfa_match</code>(), and are
      described in the <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a>
      documentation. There is no separate documentation for the
      positive error codes, because the textual error messages that
      are obtained by calling the <code class="function">pcre2_get_error_message</code>() function (see
      "Obtaining a textual error message" below) should be
      self-explanatory. Macro names starting with PCRE2_ERROR_ are
      defined for both positive and negative error codes in
      <code class="filename">pcre2.h</code>.</p>
      <p>The value returned in <code class="function">erroroffset</code> is an indication of where in
      the pattern the error occurred. It is not necessarily the
      furthest point in the pattern that was read. For example,
      after the error "lookbehind assertion is not fixed length",
      the error offset points to the start of the failing
      assertion. For an invalid UTF-8 or UTF-16 string, the offset
      is that of the first code unit of the failing character.</p>
      <p>Some errors are not detected until the whole pattern has
      been scanned; in these cases, the offset passed back is the
      length of the pattern. Note that the offset is in code units,
      not characters, even in a UTF mode. It may sometimes point
      into the middle of a UTF-8 or UTF-16 character.</p>
      <p>This code fragment shows a typical straightforward call to
      <code class="function">pcre2_compile</code>():</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 pcre2_code *re;
 PCRE2_SIZE erroffset;
 int errorcode;
 re = pcre2_compile(
   "^A.*Z",                /* the pattern */
   PCRE2_ZERO_TERMINATED,  /* the pattern is zero-terminated */
   0,                      /* default options */
   &amp;errorcode,             /* for error code */
   &amp;erroffset,             /* for error offset */
   NULL);                  /* no compile context */
</pre>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect27" name="pcre2api-3_sect27" shape="rect"> </a>
        <h3>Main compile options</h3>
        <p>The following names for option bits are defined in the
        <code class="filename">pcre2.h</code> header file:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ANCHORED
</pre>
        </div>
        <p>If this bit is set, the pattern is forced to be
        "anchored", that is, it is constrained to match only at the
        first matching point in the string that is being searched
        (the "subject string"). This effect can also be achieved by
        appropriate constructs in the pattern itself, which is the
        only way to do it in Perl.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ALLOW_EMPTY_CLASS
</pre>
        </div>
        <p>By default, for compatibility with Perl, a closing
        square bracket that immediately follows an opening one is
        treated as a data character for the class. When
        PCRE2_ALLOW_EMPTY_CLASS is set, it terminates the class,
        which therefore contains no characters and so can never
        match.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ALT_BSUX
</pre>
        </div>
        <p>This option request alternative handling of three escape
        sequences, which makes PCRE2's behaviour more like
        ECMAscript (aka JavaScript). When it is set:</p>
        <p>(1) \U matches an upper case "U" character; by default
        \U causes a compile time error (Perl uses \U to upper case
        subsequent characters).</p>
        <p>(2) \u matches a lower case "u" character unless it is
        followed by four hexadecimal digits, in which case the
        hexadecimal number defines the code point to match. By
        default, \u causes a compile time error (Perl uses it to
        upper case the following character).</p>
        <p>(3) \x matches a lower case "x" character unless it is
        followed by two hexadecimal digits, in which case the
        hexadecimal number defines the code point to match. By
        default, as in Perl, a hexadecimal number is always
        expected after \x, but it may have zero, one, or two digits
        (so, for example, \xz matches a binary zero character
        followed by z).</p>
        <p>ECMAscript 6 added additional functionality to \u. This
        can be accessed using the PCRE2_EXTRA_ALT_BSUX extra option
        (see "Extra compile options" below). Note that this
        alternative escape handling applies only to patterns.
        Neither of these options affects the processing of
        replacement strings passed to <code class="function">pcre2_substitute</code>().</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ALT_CIRCUMFLEX
</pre>
        </div>
        <p>In multiline mode (when PCRE2_MULTILINE is set), the
        circumflex metacharacter matches at the start of the
        subject (unless PCRE2_NOTBOL is set), and also after any
        internal newline. However, it does not match after a
        newline at the end of the subject, for compatibility with
        Perl. If you want a multiline circumflex also to match
        after a terminating newline, you must set
        PCRE2_ALT_CIRCUMFLEX.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ALT_VERBNAMES
</pre>
        </div>
        <p>By default, for compatibility with Perl, the name in any
        verb sequence such as (*MARK:NAME) is any sequence of
        characters that does not include a closing parenthesis. The
        name is not processed in any way, and it is not possible to
        include a closing parenthesis in the name. However, if the
        PCRE2_ALT_VERBNAMES option is set, normal backslash
        processing is applied to verb names and only an unescaped
        closing parenthesis terminates the name. A closing
        parenthesis can be included in a name either as \) or
        between \Q and \E. If the PCRE2_EXTENDED or
        PCRE2_EXTENDED_MORE option is set with PCRE2_ALT_VERBNAMES,
        unescaped whitespace in verb names is skipped and
        #-comments are recognized, exactly as in the rest of the
        pattern.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_AUTO_CALLOUT
</pre>
        </div>
        <p>If this bit is set, <code class="function">pcre2_compile</code>() automatically inserts
        callout items, all with number 255, before each pattern
        item, except immediately before or after an explicit
        callout in the pattern. For discussion of the callout
        facility, see the <a class="link" href="../htmlman3/pcre2callout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2callout</span>(3)</span></a>
        documentation.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_CASELESS
</pre>
        </div>
        <p>If this bit is set, letters in the pattern match both
        upper and lower case letters in the subject. It is
        equivalent to Perl's /i option, and it can be changed
        within a pattern by a (?i) option setting. If either
        PCRE2_UTF or PCRE2_UCP is set, Unicode properties are used
        for all characters with more than one other case, and for
        all characters whose code points are greater than U+007F.
        Note that there are two ASCII characters, K and S, that, in
        addition to their lower case ASCII equivalents, are
        case-equivalent with U+212A (Kelvin sign) and U+017F (long
        S) respectively. For lower valued characters with only one
        other case, a lookup table is used for speed. When neither
        PCRE2_UTF nor PCRE2_UCP is set, a lookup table is used for
        all code points less than 256, and higher code points
        (available only in 16-bit or 32-bit mode) are treated as
        not having another case.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_DOLLAR_ENDONLY
</pre>
        </div>
        <p>If this bit is set, a dollar metacharacter in the
        pattern matches only at the end of the subject string.
        Without this option, a dollar also matches immediately
        before a newline at the end of the string (but not before
        any other newlines). The PCRE2_DOLLAR_ENDONLY option is
        ignored if PCRE2_MULTILINE is set. There is no equivalent
        to this option in Perl, and no way to set it within a
        pattern.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_DOTALL
</pre>
        </div>
        <p>If this bit is set, a dot metacharacter in the pattern
        matches any character, including one that indicates a
        newline. However, it only ever matches one character, even
        if newlines are coded as CRLF. Without this option, a dot
        does not match when the current position in the subject is
        at a newline. This option is equivalent to Perl's /s
        option, and it can be changed within a pattern by a (?s)
        option setting. A negative class such as [^a] always
        matches newline characters, and the \N escape sequence
        always matches a non-newline character, independent of the
        setting of PCRE2_DOTALL.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_DUPNAMES
</pre>
        </div>
        <p>If this bit is set, names used to identify capture
        groups need not be unique. This can be helpful for certain
        types of pattern when it is known that only one instance of
        the named group can ever be matched. There are more details
        of named capture groups below; see also the <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a>
        documentation.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ENDANCHORED
</pre>
        </div>
        <p>If this bit is set, the end of any pattern match must be
        right at the end of the string being searched (the "subject
        string"). If the pattern match succeeds by reaching
        (*ACCEPT), but does not reach the end of the subject, the
        match fails at the current starting point. For unanchored
        patterns, a new match is then tried at the next starting
        point. However, if the match succeeds by reaching the end
        of the pattern, but not the end of the subject,
        backtracking occurs and an alternative match may be found.
        Consider these two patterns:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 .(*ACCEPT)|..
 .|..
</pre>
        </div>
        <p>If matched against "abc" with PCRE2_ENDANCHORED set, the
        first matches "c" whereas the second matches "bc". The
        effect of PCRE2_ENDANCHORED can also be achieved by
        appropriate constructs in the pattern itself, which is the
        only way to do it in Perl.</p>
        <p>For DFA matching with <code class="function">pcre2_dfa_match</code>(), PCRE2_ENDANCHORED
        applies only to the first (that is, the longest) matched
        string. Other parallel matches, which are necessarily
        substrings of the first one, must obviously end before the
        end of the subject.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_EXTENDED
</pre>
        </div>
        <p>If this bit is set, most white space characters in the
        pattern are totally ignored except when escaped or inside a
        character class. However, white space is not allowed within
        sequences such as (?&gt; that introduce various
        parenthesized groups, nor within numerical quantifiers such
        as {1,3}. Ignorable white space is permitted between an
        item and a following quantifier and between a quantifier
        and a following + that indicates possessiveness.
        PCRE2_EXTENDED is equivalent to Perl's /x option, and it
        can be changed within a pattern by a (?x) option
        setting.</p>
        <p>When PCRE2 is compiled without Unicode support,
        PCRE2_EXTENDED recognizes as white space only those
        characters with code points less than 256 that are flagged
        as white space in its low-character table. The table is
        normally created by <code class="function">pcre2_maketables</code>(), which uses the
        <code class="function">isspace</code>() function to
        identify space characters. In most ASCII environments, the
        relevant characters are those with code points 0x0009
        (tab), 0x000A (linefeed), 0x000B (vertical tab), 0x000C
        (formfeed), 0x000D (carriage return), and 0x0020
        (space).</p>
        <p>When PCRE2 is compiled with Unicode support, in addition
        to these characters, five more Unicode "Pattern White
        Space" characters are recognized by PCRE2_EXTENDED. These
        are U+0085 (next line), U+200E (left-to-right mark), U+200F
        (right-to-left mark), U+2028 (line separator), and U+2029
        (paragraph separator). This set of characters is the same
        as recognized by Perl's /x option. Note that the horizontal
        and vertical space characters that are matched by the \h
        and \v escapes in patterns are a much bigger set.</p>
        <p>As well as ignoring most white space, PCRE2_EXTENDED
        also causes characters between an unescaped # outside a
        character class and the next newline, inclusive, to be
        ignored, which makes it possible to include comments inside
        complicated patterns. Note that the end of this type of
        comment is a literal newline sequence in the pattern;
        escape sequences that happen to represent a newline do not
        count.</p>
        <p>Which characters are interpreted as newlines can be
        specified by a setting in the compile context that is
        passed to <code class="function">pcre2_compile</code>() or
        by a special sequence at the start of the pattern, as
        described in the section entitled "Newline conventions" in
        the <code class="function">pcre2pattern</code>
        documentation. A default is defined when PCRE2 is
        built.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_EXTENDED_MORE
</pre>
        </div>
        <p>This option has the effect of PCRE2_EXTENDED, but, in
        addition, unescaped space and horizontal tab characters are
        ignored inside a character class. Note: only these two
        characters are ignored, not the full set of pattern white
        space characters that are ignored outside a character
        class. PCRE2_EXTENDED_MORE is equivalent to Perl's /xx
        option, and it can be changed within a pattern by a (?xx)
        option setting.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_FIRSTLINE
</pre>
        </div>
        <p>If this option is set, the start of an unanchored
        pattern match must be before or at the first newline in the
        subject string following the start of matching, though the
        matched text may continue over the newline. If <code class="function">startoffset</code> is non-zero, the limiting
        newline is not necessarily the first newline in the
        subject. For example, if the subject string is "abc\nxyz"
        (where \n represents a single-character newline) a pattern
        match for "yz" succeeds with PCRE2_FIRSTLINE if
        <code class="function">startoffset</code> is greater than
        3. See also PCRE2_USE_OFFSET_LIMIT, which provides a more
        general limiting facility. If PCRE2_FIRSTLINE is set with
        an offset limit, a match must occur in the first line and
        also within the offset limit. In other words, whichever
        limit comes first is used.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_LITERAL
</pre>
        </div>
        <p>If this option is set, all meta-characters in the
        pattern are disabled, and it is treated as a literal
        string. Matching literal strings with a regular expression
        engine is not the most efficient way of doing it. If you
        are doing a lot of literal matching and are worried about
        efficiency, you should consider using other approaches. The
        only other main options that are allowed with PCRE2_LITERAL
        are: PCRE2_ANCHORED, PCRE2_ENDANCHORED, PCRE2_AUTO_CALLOUT,
        PCRE2_CASELESS, PCRE2_FIRSTLINE, PCRE2_MATCH_INVALID_UTF,
        PCRE2_NO_START_OPTIMIZE, PCRE2_NO_UTF_CHECK, PCRE2_UTF, and
        PCRE2_USE_OFFSET_LIMIT. The extra options
        PCRE2_EXTRA_MATCH_LINE and PCRE2_EXTRA_MATCH_WORD are also
        supported. Any other options cause an error.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_MATCH_INVALID_UTF
</pre>
        </div>
        <p>This option forces PCRE2_UTF (see below) and also
        enables support for matching by <code class="function">pcre2_match</code>() in subject strings that
        contain invalid UTF sequences. This facility is not
        supported for DFA matching. For details, see the <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a>
        documentation.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_MATCH_UNSET_BACKREF
</pre>
        </div>
        <p>If this option is set, a backreference to an unset
        capture group matches an empty string (by default this
        causes the current matching alternative to fail). A pattern
        such as (\1)(a) succeeds when this option is set (assuming
        it can find an "a" in the subject), whereas it fails by
        default, for Perl compatibility. Setting this option makes
        PCRE2 behave more like ECMAscript (aka JavaScript).</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_MULTILINE
</pre>
        </div>
        <p>By default, for the purposes of matching "start of line"
        and "end of line", PCRE2 treats the subject string as
        consisting of a single line of characters, even if it
        actually contains newlines. The "start of line"
        metacharacter (^) matches only at the start of the string,
        and the "end of line" metacharacter ($) matches only at the
        end of the string, or before a terminating newline (except
        when PCRE2_DOLLAR_ENDONLY is set). Note, however, that
        unless PCRE2_DOTALL is set, the "any character"
        metacharacter (.) does not match at a newline. This
        behaviour (for ^, $, and dot) is the same as Perl.</p>
        <p>When PCRE2_MULTILINE it is set, the "start of line" and
        "end of line" constructs match immediately following or
        immediately before internal newlines in the subject string,
        respectively, as well as at the very start and end. This is
        equivalent to Perl's /m option, and it can be changed
        within a pattern by a (?m) option setting. Note that the
        "start of line" metacharacter does not match after a
        newline at the end of the subject, for compatibility with
        Perl. However, you can change this by setting the
        PCRE2_ALT_CIRCUMFLEX option. If there are no newlines in a
        subject string, or no occurrences of ^ or $ in a pattern,
        setting PCRE2_MULTILINE has no effect.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NEVER_BACKSLASH_C
</pre>
        </div>
        <p>This option locks out the use of \C in the pattern that
        is being compiled. This escape can cause unpredictable
        behaviour in UTF-8 or UTF-16 modes, because it may leave
        the current matching point in the middle of a
        multi-code-unit character. This option may be useful in
        applications that process patterns from external sources.
        Note that there is also a build-time option that
        permanently locks out the use of \C.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NEVER_UCP
</pre>
        </div>
        <p>This option locks out the use of Unicode properties for
        handling \B, \b, \D, \d, \S, \s, \W, \w, and some of the
        POSIX character classes, as described for the PCRE2_UCP
        option below. In particular, it prevents the creator of the
        pattern from enabling this facility by starting the pattern
        with (*UCP). This option may be useful in applications that
        process patterns from external sources. The option
        combination PCRE_UCP and PCRE_NEVER_UCP causes an
        error.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NEVER_UTF
</pre>
        </div>
        <p>This option locks out interpretation of the pattern as
        UTF-8, UTF-16, or UTF-32, depending on which library is in
        use. In particular, it prevents the creator of the pattern
        from switching to UTF interpretation by starting the
        pattern with (*UTF). This option may be useful in
        applications that process patterns from external sources.
        The combination of PCRE2_UTF and PCRE2_NEVER_UTF causes an
        error.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NO_AUTO_CAPTURE
</pre>
        </div>
        <p>If this option is set, it disables the use of numbered
        capturing parentheses in the pattern. Any opening
        parenthesis that is not followed by ? behaves as if it were
        followed by ?: but named parentheses can still be used for
        capturing (and they acquire numbers in the usual way). This
        is the same as Perl's /n option. Note that, when this
        option is set, references to capture groups (backreferences
        or recursion/subroutine calls) may only refer to named
        groups, though the reference can be by name or by
        number.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NO_AUTO_POSSESS
</pre>
        </div>
        <p>If this option is set, it disables
        "auto-possessification", which is an optimization that, for
        example, turns a+b into a++b in order to avoid backtracks
        into a+ that can never be successful. However, if callouts
        are in use, auto-possessification means that some callouts
        are never taken. You can set this option if you want the
        matching functions to do a full unoptimized search and run
        all the callouts, but it is mainly provided for testing
        purposes.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NO_DOTSTAR_ANCHOR
</pre>
        </div>
        <p>If this option is set, it disables an optimization that
        is applied when .* is the first significant item in a
        top-level branch of a pattern, and all the other branches
        also start with .* or with \A or \G or ^. The optimization
        is automatically disabled for .* if it is inside an atomic
        group or a capture group that is the subject of a
        backreference, or if the pattern contains (*PRUNE) or
        (*SKIP). When the optimization is not disabled, such a
        pattern is automatically anchored if PCRE2_DOTALL is set
        for all the .* items and PCRE2_MULTILINE is not set for any
        ^ items. Otherwise, the fact that any match must start
        either at the start of the subject or following a newline
        is remembered. Like other optimizations, this can cause
        callouts to be skipped.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NO_START_OPTIMIZE
</pre>
        </div>
        <p>This is an option whose main effect is at matching time.
        It does not change what <code class="function">pcre2_compile</code>() generates, but it does
        affect the output of the JIT compiler.</p>
        <p>There are a number of optimizations that may occur at
        the start of a match, in order to speed up the process. For
        example, if it is known that an unanchored match must start
        with a specific code unit value, the matching code searches
        the subject for that value, and fails immediately if it
        cannot find it, without actually running the main matching
        function. This means that a special item such as (*COMMIT)
        at the start of a pattern is not considered until after a
        suitable starting point for the match has been found. Also,
        when callouts or (*MARK) items are in use, these "start-up"
        optimizations can cause them to be skipped if the pattern
        is never actually used. The start-up optimizations are in
        effect a pre-scan of the subject that takes place before
        the pattern is run.</p>
        <p>The PCRE2_NO_START_OPTIMIZE option disables the start-up
        optimizations, possibly causing performance to suffer, but
        ensuring that in cases where the result is "no match", the
        callouts do occur, and that items such as (*COMMIT) and
        (*MARK) are considered at every possible starting position
        in the subject string.</p>
        <p>Setting PCRE2_NO_START_OPTIMIZE may change the outcome
        of a matching operation. Consider the pattern</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*COMMIT)ABC
</pre>
        </div>
        <p>When this is compiled, PCRE2 records the fact that a
        match must start with the character "A". Suppose the
        subject string is "DEFABC". The start-up optimization scans
        along the subject, finds "A" and runs the first match
        attempt from there. The (*COMMIT) item means that the
        pattern must match the current starting position, which in
        this case, it does. However, if the same match is run with
        PCRE2_NO_START_OPTIMIZE set, the initial scan along the
        subject string does not happen. The first match attempt is
        run starting from "D" and when this fails, (*COMMIT)
        prevents any further matches being tried, so the overall
        result is "no match".</p>
        <p>As another start-up optimization makes use of a minimum
        length for a matching subject, which is recorded when
        possible. Consider the pattern</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*MARK:1)B(*MARK:2)(X|Y)
</pre>
        </div>
        <p>The minimum length for a match is two characters. If the
        subject is "XXBB", the "starting character" optimization
        skips "XX", then tries to match "BB", which is long enough.
        In the process, (*MARK:2) is encountered and remembered.
        When the match attempt fails, the next "B" is found, but
        there is only one character left, so there are no more
        attempts, and "no match" is returned with the "last mark
        seen" set to "2". If NO_START_OPTIMIZE is set, however,
        matches are tried at every possible starting position,
        including at the end of the subject, where (*MARK:1) is
        encountered, but there is no "B", so the "last mark seen"
        that is returned is "1". In this case, the optimizations do
        not affect the overall match result, which is still "no
        match", but they do affect the auxiliary information that
        is returned.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NO_UTF_CHECK
</pre>
        </div>
        <p>When PCRE2_UTF is set, the validity of the pattern as a
        UTF string is automatically checked. There are discussions
        about the validity of UTF-8 strings, UTF-16 strings, and
        UTF-32 strings in the <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a> document.
        If an invalid UTF sequence is found, <code class="function">pcre2_compile</code>() returns a negative error
        code.</p>
        <p>If you know that your pattern is a valid UTF string, and
        you want to skip this check for performance reasons, you
        can set the PCRE2_NO_UTF_CHECK option. When it is set, the
        effect of passing an invalid UTF string as a pattern is
        undefined. It may cause your program to crash or loop.</p>
        <p>Note that this option can also be passed to <code class="function">pcre2_match</code>() and <code class="function">pcre_dfa_match</code>(), to suppress UTF
        validity checking of the subject string.</p>
        <p>Note also that setting PCRE2_NO_UTF_CHECK at compile
        time does not disable the error that is given if an escape
        sequence for an invalid Unicode code point is encountered
        in the pattern. In particular, the so-called "surrogate"
        code points (0xd800 to 0xdfff) are invalid. If you want to
        allow escape sequences such as \x{d800} you can set the
        PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES extra option, as
        described in the section entitled "Extra compile options"
        below. However, this is possible only in UTF-8 and UTF-32
        modes, because these values are not representable in
        UTF-16.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_UCP
</pre>
        </div>
        <p>This option has two effects. Firstly, it change the way
        PCRE2 processes \B, \b, \D, \d, \S, \s, \W, \w, and some of
        the POSIX character classes. By default, only ASCII
        characters are recognized, but if PCRE2_UCP is set, Unicode
        properties are used instead to classify characters. More
        details are given in the section on generic character types
        in the <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a> page. If
        you set PCRE2_UCP, matching one of the items it affects
        takes much longer.</p>
        <p>The second effect of PCRE2_UCP is to force the use of
        Unicode properties for upper/lower casing operations on
        characters with code points greater than 127, even when
        PCRE2_UTF is not set. This makes it possible, for example,
        to process strings in the 16-bit UCS-2 code. This option is
        available only if PCRE2 has been compiled with Unicode
        support (which is the default).</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_UNGREEDY
</pre>
        </div>
        <p>This option inverts the "greediness" of the quantifiers
        so that they are not greedy by default, but become greedy
        if followed by "?". It is not compatible with Perl. It can
        also be set by a (?U) option setting within the
        pattern.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_USE_OFFSET_LIMIT
</pre>
        </div>
        <p>This option must be set for <code class="function">pcre2_compile</code>() if <code class="function">pcre2_set_offset_limit</code>() is going to be
        used to set a non-default offset limit in a match context
        for matches that use this pattern. An error is generated if
        an offset limit is set without this option. For more
        details, see the description of <code class="function">pcre2_set_offset_limit</code>() in the section
        that describes match contexts. See also the PCRE2_FIRSTLINE
        option above.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_UTF
</pre>
        </div>
        <p>This option causes PCRE2 to regard both the pattern and
        the subject strings that are subsequently processed as
        strings of UTF characters instead of single-code-unit
        strings. It is available when PCRE2 is built to include
        Unicode support (which is the default). If Unicode support
        is not available, the use of this option provokes an error.
        Details of how PCRE2_UTF changes the behaviour of PCRE2 are
        given in the <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a> page. In
        particular, note that it changes the way PCRE2_CASELESS
        handles characters with code points greater than 127.</p>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect28" name="pcre2api-3_sect28" shape="rect"> </a>
        <h3>Extra compile options</h3>
        <p>The option bits that can be set in a compile context by
        calling the <code class="function">pcre2_set_compile_extra_options</code>()
        function are as follows:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES
</pre>
        </div>
        <p>This option applies when compiling a pattern in UTF-8 or
        UTF-32 mode. It is forbidden in UTF-16 mode, and ignored in
        non-UTF modes. Unicode "surrogate" code points in the range
        0xd800 to 0xdfff are used in pairs in UTF-16 to encode code
        points with values in the range 0x10000 to 0x10ffff. The
        surrogates cannot therefore be represented in UTF-16. They
        can be represented in UTF-8 and UTF-32, but are defined as
        invalid code points, and cause errors if encountered in a
        UTF-8 or UTF-32 string that is being checked for validity
        by PCRE2.</p>
        <p>These values also cause errors if encountered in escape
        sequences such as \x{d912} within a pattern. However, it
        seems that some applications, when using PCRE2 to check for
        unwanted characters in UTF-8 strings, explicitly test for
        the surrogates using escape sequences. The
        PCRE2_NO_UTF_CHECK option does not disable the error that
        occurs, because it applies only to the testing of input
        strings for UTF validity.</p>
        <p>If the extra option PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES
        is set, surrogate code point values in UTF-8 and UTF-32
        patterns no longer provoke errors and are incorporated in
        the compiled pattern. However, they can only match subject
        characters if the matching function is called with
        PCRE2_NO_UTF_CHECK set.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_EXTRA_ALT_BSUX
</pre>
        </div>
        <p>The original option PCRE2_ALT_BSUX causes PCRE2 to
        process \U, \u, and \x in the way that ECMAscript (aka
        JavaScript) does. Additional functionality was defined by
        ECMAscript 6; setting PCRE2_EXTRA_ALT_BSUX has the effect
        of PCRE2_ALT_BSUX, but in addition it recognizes \u{hhh..}
        as a hexadecimal character code, where hhh.. is any number
        of hexadecimal digits.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL
</pre>
        </div>
        <p>This is a dangerous option. Use with care. By default,
        an unrecognized escape such as \j or a malformed one such
        as \x{2z} causes a compile-time error when detected by
        <code class="function">pcre2_compile</code>(). Perl is
        somewhat inconsistent in handling such items: for example,
        \j is treated as a literal "j", and non-hexadecimal digits
        in \x{} are just ignored, though warnings are given in both
        cases if Perl's warning switch is enabled. However, a
        malformed octal number after \o{ always causes an error in
        Perl.</p>
        <p>If the PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL extra option is
        passed to <code class="function">pcre2_compile</code>(),
        all unrecognized or malformed escape sequences are treated
        as single-character escapes. For example, \j is a literal
        "j" and \x{2z} is treated as the literal string "x{2z}".
        Setting this option means that typos in patterns may go
        undetected and have unexpected results. Also note that a
        sequence such as [\N{] is interpreted as a malformed
        attempt at [\N{...}] and so is treated as [N{] whereas [\N]
        gives an error because an unqualified \N is a valid escape
        sequence but is not supported in a character class. To
        reiterate: this is a dangerous option. Use with great
        care.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_EXTRA_ESCAPED_CR_IS_LF
</pre>
        </div>
        <p>There are some legacy applications where the escape
        sequence \r in a pattern is expected to match a newline. If
        this option is set, \r in a pattern is converted to \n so
        that it matches a LF (linefeed) instead of a CR (carriage
        return) character. The option does not affect a literal CR
        in the pattern, nor does it affect CR specified as an
        explicit code point such as \x{0D}.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_EXTRA_MATCH_LINE
</pre>
        </div>
        <p>This option is provided for use by the <code class="option">−x</code> option of <code class="function">pcre2grep</code>. It causes the pattern only to
        match complete lines. This is achieved by automatically
        inserting the code for "^(?:" at the start of the compiled
        pattern and ")$" at the end. Thus, when PCRE2_MULTILINE is
        set, the matched line may be in the middle of the subject
        string. This option can be used with PCRE2_LITERAL.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_EXTRA_MATCH_WORD
</pre>
        </div>
        <p>This option is provided for use by the <code class="option">−w</code> option of <code class="function">pcre2grep</code>. It causes the pattern only to
        match strings that have a word boundary at the start and
        the end. This is achieved by automatically inserting the
        code for "\b(?:" at the start of the compiled pattern and
        ")\b" at the end. The option may be used with
        PCRE2_LITERAL. However, it is ignored if
        PCRE2_EXTRA_MATCH_LINE is also set.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect29" name="pcre2api-3_sect29" shape="rect"> </a>
      <h2>JUST-IN-TIME (JIT) COMPILATION</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_jit_compile(pcre2_code *<code class="function">code</code>, uint32_t <code class="function">options</code>);</em></span>

<span class="emphasis"><em>int pcre2_jit_match(const pcre2_code *<code class="function">code</code>, PCRE2_SPTR <code class="function">subject</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">length</code>, PCRE2_SIZE <code class="function">startoffset</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_jit_free_unused_memory(pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_jit_stack *pcre2_jit_stack_create(PCRE2_SIZE <code class="function">startsize</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">maxsize</code>, pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_jit_stack_assign(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  pcre2_jit_callback <code class="function">callback_function</code>, void *<code class="function">callback_data</code>);</em></span>

<span class="emphasis"><em>void pcre2_jit_stack_free(pcre2_jit_stack *<code class="function">jit_stack</code>);</em></span>
</pre>
      </div>
      <p>These functions provide support for JIT compilation,
      which, if the just-in-time compiler is available, further
      processes a compiled pattern into machine code that executes
      much faster than the <code class="function">pcre2_match</code>() interpretive matching
      function. Full details are given in the <a class="link" href="../htmlman3/pcre2jit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2jit</span>(3)</span></a>
      documentation.</p>
      <p>JIT compilation is a heavyweight optimization. It can take
      some time for patterns to be analyzed, and for one-off
      matches and simple patterns the benefit of faster execution
      might be offset by a much slower compilation time. Most (but
      not all) patterns can be optimized by the JIT compiler.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect30" name="pcre2api-3_sect30" shape="rect"> </a>
      <h2>LOCALE SUPPORT</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>const uint8_t *pcre2_maketables(pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_maketables_free(pcre2_general_context *<code class="function">gcontext</code>,</em></span>
<span class="emphasis"><em>  const uint8_t *<code class="function">tables</code>);</em></span>
</pre>
      </div>
      <p>PCRE2 handles caseless matching, and determines whether
      characters are letters, digits, or whatever, by reference to
      a set of tables, indexed by character code point. However,
      this applies only to characters whose code points are less
      than 256. By default, higher-valued code points never match
      escapes such as \w or \d.</p>
      <p>When PCRE2 is built with Unicode support (the default),
      the Unicode properties of all characters can be tested with
      \p and \P, or, alternatively, the PCRE2_UCP option can be set
      when a pattern is compiled; this causes \w and friends to use
      Unicode property support instead of the built-in tables.
      PCRE2_UCP also causes upper/lower casing operations on
      characters with code points greater than 127 to use Unicode
      properties. These effects apply even when PCRE2_UTF is not
      set.</p>
      <p>The use of locales with Unicode is discouraged. If you are
      handling characters with code points greater than 127, you
      should either use Unicode support, or use locales, but not
      try to mix the two.</p>
      <p>PCRE2 contains a built-in set of character tables that are
      used by default. These are sufficient for many applications.
      Normally, the internal tables recognize only ASCII
      characters. However, when PCRE2 is built, it is possible to
      cause the internal tables to be rebuilt in the default "C"
      locale of the local system, which may cause them to be
      different.</p>
      <p>The built-in tables can be overridden by tables supplied
      by the application that calls PCRE2. These may be created in
      a different locale from the default. As more and more
      applications change to using Unicode, the need for this
      locale support is expected to die away.</p>
      <p>External tables are built by calling the <code class="function">pcre2_maketables</code>() function, in the
      relevant locale. The only argument to this function is a
      general context, which can be used to pass a custom memory
      allocator. If the argument is NULL, the system <code class="function">malloc</code>() is used. The result can be passed
      to <code class="function">pcre2_compile</code>() as often as
      necessary, by creating a compile context and calling
      <code class="function">pcre2_set_character_tables</code>() to
      set the tables pointer therein.</p>
      <p>For example, to build and use tables that are appropriate
      for the French locale (where accented characters with values
      greater than 127 are treated as letters), the following code
      could be used:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 setlocale(LC_CTYPE, "fr_FR");
 tables = pcre2_maketables(NULL);
 ccontext = pcre2_compile_context_create(NULL);
 pcre2_set_character_tables(ccontext, tables);
 re = pcre2_compile(..., ccontext);
</pre>
      </div>
      <p>The locale name "fr_FR" is used on Linux and other
      Unix-like systems; if you are using Windows, the name for the
      French locale is "french".</p>
      <p>The pointer that is passed (via the compile context) to
      <code class="function">pcre2_compile</code>() is saved with
      the compiled pattern, and the same tables are used by the
      matching functions. Thus, for any single pattern, compilation
      and matching both happen in the same locale, but different
      patterns can be processed in different locales.</p>
      <p>It is the caller's responsibility to ensure that the
      memory containing the tables remains available while they are
      still in use. When they are no longer needed, you can discard
      them using <code class="function">pcre2_maketables_free</code>(), which should pass
      as its first parameter the same global context that was used
      to create the tables.</p>
      <div class="refsect2">
        <a id="pcre2api-3_sect31" name="pcre2api-3_sect31" shape="rect"> </a>
        <h3>Saving locale tables</h3>
        <p>The tables described above are just a sequence of binary
        bytes, which makes them independent of hardware
        characteristics such as endianness or whether the processor
        is 32-bit or 64-bit. A copy of the result of <code class="function">pcre2_maketables</code>() can therefore be saved
        in a file or elsewhere and re-used later, even in a
        different program or on another computer. The size of the
        tables (number of bytes) must be obtained by calling
        <code class="function">pcre2_config</code>() with the
        PCRE2_CONFIG_TABLES_LENGTH option because <code class="function">pcre2_maketables</code>() does not return this
        value. Note that the <code class="function">pcre2_dftables</code> program, which is part of
        the PCRE2 build system, can be used stand-alone to create a
        file that contains a set of binary tables. See the
        <code class="function">pcre2build</code> documentation for
        details.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect32" name="pcre2api-3_sect32" shape="rect"> </a>
      <h2>INFORMATION ABOUT A COMPILED PATTERN</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_pattern_info(const pcre2 *<code class="function">code</code>, uint32_t <code class="function">what</code>, void *<code class="function">where</code>);</em></span>
</pre>
      </div>
      <p>The <code class="function">pcre2_pattern_info</code>()
      function returns general information about a compiled
      pattern. For information about callouts, see the next
      section. The first argument for <code class="function">pcre2_pattern_info</code>() is a pointer to the
      compiled pattern. The second argument specifies which piece
      of information is required, and the third argument is a
      pointer to a variable to receive the data. If the third
      argument is NULL, the first argument is ignored, and the
      function returns the size in bytes of the variable that is
      required for the information requested. Otherwise, the yield
      of the function is zero for success, or one of the following
      negative numbers:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE2_ERROR_NULL           the argument <code class="function">code</code> was NULL
 PCRE2_ERROR_BADMAGIC       the "magic number" was not found
 PCRE2_ERROR_BADOPTION      the value of <code class="function">what</code> was invalid
 PCRE2_ERROR_UNSET          the requested field is not set
</pre>
      </div>
      <p>The "magic number" is placed at the start of each compiled
      pattern as a simple check against passing an arbitrary memory
      pointer. Here is a typical call of <code class="function">pcre2_pattern_info</code>(), to obtain the length
      of the compiled pattern:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 size_t length;
 rc = pcre2_pattern_info(
   re,               /* result of pcre2_compile() */
   PCRE2_INFO_SIZE,  /* what is required */
   &amp;length);         /* where to put the data */
</pre>
      </div>
      <p>The possible values for the second argument are defined in
      <code class="filename">pcre2.h</code>, and are as
      follows:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE2_INFO_ALLOPTIONS
 PCRE2_INFO_ARGOPTIONS
 PCRE2_INFO_EXTRAOPTIONS
</pre>
      </div>
      <p>Return copies of the pattern's options. The third argument
      should point to a <span class="type">uint32_t</span>
      variable. PCRE2_INFO_ARGOPTIONS returns exactly the options
      that were passed to <code class="function">pcre2_compile</code>(), whereas
      PCRE2_INFO_ALLOPTIONS returns the compile options as modified
      by any top-level (*XXX) option settings such as (*UTF) at the
      start of the pattern itself. PCRE2_INFO_EXTRAOPTIONS returns
      the extra options that were set in the compile context by
      calling the pcre2_set_compile_extra_options() function.</p>
      <p>For example, if the pattern /(*UTF)abc/ is compiled with
      the PCRE2_EXTENDED option, the result for
      PCRE2_INFO_ALLOPTIONS is PCRE2_EXTENDED and PCRE2_UTF. Option
      settings such as (?i) that can change within a pattern do not
      affect the result of PCRE2_INFO_ALLOPTIONS, even if they
      appear right at the start of the pattern. (This was different
      in some earlier releases.)</p>
      <p>A pattern compiled without PCRE2_ANCHORED is automatically
      anchored by PCRE2 if the first significant item in every
      top-level branch is one of the following:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 ^     unless PCRE2_MULTILINE is set
 \A    always
 \G    always
 .*    sometimes - see below
</pre>
      </div>
      <p>When .* is the first significant item, anchoring is
      possible only when all the following are true:</p>
      <p>.* is not in an atomic group</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 .* is not in a capture group that is the subject
      of a backreference
 PCRE2_DOTALL is in force for .*
 Neither (*PRUNE) nor (*SKIP) appears in the pattern
 PCRE2_NO_DOTSTAR_ANCHOR is not set
</pre>
      </div>
      <p>For patterns that are auto-anchored, the PCRE2_ANCHORED
      bit is set in the options returned for
      PCRE2_INFO_ALLOPTIONS.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_BACKREFMAX
</pre>
      </div>
      <p>Return the number of the highest backreference in the
      pattern. The third argument should point to a <span class="type">uint32_t</span> variable. Named capture groups acquire
      numbers as well as names, and these count towards the highest
      backreference. Backreferences such as \4 or \g{12} match the
      captured characters of the given group, but in addition, the
      check that a capture group is set in a conditional group such
      as (?(3)a|b) is also a backreference. Zero is returned if
      there are no backreferences.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_BSR
</pre>
      </div>
      <p>The output is a uint32_t integer whose value indicates
      what character sequences the \R escape sequence matches. A
      value of PCRE2_BSR_UNICODE means that \R matches any Unicode
      line ending sequence; a value of PCRE2_BSR_ANYCRLF means that
      \R matches only CR, LF, or CRLF.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_CAPTURECOUNT
</pre>
      </div>
      <p>Return the highest capture group number in the pattern. In
      patterns where (?| is not used, this is also the total number
      of capture groups. The third argument should point to a
      <span class="type">uint32_t</span> variable.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_DEPTHLIMIT
</pre>
      </div>
      <p>If the pattern set a backtracking depth limit by including
      an item of the form (*LIMIT_DEPTH=nnnn) at the start, the
      value is returned. The third argument should point to a
      uint32_t integer. If no such value has been set, the call to
      <code class="function">pcre2_pattern_info</code>() returns
      the error PCRE2_ERROR_UNSET. Note that this limit will only
      be used during matching if it is less than the limit set or
      defaulted by the caller of the match function.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_FIRSTBITMAP
</pre>
      </div>
      <p>In the absence of a single first code unit for a
      non-anchored pattern, <code class="function">pcre2_compile</code>() may construct a 256-bit
      table that defines a fixed set of values for the first code
      unit in any match. For example, a pattern that starts with
      [abc] results in a table with three bits set. When code unit
      values greater than 255 are supported, the flag bit for 255
      means "any code unit of value 255 or above". If such a table
      was constructed, a pointer to it is returned. Otherwise NULL
      is returned. The third argument should point to a
      <span class="type">const uint8_t *</span> variable.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_FIRSTCODETYPE
</pre>
      </div>
      <p>Return information about the first code unit of any
      matched string, for a non-anchored pattern. The third
      argument should point to a <span class="type">uint32_t</span>
      variable. If there is a fixed first value, for example, the
      letter "c" from a pattern such as (cat|cow|coyote), 1 is
      returned, and the value can be retrieved using
      PCRE2_INFO_FIRSTCODEUNIT. If there is no fixed first value,
      but it is known that a match can occur only at the start of
      the subject or following a newline in the subject, 2 is
      returned. Otherwise, and for anchored patterns, 0 is
      returned.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_FIRSTCODEUNIT
</pre>
      </div>
      <p>Return the value of the first code unit of any matched
      string for a pattern where PCRE2_INFO_FIRSTCODETYPE returns
      1; otherwise return 0. The third argument should point to a
      <span class="type">uint32_t</span> variable. In the 8-bit
      library, the value is always less than 256. In the 16-bit
      library the value can be up to 0xffff. In the 32-bit library
      in UTF-32 mode the value can be up to 0x10ffff, and up to
      0xffffffff when not using UTF-32 mode.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_FRAMESIZE
</pre>
      </div>
      <p>Return the size (in bytes) of the data frames that are
      used to remember backtracking positions when the pattern is
      processed by <code class="function">pcre2_match</code>()
      without the use of JIT. The third argument should point to a
      <span class="type">size_t</span> variable. The frame size
      depends on the number of capturing parentheses in the
      pattern. Each additional capture group adds two PCRE2_SIZE
      variables.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_HASBACKSLASHC
</pre>
      </div>
      <p>Return 1 if the pattern contains any instances of \C,
      otherwise 0. The third argument should point to a
      <span class="type">uint32_t</span> variable.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_HASCRORLF
</pre>
      </div>
      <p>Return 1 if the pattern contains any explicit matches for
      CR or LF characters, otherwise 0. The third argument should
      point to a <span class="type">uint32_t</span> variable. An
      explicit match is either a literal CR or LF character, or \r
      or \n or one of the equivalent hexadecimal or octal escape
      sequences.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_HEAPLIMIT
</pre>
      </div>
      <p>If the pattern set a heap memory limit by including an
      item of the form (*LIMIT_HEAP=nnnn) at the start, the value
      is returned. The third argument should point to a uint32_t
      integer. If no such value has been set, the call to
      <code class="function">pcre2_pattern_info</code>() returns
      the error PCRE2_ERROR_UNSET. Note that this limit will only
      be used during matching if it is less than the limit set or
      defaulted by the caller of the match function.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_JCHANGED
</pre>
      </div>
      <p>Return 1 if the (?J) or (?-J) option setting is used in
      the pattern, otherwise 0. The third argument should point to
      a <span class="type">uint32_t</span> variable. (?J) and (?-J)
      set and unset the local PCRE2_DUPNAMES option,
      respectively.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_JITSIZE
</pre>
      </div>
      <p>If the compiled pattern was successfully processed by
      <code class="function">pcre2_jit_compile</code>(), return the
      size of the JIT compiled code, otherwise return zero. The
      third argument should point to a <span class="type">size_t</span> variable.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_LASTCODETYPE
</pre>
      </div>
      <p>Returns 1 if there is a rightmost literal code unit that
      must exist in any matched string, other than at its start.
      The third argument should point to a <span class="type">uint32_t</span> variable. If there is no such value, 0
      is returned. When 1 is returned, the code unit value itself
      can be retrieved using PCRE2_INFO_LASTCODEUNIT. For anchored
      patterns, a last literal value is recorded only if it follows
      something of variable length. For example, for the pattern
      /^a\d+z\d+/ the returned value is 1 (with "z" returned from
      PCRE2_INFO_LASTCODEUNIT), but for /^a\dz\d/ the returned
      value is 0.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_LASTCODEUNIT
</pre>
      </div>
      <p>Return the value of the rightmost literal code unit that
      must exist in any matched string, other than at its start,
      for a pattern where PCRE2_INFO_LASTCODETYPE returns 1.
      Otherwise, return 0. The third argument should point to a
      <span class="type">uint32_t</span> variable.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_MATCHEMPTY
</pre>
      </div>
      <p>Return 1 if the pattern might match an empty string,
      otherwise 0. The third argument should point to a
      <span class="type">uint32_t</span> variable. When a pattern
      contains recursive subroutine calls it is not always possible
      to determine whether or not it can match an empty string.
      PCRE2 takes a cautious approach and returns 1 in such
      cases.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_MATCHLIMIT
</pre>
      </div>
      <p>If the pattern set a match limit by including an item of
      the form (*LIMIT_MATCH=nnnn) at the start, the value is
      returned. The third argument should point to a uint32_t
      integer. If no such value has been set, the call to
      <code class="function">pcre2_pattern_info</code>() returns
      the error PCRE2_ERROR_UNSET. Note that this limit will only
      be used during matching if it is less than the limit set or
      defaulted by the caller of the match function.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_MAXLOOKBEHIND
</pre>
      </div>
      <p>A lookbehind assertion moves back a certain number of
      characters (not code units) when it starts to process each of
      its branches. This request returns the largest of these
      backward moves. The third argument should point to a uint32_t
      integer. The simple assertions \b and \B require a
      one-character lookbehind and cause PCRE2_INFO_MAXLOOKBEHIND
      to return 1 in the absence of anything longer. \A also
      registers a one-character lookbehind, though it does not
      actually inspect the previous character.</p>
      <p>Note that this information is useful for multi-segment
      matching only if the pattern contains no nested lookbehinds.
      For example, the pattern (?&lt;=a(?&lt;=ba)c) returns a
      maximum lookbehind of 2, but when it is processed, the first
      lookbehind moves back by two characters, matches one
      character, then the nested lookbehind also moves back by two
      characters. This puts the matching point three characters
      earlier than it was at the start. PCRE2_INFO_MAXLOOKBEHIND is
      really only useful as a debugging tool. See the <a class="link" href="../htmlman3/pcre2partial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2partial</span>(3)</span></a>
      documentation for a discussion of multi-segment matching.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_MINLENGTH
</pre>
      </div>
      <p>If a minimum length for matching subject strings was
      computed, its value is returned. Otherwise the returned value
      is 0. This value is not computed when PCRE2_NO_START_OPTIMIZE
      is set. The value is a number of characters, which in UTF
      mode may be different from the number of code units. The
      third argument should point to a <span class="type">uint32_t</span> variable. The value is a lower bound
      to the length of any matching string. There may not be any
      strings of that length that do actually match, but every
      string that does match is at least that long.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE2_INFO_NAMECOUNT
 PCRE2_INFO_NAMEENTRYSIZE
 PCRE2_INFO_NAMETABLE
</pre>
      </div>
      <p>PCRE2 supports the use of named as well as numbered
      capturing parentheses. The names are just an additional way
      of identifying the parentheses, which still acquire numbers.
      Several convenience functions such as <code class="function">pcre2_substring_get_byname</code>() are provided
      for extracting captured substrings by name. It is also
      possible to extract the data directly, by first converting
      the name to a number in order to access the correct pointers
      in the output vector (described with <code class="function">pcre2_match</code>() below). To do the conversion,
      you need to use the name-to-number map, which is described by
      these three values.</p>
      <p>The map consists of a number of fixed-size entries.
      PCRE2_INFO_NAMECOUNT gives the number of entries, and
      PCRE2_INFO_NAMEENTRYSIZE gives the size of each entry in code
      units; both of these return a <span class="type">uint32_t</span> value. The entry size depends on the
      length of the longest name.</p>
      <p>PCRE2_INFO_NAMETABLE returns a pointer to the first entry
      of the table. This is a PCRE2_SPTR pointer to a block of code
      units. In the 8-bit library, the first two bytes of each
      entry are the number of the capturing parenthesis, most
      significant byte first. In the 16-bit library, the pointer
      points to 16-bit code units, the first of which contains the
      parenthesis number. In the 32-bit library, the pointer points
      to 32-bit code units, the first of which contains the
      parenthesis number. The rest of the entry is the
      corresponding name, zero terminated.</p>
      <p>The names are in alphabetical order. If (?| is used to
      create multiple capture groups with the same number, as
      described in the section on duplicate group numbers in the
      <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a> page, the
      groups may be given the same name, but there is only one
      entry in the table. Different names for groups of the same
      number are not permitted.</p>
      <p>Duplicate names for capture groups with different numbers
      are permitted, but only if PCRE2_DUPNAMES is set. They appear
      in the table in the order in which they were found in the
      pattern. In the absence of (?| this is the order of
      increasing number; when (?| is used this is not necessarily
      the case because later capture groups may have lower
      numbers.</p>
      <p>As a simple example of the name/number table, consider the
      following pattern after compilation by the 8-bit library
      (assume PCRE2_EXTENDED is set, so white space - including
      newlines - is ignored):</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 (?&lt;date&gt; (?&lt;year&gt;(\d\d)?\d\d) -
 (?&lt;month&gt;\d\d) - (?&lt;day&gt;\d\d) )
</pre>
      </div>
      <p>There are four named capture groups, so the table has four
      entries, and each entry in the table is eight bytes long. The
      table is as follows, with non-printing bytes shows in
      hexadecimal, and undefined bytes shown as ??:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 00 01 d  a  t  e  00 ??
 00 05 d  a  y  00 ?? ??
 00 04 m  o  n  t  h  00
 00 02 y  e  a  r  00 ??
</pre>
      </div>
      <p>When writing code to extract data from named capture
      groups using the name-to-number map, remember that the length
      of the entries is likely to be different for each compiled
      pattern.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_NEWLINE
</pre>
      </div>
      <p>The output is one of the following <span class="type">uint32_t</span> values:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE2_NEWLINE_CR       Carriage return (CR)
 PCRE2_NEWLINE_LF       Linefeed (LF)
 PCRE2_NEWLINE_CRLF     Carriage return, linefeed (CRLF)
 PCRE2_NEWLINE_ANY      Any Unicode line ending
 PCRE2_NEWLINE_ANYCRLF  Any of CR, LF, or CRLF
 PCRE2_NEWLINE_NUL      The NUL character (binary zero)
</pre>
      </div>
      <p>This identifies the character sequence that will be
      recognized as meaning "newline" while matching.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_INFO_SIZE
</pre>
      </div>
      <p>Return the size of the compiled pattern in bytes (for all
      three libraries). The third argument should point to a
      <span class="type">size_t</span> variable. This value
      includes the size of the general data block that precedes the
      code units of the compiled pattern itself. The value that is
      used when <code class="function">pcre2_compile</code>() is
      getting memory in which to place the compiled pattern may be
      slightly larger than the value returned by this option,
      because there are cases where the code that calculates the
      size has to over-estimate. Processing a pattern with the JIT
      compiler does not alter the value returned by this
      option.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect33" name="pcre2api-3_sect33" shape="rect"> </a>
      <h2>INFORMATION ABOUT A PATTERN'S CALLOUTS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_callout_enumerate(const pcre2_code *<code class="function">code</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">callback</code>)(pcre2_callout_enumerate_block *, void *),</em></span>
<span class="emphasis"><em>  void *<code class="function">user_data</code>);</em></span>
</pre>
      </div>
      <p>A script language that supports the use of string
      arguments in callouts might like to scan all the callouts in
      a pattern before running the match. This can be done by
      calling <code class="function">pcre2_callout_enumerate</code>(). The first
      argument is a pointer to a compiled pattern, the second
      points to a callback function, and the third is arbitrary
      user data. The callback function is called for every callout
      in the pattern in the order in which they appear. Its first
      argument is a pointer to a callout enumeration block, and its
      second argument is the <code class="function">user_data</code> value that was passed to
      <code class="function">pcre2_callout_enumerate</code>(). The
      contents of the callout enumeration block are described in
      the <a class="link" href="../htmlman3/pcre2callout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2callout</span>(3)</span></a>
      documentation, which also gives further details about
      callouts.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect34" name="pcre2api-3_sect34" shape="rect"> </a>
      <h2>SERIALIZATION AND PRECOMPILING</h2>
      <p>It is possible to save compiled patterns on disc or
      elsewhere, and reload them later, subject to a number of
      restrictions. The host on which the patterns are reloaded
      must be running the same version of PCRE2, with the same code
      unit width, and must also have the same endianness, pointer
      width, and PCRE2_SIZE type. Before compiled patterns can be
      saved, they must be converted to a "serialized" form, which
      in the case of PCRE2 is really just a bytecode dump. The
      functions whose names begin with <code class="function">pcre2_serialize_</code> are used for converting to
      and from the serialized form. They are described in the
      <a class="link" href="../htmlman3/pcre2serialize.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2serialize</span>(3)</span></a>
      documentation. Note that PCRE2 serialization does not convert
      compiled patterns to an abstract format like Java or .NET
      serialization.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect35" name="pcre2api-3_sect35" shape="rect"> </a>
      <h2>THE MATCH DATA BLOCK</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>pcre2_match_data *pcre2_match_data_create(uint32_t <code class="function">ovecsize</code>,</em></span>
<span class="emphasis"><em>  pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>pcre2_match_data *pcre2_match_data_create_from_pattern(</em></span>
<span class="emphasis"><em>  const pcre2_code *<code class="function">code</code>, pcre2_general_context *<code class="function">gcontext</code>);</em></span>

<span class="emphasis"><em>void pcre2_match_data_free(pcre2_match_data *<code class="function">match_data</code>);</em></span>
</pre>
      </div>
      <p>Information about a successful or unsuccessful match is
      placed in a match data block, which is an opaque structure
      that is accessed by function calls. In particular, the match
      data block contains a vector of offsets into the subject
      string that define the matched part of the subject and any
      substrings that were captured. This is known as the
      <code class="function">ovector</code>.</p>
      <p>Before calling <code class="function">pcre2_match</code>(), <code class="function">pcre2_dfa_match</code>(), or <code class="function">pcre2_jit_match</code>() you must create a match
      data block by calling one of the creation functions above.
      For <code class="function">pcre2_match_data_create</code>(),
      the first argument is the number of pairs of offsets in the
      <code class="function">ovector</code>. One pair of offsets is
      required to identify the string that matched the whole
      pattern, with an additional pair for each captured substring.
      For example, a value of 4 creates enough space to record the
      matched portion of the subject plus three captured
      substrings. A minimum of at least 1 pair is imposed by
      <code class="function">pcre2_match_data_create</code>(), so
      it is always possible to return the overall matched
      string.</p>
      <p>The second argument of <code class="function">pcre2_match_data_create</code>() is a pointer to a
      general context, which can specify custom memory management
      for obtaining the memory for the match data block. If you are
      not using custom memory management, pass NULL, which causes
      <code class="function">malloc</code>() to be used.</p>
      <p>For <code class="function">pcre2_match_data_create_from_pattern</code>(), the
      first argument is a pointer to a compiled pattern. The
      ovector is created to be exactly the right size to hold all
      the substrings a pattern might capture. The second argument
      is again a pointer to a general context, but in this case if
      NULL is passed, the memory is obtained using the same
      allocator that was used for the compiled pattern (custom or
      default).</p>
      <p>A match data block can be used many times, with the same
      or different compiled patterns. You can extract information
      from a match data block after a match operation has finished,
      using functions that are described in the sections on matched
      strings and other match data below.</p>
      <p>When a call of <code class="function">pcre2_match</code>()
      fails, valid data is available in the match block only when
      the error is PCRE2_ERROR_NOMATCH, PCRE2_ERROR_PARTIAL, or one
      of the error codes for an invalid UTF string. Exactly what is
      available depends on the error, and is detailed below.</p>
      <p>When one of the matching functions is called, pointers to
      the compiled pattern and the subject string are set in the
      match data block so that they can be referenced by the
      extraction functions after a successful match. After running
      a match, you must not free a compiled pattern or a subject
      string until after all operations on the match data block
      (for that match) have taken place, unless, in the case of the
      subject string, you have used the PCRE2_COPY_MATCHED_SUBJECT
      option, which is described in the section entitled "Option
      bits for <code class="function">pcre2_match</code>()"
      below.</p>
      <p>When a match data block itself is no longer needed, it
      should be freed by calling <code class="function">pcre2_match_data_free</code>(). If this function
      is called with a NULL argument, it returns immediately,
      without doing anything.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect36" name="pcre2api-3_sect36" shape="rect"> </a>
      <h2>MATCHING A PATTERN: THE TRADITIONAL FUNCTION</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_match(const pcre2_code *<code class="function">code</code>, PCRE2_SPTR <code class="function">subject</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">length</code>, PCRE2_SIZE <code class="function">startoffset</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>);</em></span>
</pre>
      </div>
      <p>The function <code class="function">pcre2_match</code>()
      is called to match a subject string against a compiled
      pattern, which is passed in the <code class="function">code</code> argument. You can call <code class="function">pcre2_match</code>() with the same <code class="function">code</code> argument as many times as you like, in
      order to find multiple matches in the subject string or to
      match different subject strings with the same pattern.</p>
      <p>This function is the main matching facility of the
      library, and it operates in a Perl-like manner. For
      specialist use there is also an alternative matching
      function, which is described below in the section about the
      <code class="function">pcre2_dfa_match</code>() function.</p>
      <p>Here is an example of a simple call to <code class="function">pcre2_match</code>():</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 pcre2_match_data *md = pcre2_match_data_create(4, NULL);
 int rc = pcre2_match(
   re,             /* result of pcre2_compile() */
   "some string",  /* the subject string */
   11,             /* the length of the subject string */
   0,              /* start at offset 0 in the subject */
   0,              /* default options */
   md,             /* the match data block */
   NULL);          /* a match context; NULL means use defaults */
</pre>
      </div>
      <p>If the subject string is zero-terminated, the length can
      be given as PCRE2_ZERO_TERMINATED. A match context must be
      provided if certain less common matching parameters are to be
      changed. For details, see the section on the match context
      above.</p>
      <div class="refsect2">
        <a id="pcre2api-3_sect37" name="pcre2api-3_sect37" shape="rect"> </a>
        <h3>The string to be matched by <code class="function">pcre2_match</code>()</h3>
        <p>The subject string is passed to <code class="function">pcre2_match</code>() as a pointer in
        <code class="function">subject</code>, a length in
        <code class="function">length</code>, and a starting offset
        in <code class="function">startoffset</code>. The length
        and offset are in code units, not characters. That is, they
        are in bytes for the 8-bit library, 16-bit code units for
        the 16-bit library, and 32-bit code units for the 32-bit
        library, whether or not UTF processing is enabled.</p>
        <p>If <code class="function">startoffset</code> is greater
        than the length of the subject, <code class="function">pcre2_match</code>() returns
        PCRE2_ERROR_BADOFFSET. When the starting offset is zero,
        the search for a match starts at the beginning of the
        subject, and this is by far the most common case. In UTF-8
        or UTF-16 mode, the starting offset must point to the start
        of a character, or to the end of the subject (in UTF-32
        mode, one code unit equals one character, so all offsets
        are valid). Like the pattern string, the subject may
        contain binary zeros.</p>
        <p>A non-zero starting offset is useful when searching for
        another match in the same subject by calling <code class="function">pcre2_match</code>() again after a previous
        success. Setting <code class="function">startoffset</code>
        differs from passing over a shortened string and setting
        PCRE2_NOTBOL in the case of a pattern that begins with any
        kind of lookbehind. For example, consider the pattern</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
\Biss\B
</pre>
        </div>
        <p>which finds occurrences of "iss" in the middle of words.
        (\B matches only if the current position in the subject is
        not a word boundary.) When applied to the string
        "Mississipi" the first call to <code class="function">pcre2_match</code>() finds the first occurrence.
        If <code class="function">pcre2_match</code>() is called
        again with just the remainder of the subject, namely
        "issipi", it does not match, because \B is always false at
        the start of the subject, which is deemed to be a word
        boundary. However, if <code class="function">pcre2_match</code>() is passed the entire string
        again, but with <code class="function">startoffset</code>
        set to 4, it finds the second occurrence of "iss" because
        it is able to look behind the starting point to discover
        that it is preceded by a letter.</p>
        <p>Finding all the matches in a subject is tricky when the
        pattern can match an empty string. It is possible to
        emulate Perl's /g behaviour by first trying the match again
        at the same offset, with the PCRE2_NOTEMPTY_ATSTART and
        PCRE2_ANCHORED options, and then if that fails, advancing
        the starting offset and trying an ordinary match again.
        There is some code that demonstrates how to do this in the
        <span class="citerefentry"><span class="refentrytitle">pcre2demo</span>(3)</span> sample program.
        In the most general case, you have to check to see if the
        newline convention recognizes CRLF as a newline, and if so,
        and the current character is CR followed by LF, advance the
        starting offset by two characters instead of one.</p>
        <p>If a non-zero starting offset is passed when the pattern
        is anchored, a single attempt to match at the given offset
        is made. This can only succeed if the pattern does not
        require the match to be at the start of the subject. In
        other words, the anchoring must be the result of setting
        the PCRE2_ANCHORED option or the use of .* with
        PCRE2_DOTALL, not by starting the pattern with ^ or \A.</p>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect38" name="pcre2api-3_sect38" shape="rect"> </a>
        <h3>Option bits for <code class="function">pcre2_match</code>()</h3>
        <p>The unused bits of the <code class="function">options</code> argument for <code class="function">pcre2_match</code>() must be zero. The only bits
        that may be set are PCRE2_ANCHORED,
        PCRE2_COPY_MATCHED_SUBJECT, PCRE2_ENDANCHORED,
        PCRE2_NOTBOL, PCRE2_NOTEOL, PCRE2_NOTEMPTY,
        PCRE2_NOTEMPTY_ATSTART, PCRE2_NO_JIT, PCRE2_NO_UTF_CHECK,
        PCRE2_PARTIAL_HARD, and PCRE2_PARTIAL_SOFT. Their action is
        described below.</p>
        <p>Setting PCRE2_ANCHORED or PCRE2_ENDANCHORED at match
        time is not supported by the just-in-time (JIT) compiler.
        If it is set, JIT matching is disabled and the interpretive
        code in <code class="function">pcre2_match</code>() is run.
        Apart from PCRE2_NO_JIT (obviously), the remaining options
        are supported for JIT matching.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ANCHORED
</pre>
        </div>
        <p>The PCRE2_ANCHORED option limits <code class="function">pcre2_match</code>() to matching at the first
        matching position. If a pattern was compiled with
        PCRE2_ANCHORED, or turned out to be anchored by virtue of
        its contents, it cannot be made unachored at matching time.
        Note that setting the option at match time disables JIT
        matching.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_COPY_MATCHED_SUBJECT
</pre>
        </div>
        <p>By default, a pointer to the subject is remembered in
        the match data block so that, after a successful match, it
        can be referenced by the substring extraction functions.
        This means that the subject's memory must not be freed
        until all such operations are complete. For some
        applications where the lifetime of the subject string is
        not guaranteed, it may be necessary to make a copy of the
        subject string, but it is wasteful to do this unless the
        match is successful. After a successful match, if
        PCRE2_COPY_MATCHED_SUBJECT is set, the subject is copied
        and the new pointer is remembered in the match data block
        instead of the original subject pointer. The memory
        allocator that was used for the match block itself is used.
        The copy is automatically freed when <code class="function">pcre2_match_data_free</code>() is called to free
        the match data block. It is also automatically freed if the
        match data block is re-used for another match
        operation.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ENDANCHORED
</pre>
        </div>
        <p>If the PCRE2_ENDANCHORED option is set, any string that
        <code class="function">pcre2_match</code>() matches must be
        right at the end of the subject string. Note that setting
        the option at match time disables JIT matching.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NOTBOL
</pre>
        </div>
        <p>This option specifies that first character of the
        subject string is not the beginning of a line, so the
        circumflex metacharacter should not match before it.
        Setting this without having set PCRE2_MULTILINE at compile
        time causes circumflex never to match. This option affects
        only the behaviour of the circumflex metacharacter. It does
        not affect \A.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NOTEOL
</pre>
        </div>
        <p>This option specifies that the end of the subject string
        is not the end of a line, so the dollar metacharacter
        should not match it nor (except in multiline mode) a
        newline immediately before it. Setting this without having
        set PCRE2_MULTILINE at compile time causes dollar never to
        match. This option affects only the behaviour of the dollar
        metacharacter. It does not affect \Z or \z.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NOTEMPTY
</pre>
        </div>
        <p>An empty string is not considered to be a valid match if
        this option is set. If there are alternatives in the
        pattern, they are tried. If all the alternatives match the
        empty string, the entire match fails. For example, if the
        pattern</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
a?b?
</pre>
        </div>
        <p>is applied to a string not beginning with "a" or "b", it
        matches an empty string at the start of the subject. With
        PCRE2_NOTEMPTY set, this match is not valid, so
        <code class="function">pcre2_match</code>() searches
        further into the string for occurrences of "a" or "b".</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NOTEMPTY_ATSTART
</pre>
        </div>
        <p>This is like PCRE2_NOTEMPTY, except that it locks out an
        empty string match only at the first matching position,
        that is, at the start of the subject plus the starting
        offset. An empty string match later in the subject is
        permitted. If the pattern is anchored, such a match can
        occur only if the pattern contains \K.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NO_JIT
</pre>
        </div>
        <p>By default, if a pattern has been successfully processed
        by <code class="function">pcre2_jit_compile</code>(), JIT
        is automatically used when <code class="function">pcre2_match</code>() is called with options that
        JIT supports. Setting PCRE2_NO_JIT disables the use of JIT;
        it forces matching to be done by the interpreter.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_NO_UTF_CHECK
</pre>
        </div>
        <p>When PCRE2_UTF is set at compile time, the validity of
        the subject as a UTF string is checked unless
        PCRE2_NO_UTF_CHECK is passed to <code class="function">pcre2_match</code>() or PCRE2_MATCH_INVALID_UTF
        was passed to <code class="function">pcre2_compile</code>(). The latter special case
        is discussed in detail in the <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a>
        documentation.</p>
        <p>In the default case, if a non-zero starting offset is
        given, the check is applied only to that part of the
        subject that could be inspected during matching, and there
        is a check that the starting offset points to the first
        code unit of a character or to the end of the subject. If
        there are no lookbehind assertions in the pattern, the
        check starts at the starting offset. Otherwise, it starts
        at the length of the longest lookbehind before the starting
        offset, or at the start of the subject if there are not
        that many characters before the starting offset. Note that
        the sequences \b and \B are one-character lookbehinds.</p>
        <p>The check is carried out before any other processing
        takes place, and a negative error code is returned if the
        check fails. There are several UTF error codes for each
        code unit width, corresponding to different problems with
        the code unit sequence. There are discussions about the
        validity of UTF-8 strings, UTF-16 strings, and UTF-32
        strings in the <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a>
        documentation.</p>
        <p>If you know that your subject is valid, and you want to
        skip this check for performance reasons, you can set the
        PCRE2_NO_UTF_CHECK option when calling <code class="function">pcre2_match</code>(). You might want to do this
        for the second and subsequent calls to <code class="function">pcre2_match</code>() if you are making repeated
        calls to find multiple matches in the same subject
        string.</p>
        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Warning">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25" colspan="1"><img alt="[Warning]" src="../stylesheet/warning.png" /></td>
              <th align="left" rowspan="1" colspan="1">Warning</th>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">
                <p>Unless PCRE2_MATCH_INVALID_UTF was set at
                compile time, when PCRE2_NO_UTF_CHECK is set at
                match time the effect of passing an invalid string
                as a subject, or an invalid value of <code class="function">startoffset</code>, is undefined. Your
                program may crash or loop indefinitely or give
                wrong results.</p>
              </td>
            </tr>
          </table>
        </div>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE2_PARTIAL_HARD
 PCRE2_PARTIAL_SOFT
</pre>
        </div>
        <p>These options turn on the partial matching feature. A
        partial match occurs if the end of the subject string is
        reached successfully, but there are not enough subject
        characters to complete the match. In addition, either at
        least one character must have been inspected or the pattern
        must contain a lookbehind, or the pattern must be one that
        could match an empty string.</p>
        <p>If this situation arises when PCRE2_PARTIAL_SOFT (but
        not PCRE2_PARTIAL_HARD) is set, matching continues by
        testing any remaining alternatives. Only if no complete
        match can be found is PCRE2_ERROR_PARTIAL returned instead
        of PCRE2_ERROR_NOMATCH. In other words, PCRE2_PARTIAL_SOFT
        specifies that the caller is prepared to handle a partial
        match, but only if no complete match can be found.</p>
        <p>If PCRE2_PARTIAL_HARD is set, it overrides
        PCRE2_PARTIAL_SOFT. In this case, if a partial match is
        found, <code class="function">pcre2_match</code>()
        immediately returns PCRE2_ERROR_PARTIAL, without
        considering any other alternatives. In other words, when
        PCRE2_PARTIAL_HARD is set, a partial match is considered to
        be more important that an alternative complete match.</p>
        <p>There is a more detailed discussion of partial and
        multi-segment matching, with examples, in the <a class="link" href="../htmlman3/pcre2partial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2partial</span>(3)</span></a>
        documentation.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect39" name="pcre2api-3_sect39" shape="rect"> </a>
      <h2>NEWLINE HANDLING WHEN MATCHING</h2>
      <p>When PCRE2 is built, a default newline convention is set;
      this is usually the standard convention for the operating
      system. The default can be overridden in a compile context by
      calling <code class="function">pcre2_set_newline</code>(). It
      can also be overridden by starting a pattern string with, for
      example, (*CRLF), as described in the section on newline
      conventions in the <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a> page.
      During matching, the newline choice affects the behaviour of
      the dot, circumflex, and dollar metacharacters. It may also
      alter the way the match starting position is advanced after a
      match failure for an unanchored pattern.</p>
      <p>When PCRE2_NEWLINE_CRLF, PCRE2_NEWLINE_ANYCRLF, or
      PCRE2_NEWLINE_ANY is set as the newline convention, and a
      match attempt for an unanchored pattern fails when the
      current starting position is at a CRLF sequence, and the
      pattern contains no explicit matches for CR or LF characters,
      the match position is advanced by two characters instead of
      one, in other words, to after the CRLF.</p>
      <p>The above rule is a compromise that makes the most common
      cases work as expected. For example, if the pattern is .+A
      (and the PCRE2_DOTALL option is not set), it does not match
      the string "\r\nA" because, after failing at the start, it
      skips both the CR and the LF before retrying. However, the
      pattern [\r\n]A does match that string, because it contains
      an explicit CR or LF reference, and so advances only by one
      character after the first failure.</p>
      <p>An explicit match for CR of LF is either a literal
      appearance of one of those characters in the pattern, or one
      of the \r or \n or equivalent octal or hexadecimal escape
      sequences. Implicit matches such as [^X] do not count, nor
      does \s, even though it includes CR and LF in the characters
      that it matches.</p>
      <p>Notwithstanding the above, anomalous effects may still
      occur when CRLF is a valid newline sequence and explicit \r
      or \n escapes appear in the pattern.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect40" name="pcre2api-3_sect40" shape="rect"> </a>
      <h2>HOW PCRE2_MATCH() RETURNS A STRING AND CAPTURED
      SUBSTRINGS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>uint32_t pcre2_get_ovector_count(pcre2_match_data *<code class="function">match_data</code>);</em></span>

<span class="emphasis"><em>PCRE2_SIZE *pcre2_get_ovector_pointer(pcre2_match_data *<code class="function">match_data</code>);</em></span>
</pre>
      </div>
      <p>In general, a pattern matches a certain portion of the
      subject, and in addition, further substrings from the subject
      may be picked out by parenthesized parts of the pattern.
      Following the usage in Jeffrey Friedl's book, this is called
      "capturing" in what follows, and the phrase "capture group"
      (Perl terminology) is used for a fragment of a pattern that
      picks out a substring. PCRE2 supports several other kinds of
      parenthesized group that do not cause substrings to be
      captured. The <code class="function">pcre2_pattern_info</code>() function can be used
      to find out how many capture groups there are in a compiled
      pattern.</p>
      <p>You can use auxiliary functions for accessing captured
      substrings by number or by name, as described in sections
      below.</p>
      <p>Alternatively, you can make direct use of the vector of
      PCRE2_SIZE values, called the <code class="function">ovector</code>, which contains the offsets of
      captured strings. It is part of the match data block. The
      function <code class="function">pcre2_get_ovector_pointer</code>() returns the
      address of the ovector, and <code class="function">pcre2_get_ovector_count</code>() returns the
      number of pairs of values it contains.</p>
      <p>Within the ovector, the first in each pair of values is
      set to the offset of the first code unit of a substring, and
      the second is set to the offset of the first code unit after
      the end of a substring. These values are always code unit
      offsets, not character offsets. That is, they are byte
      offsets in the 8-bit library, 16-bit offsets in the 16-bit
      library, and 32-bit offsets in the 32-bit library.</p>
      <p>After a partial match (error return PCRE2_ERROR_PARTIAL),
      only the first pair of offsets (that is, <em class="replaceable"><code>ovector[0]</code></em> and <em class="replaceable"><code>ovector[1]</code></em>) are set. They
      identify the part of the subject that was partially matched.
      See the <a class="link" href="../htmlman3/pcre2partial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2partial</span>(3)</span></a>
      documentation for details of partial matching.</p>
      <p>After a fully successful match, the first pair of offsets
      identifies the portion of the subject string that was matched
      by the entire pattern. The next pair is used for the first
      captured substring, and so on. The value returned by
      <code class="function">pcre2_match</code>() is one more than
      the highest numbered pair that has been set. For example, if
      two substrings have been captured, the returned value is 3.
      If there are no captured substrings, the return value from a
      successful match is 1, indicating that just the first pair of
      offsets has been set.</p>
      <p>If a pattern uses the \K escape sequence within a positive
      assertion, the reported start of a successful match can be
      greater than the end of the match. For example, if the
      pattern (?=ab\K) is matched against "ab", the start and end
      offset values for the match are 2 and 0.</p>
      <p>If a capture group is matched repeatedly within a single
      match operation, it is the last portion of the subject that
      it matched that is returned.</p>
      <p>If the ovector is too small to hold all the captured
      substring offsets, as much as possible is filled in, and the
      function returns a value of zero. If captured substrings are
      not of interest, <code class="function">pcre2_match</code>()
      may be called with a match data block whose ovector is of
      minimum length (that is, one pair).</p>
      <p>It is possible for capture group number <em class="replaceable"><code>n+1</code></em> to match some part of the
      subject when group <code class="literal">n</code> has not
      been used at all. For example, if the string "abc" is matched
      against the pattern (a|(z))(bc) the return from the function
      is 4, and groups 1 and 3 are matched, but 2 is not. When this
      happens, both values in the offset pairs corresponding to
      unused groups are set to PCRE2_UNSET.</p>
      <p>Offset values that correspond to unused groups at the end
      of the expression are also set to PCRE2_UNSET. For example,
      if the string "abc" is matched against the pattern
      (abc)(x(yz)?)? groups 2 and 3 are not matched. The return
      from the function is 2, because the highest used capture
      group number is 1. The offsets for for the second and third
      capture groupss (assuming the vector is large enough, of
      course) are set to PCRE2_UNSET.</p>
      <p>Elements in the ovector that do not correspond to
      capturing parentheses in the pattern are never changed. That
      is, if a pattern contains <code class="literal">n</code>
      capturing parentheses, no more than <em class="replaceable"><code>ovector[0]</code></em> to <em class="replaceable"><code>ovector[2n+1]</code></em> are set by
      <code class="function">pcre2_match</code>(). The other
      elements retain whatever values they previously had. After a
      failed match attempt, the contents of the ovector are
      unchanged.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect41" name="pcre2api-3_sect41" shape="rect"> </a>
      <h2>OTHER INFORMATION ABOUT A MATCH</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>PCRE2_SPTR pcre2_get_mark(pcre2_match_data *<code class="function">match_data</code>);</em></span>

<span class="emphasis"><em>PCRE2_SIZE pcre2_get_startchar(pcre2_match_data *<code class="function">match_data</code>);</em></span>
</pre>
      </div>
      <p>As well as the offsets in the ovector, other information
      about a match is retained in the match data block and can be
      retrieved by the above functions in appropriate
      circumstances. If they are called at other times, the result
      is undefined.</p>
      <p>After a successful match, a partial match
      (PCRE2_ERROR_PARTIAL), or a failure to match
      (PCRE2_ERROR_NOMATCH), a mark name may be available. The
      function <code class="function">pcre2_get_mark</code>() can
      be called to access this name, which can be specified in the
      pattern by any of the backtracking control verbs, not just
      (*MARK). The same function applies to all the verbs. It
      returns a pointer to the zero-terminated name, which is
      within the compiled pattern. If no name is available, NULL is
      returned. The length of the name (excluding the terminating
      zero) is stored in the code unit that precedes the name. You
      should use this length instead of relying on the terminating
      zero if the name might contain a binary zero.</p>
      <p>After a successful match, the name that is returned is the
      last mark name encountered on the matching path through the
      pattern. Instances of backtracking verbs without names do not
      count. Thus, for example, if the matching path contains
      (*MARK:A)(*PRUNE), the name "A" is returned. After a "no
      match" or a partial match, the last encountered name is
      returned. For example, consider this pattern:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
^(*MARK:A)((*MARK:B)a|b)c
</pre>
      </div>
      <p>When it matches "bc", the returned name is A. The B mark
      is "seen" in the first branch of the group, but it is not on
      the matching path. On the other hand, when this pattern fails
      to match "bx", the returned name is B.</p>
      <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Warning">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Warning]" src="../stylesheet/warning.png" /></td>
            <th align="left" rowspan="1" colspan="1">Warning</th>
          </tr>
          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <p>By default, certain start-of-match optimizations
              are used to give a fast "no match" result in some
              situations. For example, if the anchoring is removed
              from the pattern above, there is an initial check for
              the presence of "c" in the subject before running the
              matching engine. This check fails for "bx", causing a
              match failure without seeing any marks. You can
              disable the start-of-match optimizations by setting
              the PCRE2_NO_START_OPTIMIZE option for <code class="function">pcre2_compile</code>() or by starting the
              pattern with (*NO_START_OPT).</p>
            </td>
          </tr>
        </table>
      </div>
      <p>After a successful match, a partial match, or one of the
      invalid UTF errors (for example, PCRE2_ERROR_UTF8_ERR5),
      <code class="function">pcre2_get_startchar</code>() can be
      called. After a successful or partial match it returns the
      code unit offset of the character at which the match started.
      For a non-partial match, this can be different to the value
      of <em class="replaceable"><code>ovector[0]</code></em> if
      the pattern contains the \K escape sequence. After a partial
      match, however, this value is always the same as <em class="replaceable"><code>ovector[0]</code></em> because \K does
      not affect the result of a partial match.</p>
      <p>After a UTF check failure, <code class="function">pcre2_get_startchar</code>() can be used to obtain
      the code unit offset of the invalid UTF character. Details
      are given in the <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a> page.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect42" name="pcre2api-3_sect42" shape="rect"> </a>
      <h2>ERROR RETURNS FROM <code class="function">pcre2_match</code>()</h2>
      <p>If <code class="function">pcre2_match</code>() fails, it
      returns a negative number. This can be converted to a text
      string by calling the <code class="function">pcre2_get_error_message</code>() function (see
      "Obtaining a textual error message" below). Negative error
      codes are also returned by other functions, and are
      documented with them. The codes are given names in the header
      file. If UTF checking is in force and an invalid UTF subject
      string is detected, one of a number of UTF-specific negative
      error codes is returned. Details are given in the <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a> page. The
      following are the other errors that may be returned by
      <code class="function">pcre2_match</code>():</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_NOMATCH
</pre>
      </div>
      <p>The subject string did not match the pattern.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_PARTIAL
</pre>
      </div>
      <p>The subject string did not match, but it did match
      partially. See the <a class="link" href="../htmlman3/pcre2partial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2partial</span>(3)</span></a>
      documentation for details of partial matching.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_BADMAGIC
</pre>
      </div>
      <p>PCRE2 stores a 4-byte "magic number" at the start of the
      compiled code, to catch the case when it is passed a junk
      pointer. This is the error that is returned when the magic
      number is not present.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_BADMODE
</pre>
      </div>
      <p>This error is given when a compiled pattern is passed to a
      function in a library of a different code unit width, for
      example, a pattern compiled by the 8-bit library is passed to
      a 16-bit or 32-bit library function.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_BADOFFSET
</pre>
      </div>
      <p>The value of <code class="function">startoffset</code> was
      greater than the length of the subject.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_BADOPTION
</pre>
      </div>
      <p>An unrecognized bit was set in the <code class="function">options</code> argument.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_BADUTFOFFSET
</pre>
      </div>
      <p>The UTF code unit sequence that was passed as a subject
      was checked and found to be valid (the PCRE2_NO_UTF_CHECK
      option was not set), but the value of <code class="function">startoffset</code> did not point to the beginning
      of a UTF character or the end of the subject.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_CALLOUT
</pre>
      </div>
      <p>This error is never generated by <code class="function">pcre2_match</code>() itself. It is provided for
      use by callout functions that want to cause <code class="function">pcre2_match</code>() or <code class="function">pcre2_callout_enumerate</code>() to return a
      distinctive error code. See the <a class="link" href="../htmlman3/pcre2callout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2callout</span>(3)</span></a>
      documentation for details.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_DEPTHLIMIT
</pre>
      </div>
      <p>The nested backtracking depth limit was reached.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_HEAPLIMIT
</pre>
      </div>
      <p>The heap limit was reached.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_INTERNAL
</pre>
      </div>
      <p>An unexpected internal error has occurred. This error
      could be caused by a bug in PCRE2 or by overwriting of the
      compiled pattern.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_JIT_STACKLIMIT
</pre>
      </div>
      <p>This error is returned when a pattern that was
      successfully studied using JIT is being matched, but the
      memory available for the just-in-time processing stack is not
      large enough. See the <a class="link" href="../htmlman3/pcre2jit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2jit</span>(3)</span></a> documentation
      for more details.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_MATCHLIMIT
</pre>
      </div>
      <p>The backtracking match limit was reached.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_NOMEMORY
</pre>
      </div>
      <p>If a pattern contains many nested backtracking points,
      heap memory is used to remember them. This error is given
      when the memory allocation function (default or custom)
      fails. Note that a different error, PCRE2_ERROR_HEAPLIMIT, is
      given if the amount of memory needed exceeds the heap limit.
      PCRE2_ERROR_NOMEMORY is also returned if
      PCRE2_COPY_MATCHED_SUBJECT is set and memory allocation
      fails.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_NULL
</pre>
      </div>
      <p>Either the <code class="function">code</code>,
      <code class="function">subject</code>, or <code class="function">match_data</code> argument was passed as NULL.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_RECURSELOOP
</pre>
      </div>
      <p>This error is returned when <code class="function">pcre2_match</code>() detects a recursion loop
      within the pattern. Specifically, it means that either the
      whole pattern or a capture group has been called recursively
      for the second time at the same position in the subject
      string. Some simple patterns that might do this are detected
      and faulted at compile time, but more complicated cases, in
      particular mutual recursions between two different groups,
      cannot be detected until matching is attempted.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect43" name="pcre2api-3_sect43" shape="rect"> </a>
      <h2>OBTAINING A TEXTUAL ERROR MESSAGE</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_get_error_message(int <code class="function">errorcode</code>, PCRE2_UCHAR *<code class="function">buffer</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">bufflen</code>);</em></span>
</pre>
      </div>
      <p>A text message for an error code from any PCRE2 function
      (compile, match, or auxiliary) can be obtained by calling
      <code class="function">pcre2_get_error_message</code>(). The
      code is passed as the first argument, with the remaining two
      arguments specifying a code unit buffer and its length in
      code units, into which the text message is placed. The
      message is returned in code units of the appropriate width
      for the library that is being used.</p>
      <p>The returned message is terminated with a trailing zero,
      and the function returns the number of code units used,
      excluding the trailing zero. If the error number is unknown,
      the negative error code PCRE2_ERROR_BADDATA is returned. If
      the buffer is too small, the message is truncated (but still
      with a trailing zero), and the negative error code
      PCRE2_ERROR_NOMEMORY is returned. None of the messages are
      very long; a buffer size of 120 code units is ample.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect44" name="pcre2api-3_sect44" shape="rect"> </a>
      <h2>EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_substring_length_bynumber(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">number</code>, PCRE2_SIZE *<code class="function">length</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_copy_bynumber(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">number</code>, PCRE2_UCHAR *<code class="function">buffer</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE *<code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_get_bynumber(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">number</code>, PCRE2_UCHAR **<code class="function">bufferptr</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE *<code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>void pcre2_substring_free(PCRE2_UCHAR *<code class="function">buffer</code>);</em></span>
</pre>
      </div>
      <p>Captured substrings can be accessed directly by using the
      ovector as described above. For convenience, auxiliary
      functions are provided for extracting captured substrings as
      new, separate, zero-terminated strings. A substring that
      contains a binary zero is correctly extracted and has a
      further zero added on the end, but the result is not, of
      course, a C string.</p>
      <p>The functions in this section identify substrings by
      number. The number zero refers to the entire matched
      substring, with higher numbers referring to substrings
      captured by parenthesized groups. After a partial match, only
      substring zero is available. An attempt to extract any other
      substring gives the error PCRE2_ERROR_PARTIAL. The next
      section describes similar functions for extracting captured
      substrings by name.</p>
      <p>If a pattern uses the \K escape sequence within a positive
      assertion, the reported start of a successful match can be
      greater than the end of the match. For example, if the
      pattern (?=ab\K) is matched against "ab", the start and end
      offset values for the match are 2 and 0. In this situation,
      calling these functions with a zero substring number extracts
      a zero-length empty string.</p>
      <p>You can find the length in code units of a captured
      substring without extracting it by calling <code class="function">pcre2_substring_length_bynumber</code>(). The
      first argument is a pointer to the match data block, the
      second is the group number, and the third is a pointer to a
      variable into which the length is placed. If you just want to
      know whether or not the substring has been captured, you can
      pass the third argument as NULL.</p>
      <p>The <code class="function">pcre2_substring_copy_bynumber</code>() function
      copies a captured substring into a supplied buffer, whereas
      <code class="function">pcre2_substring_get_bynumber</code>()
      copies it into new memory, obtained using the same memory
      allocation function that was used for the match data block.
      The first two arguments of these functions are a pointer to
      the match data block and a capture group number.</p>
      <p>The final arguments of <code class="function">pcre2_substring_copy_bynumber</code>() are a
      pointer to the buffer and a pointer to a variable that
      contains its length in code units. This is updated to contain
      the actual number of code units used for the extracted
      substring, excluding the terminating zero.</p>
      <p>For <code class="function">pcre2_substring_get_bynumber</code>() the third
      and fourth arguments point to variables that are updated with
      a pointer to the new memory and the number of code units that
      comprise the substring, again excluding the terminating zero.
      When the substring is no longer needed, the memory should be
      freed by calling <code class="function">pcre2_substring_free</code>().</p>
      <p>The return value from all these functions is zero for
      success, or a negative error code. If the pattern match
      failed, the match failure code is returned. If a substring
      number greater than zero is used after a partial match,
      PCRE2_ERROR_PARTIAL is returned. Other possible error codes
      are:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_NOMEMORY
</pre>
      </div>
      <p>The buffer was too small for <code class="function">pcre2_substring_copy_bynumber</code>(), or the
      attempt to get memory failed for <code class="function">pcre2_substring_get_bynumber</code>().</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_NOSUBSTRING
</pre>
      </div>
      <p>There is no substring with that number in the pattern,
      that is, the number is greater than the number of capturing
      parentheses.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_UNAVAILABLE
</pre>
      </div>
      <p>The substring number, though not greater than the number
      of captures in the pattern, is greater than the number of
      slots in the ovector, so the substring could not be
      captured.</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_UNSET
</pre>
      </div>
      <p>The substring did not participate in the match. For
      example, if the pattern is (abc)|(def) and the subject is
      "def", and the ovector contains at least two capturing slots,
      substring number 1 is unset.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect45" name="pcre2api-3_sect45" shape="rect"> </a>
      <h2>EXTRACTING A LIST OF ALL CAPTURED SUBSTRINGS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_substring_list_get(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  PCRE2_UCHAR ***<code class="function">listptr</code>, PCRE2_SIZE **<code class="function">lengthsptr</code>);</em></span>

<span class="emphasis"><em>void pcre2_substring_list_free(PCRE2_SPTR *<code class="function">list</code>);</em></span>
</pre>
      </div>
      <p>The <code class="function">pcre2_substring_list_get</code>() function
      extracts all available substrings and builds a list of
      pointers to them. It also (optionally) builds a second list
      that contains their lengths (in code units), excluding a
      terminating zero that is added to each of them. All this is
      done in a single block of memory that is obtained using the
      same memory allocation function that was used to get the
      match data block.</p>
      <p>This function must be called only after a successful
      match. If called after a partial match, the error code
      PCRE2_ERROR_PARTIAL is returned.</p>
      <p>The address of the memory block is returned via
      <code class="function">listptr</code>, which is also the
      start of the list of string pointers. The end of the list is
      marked by a NULL pointer. The address of the list of lengths
      is returned via <code class="function">lengthsptr</code>. If
      your strings do not contain binary zeros and you do not
      therefore need the lengths, you may supply NULL as the
      <code class="function">lengthsptr</code> argument to disable
      the creation of a list of lengths. The yield of the function
      is zero if all went well, or PCRE2_ERROR_NOMEMORY if the
      memory block could not be obtained. When the list is no
      longer needed, it should be freed by calling <code class="function">pcre2_substring_list_free</code>().</p>
      <p>If this function encounters a substring that is unset,
      which can happen when capture group number <em class="replaceable"><code>n+1</code></em> matches some part of the
      subject, but group <code class="literal">n</code> has not
      been used at all, it returns an empty string. This can be
      distinguished from a genuine zero-length substring by
      inspecting the appropriate offset in the ovector, which
      contain PCRE2_UNSET for unset substrings, or by calling
      <code class="function">pcre2_substring_length_bynumber</code>().</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect46" name="pcre2api-3_sect46" shape="rect"> </a>
      <h2>EXTRACTING CAPTURED SUBSTRINGS BY NAME</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_substring_number_from_name(const pcre2_code *<code class="function">code</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_length_byname(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>, PCRE2_SIZE *<code class="function">length</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_copy_byname(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>, PCRE2_UCHAR *<code class="function">buffer</code>, PCRE2_SIZE *<code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>int pcre2_substring_get_byname(pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>, PCRE2_UCHAR **<code class="function">bufferptr</code>, PCRE2_SIZE *<code class="function">bufflen</code>);</em></span>

<span class="emphasis"><em>void pcre2_substring_free(PCRE2_UCHAR *<code class="function">buffer</code>);</em></span>
</pre>
      </div>
      <p>To extract a substring by name, you first have to find
      associated number. For example, for this pattern:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
(a+)b(?&lt;xxx&gt;\d+)...
</pre>
      </div>
      <p>the number of the capture group called "xxx" is 2. If the
      name is known to be unique (PCRE2_DUPNAMES was not set), you
      can find the number from the name by calling <code class="function">pcre2_substring_number_from_name</code>(). The
      first argument is the compiled pattern, and the second is the
      name. The yield of the function is the group number,
      PCRE2_ERROR_NOSUBSTRING if there is no group with that name,
      or PCRE2_ERROR_NOUNIQUESUBSTRING if there is more than one
      group with that name. Given the number, you can extract the
      substring directly from the ovector, or use one of the
      "bynumber" functions described above.</p>
      <p>For convenience, there are also "byname" functions that
      correspond to the "bynumber" functions, the only difference
      being that the second argument is a name instead of a number.
      If PCRE2_DUPNAMES is set and there are duplicate names, these
      functions scan all the groups with the given name, and return
      the captured substring from the first named group that is
      set.</p>
      <p>If there are no groups with the given name,
      PCRE2_ERROR_NOSUBSTRING is returned. If all groups with the
      name have numbers that are greater than the number of slots
      in the ovector, PCRE2_ERROR_UNAVAILABLE is returned. If there
      is at least one group with a slot in the ovector, but no
      group is found to be set, PCRE2_ERROR_UNSET is returned.</p>
      <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Warning">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Warning]" src="../stylesheet/warning.png" /></td>
            <th align="left" rowspan="1" colspan="1">Warning</th>
          </tr>
          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <p>If the pattern uses the (?| feature to set up
              multiple capture groups with the same number, as
              described in the section on duplicate group numbers
              in the <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a>
              page, you cannot use names to distinguish the
              different capture groups, because names are not
              included in the compiled code. The matching process
              uses only numbers. For this reason, the use of
              different names for groups with the same number
              causes an error at compile time.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect47" name="pcre2api-3_sect47" shape="rect"> </a>
      <h2>CREATING A NEW STRING WITH SUBSTITUTIONS</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_substitute(const pcre2_code *<code class="function">code</code>, PCRE2_SPTR <code class="function">subject</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">length</code>, PCRE2_SIZE <code class="function">startoffset</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>, PCRE2_SPTR <code class="function">replacement</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">rlength</code>, PCRE2_UCHAR *<code class="function">outputbuffer</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE *<code class="function">outlengthptr</code>);</em></span>
</pre>
      </div>
      <p>This function optionally calls <code class="function">pcre2_match</code>() and then makes a copy of the
      subject string in <code class="function">outputbuffer</code>,
      replacing parts that were matched with the <code class="function">replacement</code> string, whose length is
      supplied in <code class="function">rlength</code>. This can
      be given as PCRE2_ZERO_TERMINATED for a zero-terminated
      string. There is an option (see
      PCRE2_SUBSTITUTE_REPLACEMENT_ONLY below) to return just the
      replacement string(s). The default action is to perform just
      one replacement if the pattern matches, but there is an
      option that requests multiple replacements (see
      PCRE2_SUBSTITUTE_GLOBAL below).</p>
      <p>If successful, <code class="function">pcre2_substitute</code>() returns the number of
      substitutions that were carried out. This may be zero if no
      match was found, and is never greater than one unless
      PCRE2_SUBSTITUTE_GLOBAL is set. A negative value is returned
      if an error is detected.</p>
      <p>Matches in which a \K item in a lookahead in the pattern
      causes the match to end before it starts are not supported,
      and give rise to an error return. For global replacements,
      matches in which \K in a lookbehind causes the match to start
      earlier than the point that was reached in the previous
      iteration are also not supported.</p>
      <p>The first seven arguments of <code class="function">pcre2_substitute</code>() are the same as for
      <code class="function">pcre2_match</code>(), except that the
      partial matching options are not permitted, and <code class="function">match_data</code> may be passed as NULL, in which
      case a match data block is obtained and freed within this
      function, using memory management functions from the match
      context, if provided, or else those that were used to
      allocate memory for the compiled code.</p>
      <p>If <code class="function">match_data</code> is not NULL
      and PCRE2_SUBSTITUTE_MATCHED is not set, the provided block
      is used for all calls to <code class="function">pcre2_match</code>(), and its contents afterwards
      are the result of the final call. For global changes, this
      will always be a no-match error. The contents of the ovector
      within the match data block may or may not have been
      changed.</p>
      <p>As well as the usual options for <code class="function">pcre2_match</code>(), a number of additional
      options can be set in the <code class="function">options</code> argument of <code class="function">pcre2_substitute</code>(). One such option is
      PCRE2_SUBSTITUTE_MATCHED. When this is set, an external
      <code class="function">match_data</code> block must be
      provided, and it must have been used for an external call to
      <code class="function">pcre2_match</code>(). The data in the
      <code class="function">match_data</code> block (return code,
      offset vector) is used for the first substitution instead of
      calling <code class="function">pcre2_match</code>() from
      within <code class="function">pcre2_substitute</code>(). This
      allows an application to check for a match before choosing to
      substitute, without having to repeat the match.</p>
      <p>The contents of the externally supplied match data block
      are not changed when PCRE2_SUBSTITUTE_MATCHED is set. If
      PCRE2_SUBSTITUTE_GLOBAL is also set, <code class="function">pcre2_match</code>() is called after the first
      substitution to check for further matches, but this is done
      using an internally obtained match data block, thus always
      leaving the external block unchanged.</p>
      <p>The <code class="function">code</code> argument is not
      used for matching before the first substitution when
      PCRE2_SUBSTITUTE_MATCHED is set, but it must be provided,
      even when PCRE2_SUBSTITUTE_GLOBAL is not set, because it
      contains information such as the UTF setting and the number
      of capturing parentheses in the pattern.</p>
      <p>The default action of <code class="function">pcre2_substitute</code>() is to return a copy of
      the subject string with matched substrings replaced. However,
      if PCRE2_SUBSTITUTE_REPLACEMENT_ONLY is set, only the
      replacement substrings are returned. In the global case,
      multiple replacements are concatenated in the output buffer.
      Substitution callouts (see below) can be used to separate
      them if necessary.</p>
      <p>The <code class="function">outlengthptr</code> argument of
      <code class="function">pcre2_substitute</code>() must point
      to a variable that contains the length, in code units, of the
      output buffer. If the function is successful, the value is
      updated to contain the length in code units of the new
      string, excluding the trailing zero that is automatically
      added.</p>
      <p>If the function is not successful, the value set via
      <code class="function">outlengthptr</code> depends on the
      type of error. For syntax errors in the replacement string,
      the value is the offset in the replacement string where the
      error was detected. For other errors, the value is
      PCRE2_UNSET by default. This includes the case of the output
      buffer being too small, unless
      PCRE2_SUBSTITUTE_OVERFLOW_LENGTH is set.</p>
      <p>PCRE2_SUBSTITUTE_OVERFLOW_LENGTH changes what happens when
      the output buffer is too small. The default action is to
      return PCRE2_ERROR_NOMEMORY immediately. If this option is
      set, however, <code class="function">pcre2_substitute</code>() continues to go through
      the motions of matching and substituting (without, of course,
      writing anything) in order to compute the size of buffer that
      is needed. This value is passed back via the <code class="function">outlengthptr</code> variable, with the result of
      the function still being PCRE2_ERROR_NOMEMORY.</p>
      <p>Passing a buffer size of zero is a permitted way of
      finding out how much memory is needed for given substitution.
      However, this does mean that the entire operation is carried
      out twice. Depending on the application, it may be more
      efficient to allocate a large buffer and free the excess
      afterwards, instead of using
      PCRE2_SUBSTITUTE_OVERFLOW_LENGTH.</p>
      <p>The replacement string, which is interpreted as a UTF
      string in UTF mode, is checked for UTF validity unless
      PCRE2_NO_UTF_CHECK is set. An invalid UTF replacement string
      causes an immediate return with the relevant UTF error
      code.</p>
      <p>If PCRE2_SUBSTITUTE_LITERAL is set, the replacement string
      is not interpreted in any way. By default, however, a dollar
      character is an escape character that can specify the
      insertion of characters from capture groups and names from
      (*MARK) or other control verbs in the pattern. The following
      forms are always recognized:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 $$                  insert a dollar character
 $&lt;n&gt; or ${&lt;n&gt;}      insert the contents of group &lt;n&gt;
 $*MARK or ${*MARK}  insert a control verb name
</pre>
      </div>
      <p>Either a group number or a group name can be given for
      &lt;n&gt;. Curly brackets are required only if the following
      character would be interpreted as part of the number or name.
      The number may be zero to include the entire matched string.
      For example, if the pattern a(b)c is matched with "=abc=" and
      the replacement string "+$1$0$1+", the result is
      "=+babcb+=".</p>
      <p>$*MARK inserts the name from the last encountered
      backtracking control verb on the matching path that has a
      name. (*MARK) must always include a name, but the other verbs
      need not. For example, in the case of (*MARK:A)(*PRUNE) the
      name inserted is "A", but for (*MARK:A)(*PRUNE:B) the
      relevant name is "B". This facility can be used to perform
      simple simultaneous substitutions, as this <code class="function">pcre2test</code> example shows:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 /(*MARK:pear)apple|(*MARK:orange)lemon/g,replace=${*MARK}
     apple lemon
  2: pear orange
</pre>
      </div>
      <p>PCRE2_SUBSTITUTE_GLOBAL causes the function to iterate
      over the subject string, replacing every matching substring.
      If this option is not set, only the first matching substring
      is replaced. The search for matches takes place in the
      original subject string (that is, previous replacements do
      not affect it). Iteration is implemented by advancing the
      <code class="function">startoffset</code> value for each
      search, which is always passed the entire subject string. If
      an offset limit is set in the match context, searching stops
      when that limit is reached.</p>
      <p>You can restrict the effect of a global substitution to a
      portion of the subject string by setting either or both of
      <code class="function">startoffset</code> and an offset
      limit. Here is a <code class="function">pcre2test</code>
      example:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 /B/g,replace=!,use_offset_limit
 ABC ABC ABC ABC\=offset=3,offset_limit=12
  2: ABC A!C A!C ABC
</pre>
      </div>
      <p>When continuing with global substitutions after matching a
      substring with zero length, an attempt to find a non-empty
      match at the same offset is performed. If this is not
      successful, the offset is advanced by one character except
      when CRLF is a valid newline sequence and the next two
      characters are CR, LF. In this case, the offset is advanced
      by two characters.</p>
      <p>PCRE2_SUBSTITUTE_UNKNOWN_UNSET causes references to
      capture groups that do not appear in the pattern to be
      treated as unset groups. This option should be used with
      care, because it means that a typo in a group name or number
      no longer causes the PCRE2_ERROR_NOSUBSTRING error.</p>
      <p>PCRE2_SUBSTITUTE_UNSET_EMPTY causes unset capture groups
      (including unknown groups when PCRE2_SUBSTITUTE_UNKNOWN_UNSET
      is set) to be treated as empty strings when inserted as
      described above. If this option is not set, an attempt to
      insert an unset group causes the PCRE2_ERROR_UNSET error.
      This option does not influence the extended substitution
      syntax described below.</p>
      <p>PCRE2_SUBSTITUTE_EXTENDED causes extra processing to be
      applied to the replacement string. Without this option, only
      the dollar character is special, and only the group insertion
      forms listed above are valid. When PCRE2_SUBSTITUTE_EXTENDED
      is set, two things change:</p>
      <p>Firstly, backslash in a replacement string is interpreted
      as an escape character. The usual forms such as \n or \x{ddd}
      can be used to specify particular character codes, and
      backslash followed by any non-alphanumeric character quotes
      that character. Extended quoting can be coded using \Q...\E,
      exactly as in pattern strings.</p>
      <p>There are also four escape sequences for forcing the case
      of inserted letters. The insertion mechanism has three
      states: no case forcing, force upper case, and force lower
      case. The escape sequences change the current state: \U and
      \L change to upper or lower case forcing, respectively, and
      \E (when not terminating a \Q quoted sequence) reverts to no
      case forcing. The sequences \u and \l force the next
      character (if it is a letter) to upper or lower case,
      respectively, and then the state automatically reverts to no
      case forcing. Case forcing applies to all inserted
      characters, including those from capture groups and letters
      within \Q...\E quoted sequences. If either PCRE2_UTF or
      PCRE2_UCP was set when the pattern was compiled, Unicode
      properties are used for case forcing characters whose code
      points are greater than 127.</p>
      <p>Note that case forcing sequences such as \U...\E do not
      nest. For example, the result of processing "\Uaa\LBB\Ecc\E"
      is "AAbbcc"; the final \E has no effect. Note also that the
      PCRE2_ALT_BSUX and PCRE2_EXTRA_ALT_BSUX options do not apply
      to replacement strings.</p>
      <p>The second effect of setting PCRE2_SUBSTITUTE_EXTENDED is
      to add more flexibility to capture group substitution. The
      syntax is similar to that used by Bash:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 ${&lt;n&gt;:-&lt;string&gt;}
 ${&lt;n&gt;:+&lt;string1&gt;:&lt;string2&gt;}
</pre>
      </div>
      <p>As before, &lt;n&gt; may be a group number or a name. The
      first form specifies a default value. If group &lt;n&gt; is
      set, its value is inserted; if not, &lt;string&gt; is
      expanded and the result inserted. The second form specifies
      strings that are expanded and inserted when group &lt;n&gt;
      is set or unset, respectively. The first form is just a
      convenient shorthand for</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
${&lt;n&gt;:+${&lt;n&gt;}:&lt;string&gt;}
</pre>
      </div>
      <p>Backslash can be used to escape colons and closing curly
      brackets in the replacement strings. A change of the case
      forcing state within a replacement string remains in force
      afterwards, as shown in this <code class="function">pcre2test</code> example:</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 /(some)?(body)/substitute_extended,replace=${1:+\U:\L}HeLLo
     body
  1: hello
     somebody
  1: HELLO
</pre>
      </div>
      <p>The PCRE2_SUBSTITUTE_UNSET_EMPTY option does not affect
      these extended substitutions. However,
      PCRE2_SUBSTITUTE_UNKNOWN_UNSET does cause unknown groups in
      the extended syntax forms to be treated as unset.</p>
      <p>If PCRE2_SUBSTITUTE_LITERAL is set,
      PCRE2_SUBSTITUTE_UNKNOWN_UNSET, PCRE2_SUBSTITUTE_UNSET_EMPTY,
      and PCRE2_SUBSTITUTE_EXTENDED are irrelevant and are
      ignored.</p>
      <div class="refsect2">
        <a id="pcre2api-3_sect48" name="pcre2api-3_sect48" shape="rect"> </a>
        <h3>Substitution errors</h3>
        <p>In the event of an error, <code class="function">pcre2_substitute</code>() returns a negative
        error code. Except for PCRE2_ERROR_NOMATCH (which is never
        returned), errors from <code class="function">pcre2_match</code>() are passed straight
        back.</p>
        <p>PCRE2_ERROR_NOSUBSTRING is returned for a non-existent
        substring insertion, unless PCRE2_SUBSTITUTE_UNKNOWN_UNSET
        is set.</p>
        <p>PCRE2_ERROR_UNSET is returned for an unset substring
        insertion (including an unknown substring when
        PCRE2_SUBSTITUTE_UNKNOWN_UNSET is set) when the simple
        (non-extended) syntax is used and
        PCRE2_SUBSTITUTE_UNSET_EMPTY is not set.</p>
        <p>PCRE2_ERROR_NOMEMORY is returned if the output buffer is
        not big enough. If the PCRE2_SUBSTITUTE_OVERFLOW_LENGTH
        option is set, the size of buffer that is needed is
        returned via <code class="function">outlengthptr</code>.
        Note that this does not happen by default.</p>
        <p>PCRE2_ERROR_NULL is returned if PCRE2_SUBSTITUTE_MATCHED
        is set but the <code class="function">match_data</code>
        argument is NULL.</p>
        <p>PCRE2_ERROR_BADREPLACEMENT is used for miscellaneous
        syntax errors in the replacement string, with more
        particular errors being PCRE2_ERROR_BADREPESCAPE (invalid
        escape sequence), PCRE2_ERROR_REPMISSINGBRACE (closing
        curly bracket not found), PCRE2_ERROR_BADSUBSTITUTION
        (syntax error in extended group substitution), and
        PCRE2_ERROR_BADSUBSPATTERN (the pattern match ended before
        it started or the match started earlier than the current
        position in the subject, which can happen if \K is used in
        an assertion).</p>
        <p>As for all PCRE2 errors, a text message that describes
        the error can be obtained by calling the <code class="function">pcre2_get_error_message</code>() function (see
        "Obtaining a textual error message" above).</p>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect49" name="pcre2api-3_sect49" shape="rect"> </a>
        <h3>Substitution callouts</h3>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_set_substitute_callout(pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  int (*<code class="function">callout_function</code>)(pcre2_substitute_callout_block *, void *),</em></span>
<span class="emphasis"><em>  void *<code class="function">callout_data</code>);</em></span>
</pre>
        </div>
        <p>The <code class="function">pcre2_set_substitution_callout</code>() function
        can be used to specify a callout function for <code class="function">pcre2_substitute</code>(). This information is
        passed in a match context. The callout function is called
        after each substitution has been processed, but it can
        cause the replacement not to happen. The callout function
        is not called for simulated substitutions that happen as a
        result of the PCRE2_SUBSTITUTE_OVERFLOW_LENGTH option.</p>
        <p>The first argument of the callout function is a pointer
        to a substitute callout block structure, which contains the
        following fields, not necessarily in this order:</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 uint32_t    <code class="function">version</code>;
 uint32_t    <code class="function">subscount</code>;
 PCRE2_SPTR  <code class="function">input</code>;
 PCRE2_SPTR  <code class="function">output</code>;
 PCRE2_SIZE <code class="function">*ovector</code>;
 uint32_t    <code class="function">oveccount</code>;
 PCRE2_SIZE  <em class="replaceable"><code>output_offsets[2]</code></em>;
</pre>
        </div>
        <p>The <code class="function">version</code> field contains
        the version number of the block format. The current version
        is 0. The version number will increase in future if more
        fields are added, but the intention is never to remove any
        of the existing fields.</p>
        <p>The <code class="function">subscount</code> field is the
        number of the current match. It is 1 for the first callout,
        2 for the second, and so on. The <code class="function">input</code> and <code class="function">output</code> pointers are copies of the values
        passed to <code class="function">pcre2_substitute</code>().</p>
        <p>The <code class="function">ovector</code> field points
        to the ovector, which contains the result of the most
        recent match. The <code class="function">oveccount</code>
        field contains the number of pairs that are set in the
        ovector, and is always greater than zero.</p>
        <p>The <code class="function">output_offsets</code> vector
        contains the offsets of the replacement in the output
        string. This has already been processed for dollar and (if
        requested) backslash substitutions as described above.</p>
        <p>The second argument of the callout function is the value
        passed as <code class="function">callout_data</code> when
        the function was registered. The value returned by the
        callout function is interpreted as follows:</p>
        <p>If the value is zero, the replacement is accepted, and,
        if PCRE2_SUBSTITUTE_GLOBAL is set, processing continues
        with a search for the next match. If the value is not zero,
        the current replacement is not accepted. If the value is
        greater than zero, processing continues when
        PCRE2_SUBSTITUTE_GLOBAL is set. Otherwise (the value is
        less than zero or PCRE2_SUBSTITUTE_GLOBAL is not set), the
        the rest of the input is copied to the output and the call
        to <code class="function">pcre2_substitute</code>() exits,
        returning the number of matches so far.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect50" name="pcre2api-3_sect50" shape="rect"> </a>
      <h2>DUPLICATE CAPTURE GROUP NAMES</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_substring_nametable_scan(const pcre2_code *<code class="function">code</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SPTR <code class="function">name</code>, PCRE2_SPTR *<code class="function">first</code>, PCRE2_SPTR *<code class="function">last</code>);</em></span>
</pre>
      </div>
      <p>When a pattern is compiled with the PCRE2_DUPNAMES option,
      names for capture groups are not required to be unique.
      Duplicate names are always allowed for groups with the same
      number, created by using the (?| feature. Indeed, if such
      groups are named, they are required to use the same
      names.</p>
      <p>Normally, patterns that use duplicate names are such that
      in any one match, only one of each set of identically-named
      groups participates. An example is shown in the <a class="link" href="../htmlman3/pcre2pattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2pattern</span>(3)</span></a>
      documentation.</p>
      <p>When duplicates are present, <code class="function">pcre2_substring_copy_byname</code>() and
      <code class="function">pcre2_substring_get_byname</code>()
      return the first substring corresponding to the given name
      that is set. Only if none are set is PCRE2_ERROR_UNSET is
      returned. The <code class="function">pcre2_substring_number_from_name</code>() function
      returns the error PCRE2_ERROR_NOUNIQUESUBSTRING when there
      are duplicate names.</p>
      <p>If you want to get full details of all captured substrings
      for a given name, you must use the <code class="function">pcre2_substring_nametable_scan</code>() function.
      The first argument is the compiled pattern, and the second is
      the name. If the third and fourth arguments are NULL, the
      function returns a group number for a unique name, or
      PCRE2_ERROR_NOUNIQUESUBSTRING otherwise.</p>
      <p>When the third and fourth arguments are not NULL, they
      must be pointers to variables that are updated by the
      function. After it has run, they point to the first and last
      entries in the name-to-number table for the given name, and
      the function returns the length of each entry in code units.
      In both cases, PCRE2_ERROR_NOSUBSTRING is returned if there
      are no entries for the given name.</p>
      <p>The format of the name table is described above in the
      section entitled <span class="emphasis"><em>Information about
      a pattern</em></span>. Given all the relevant entries for the
      name, you can extract each of their numbers, and hence the
      captured data.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect51" name="pcre2api-3_sect51" shape="rect"> </a>
      <h2>FINDING ALL POSSIBLE MATCHES AT ONE POSITION</h2>
      <p>The traditional matching function uses a similar algorithm
      to Perl, which stops when it finds the first match at a given
      point in the subject. If you want to find all possible
      matches, or the longest possible match at a given position,
      consider using the alternative matching function (see below)
      instead. If you cannot use the alternative function, you can
      kludge it up by making use of the callout facility, which is
      described in the <a class="link" href="../htmlman3/pcre2callout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2callout</span>(3)</span></a>
      documentation.</p>
      <p>What you have to do is to insert a callout right at the
      end of the pattern. When your callout function is called,
      extract and save the current matched substring. Then return
      1, which forces <code class="function">pcre2_match</code>()
      to backtrack and try other alternatives. Ultimately, when it
      runs out of matches, <code class="function">pcre2_match</code>() will yield
      PCRE2_ERROR_NOMATCH.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect52" name="pcre2api-3_sect52" shape="rect"> </a>
      <h2>MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
<span class="emphasis"><em>int pcre2_dfa_match(const pcre2_code *<code class="function">code</code>, PCRE2_SPTR <code class="function">subject</code>,</em></span>
<span class="emphasis"><em>  PCRE2_SIZE <code class="function">length</code>, PCRE2_SIZE <code class="function">startoffset</code>,</em></span>
<span class="emphasis"><em>  uint32_t <code class="function">options</code>, pcre2_match_data *<code class="function">match_data</code>,</em></span>
<span class="emphasis"><em>  pcre2_match_context *<code class="function">mcontext</code>,</em></span>
<span class="emphasis"><em>  int *<code class="function">workspace</code>, PCRE2_SIZE <code class="function">wscount</code>);</em></span>
</pre>
      </div>
      <p>The function <code class="function">pcre2_dfa_match</code>() is called to match a
      subject string against a compiled pattern, using a matching
      algorithm that scans the subject string just once (not
      counting lookaround assertions), and does not backtrack. This
      has different characteristics to the normal algorithm, and is
      not compatible with Perl. Some of the features of PCRE2
      patterns are not supported. Nevertheless, there are times
      when this kind of matching can be useful. For a discussion of
      the two matching algorithms, and a list of features that
      <code class="function">pcre2_dfa_match</code>() does not
      support, see the <a class="link" href="../htmlman3/pcre2matching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2matching</span>(3)</span></a>
      documentation.</p>
      <p>The arguments for the <code class="function">pcre2_dfa_match</code>() function are the same as
      for <code class="function">pcre2_match</code>(), plus two
      extras. The ovector within the match data block is used in a
      different way, and this is described below. The other common
      arguments are used in the same way as for <code class="function">pcre2_match</code>(), so their description is not
      repeated here.</p>
      <p>The two additional arguments provide workspace for the
      function. The workspace vector should contain at least 20
      elements. It is used for keeping track of multiple paths
      through the pattern tree. More workspace is needed for
      patterns and subjects where there are a lot of potential
      matches.</p>
      <p>Here is an example of a simple call to <code class="function">pcre2_dfa_match</code>():</p>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int wspace[20];
 pcre2_match_data *md = pcre2_match_data_create(4, NULL);
 int rc = pcre2_dfa_match(
   re,             /* result of pcre2_compile() */
   "some string",  /* the subject string */
   11,             /* the length of the subject string */
   0,              /* start at offset 0 in the subject */
   0,              /* default options */
   md,             /* the match data block */
   NULL,           /* a match context; NULL means use defaults */
   wspace,         /* working space vector */
   20);            /* number of elements (NOT size in bytes) */
</pre>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect53" name="pcre2api-3_sect53" shape="rect"> </a>
        <h3>Option bits for <code class="function">pcre_dfa_match</code>()</h3>
        <p>The unused bits of the <code class="function">options</code> argument for <code class="function">pcre2_dfa_match</code>() must be zero. The only
        bits that may be set are PCRE2_ANCHORED,
        PCRE2_COPY_MATCHED_SUBJECT, PCRE2_ENDANCHORED,
        PCRE2_NOTBOL, PCRE2_NOTEOL, PCRE2_NOTEMPTY,
        PCRE2_NOTEMPTY_ATSTART, PCRE2_NO_UTF_CHECK,
        PCRE2_PARTIAL_HARD, PCRE2_PARTIAL_SOFT, PCRE2_DFA_SHORTEST,
        and PCRE2_DFA_RESTART. All but the last four of these are
        exactly the same as for <code class="function">pcre2_match</code>(), so their description is
        not repeated here.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE2_PARTIAL_HARD
 PCRE2_PARTIAL_SOFT
</pre>
        </div>
        <p>These have the same general effect as they do for
        <code class="function">pcre2_match</code>(), but the
        details are slightly different. When PCRE2_PARTIAL_HARD is
        set for <code class="function">pcre2_dfa_match</code>(), it
        returns PCRE2_ERROR_PARTIAL if the end of the subject is
        reached and there is still at least one matching
        possibility that requires additional characters. This
        happens even if some complete matches have already been
        found. When PCRE2_PARTIAL_SOFT is set, the return code
        PCRE2_ERROR_NOMATCH is converted into PCRE2_ERROR_PARTIAL
        if the end of the subject is reached, there have been no
        complete matches, but there is still at least one matching
        possibility. The portion of the string that was inspected
        when the longest partial match was found is set as the
        first matching string in both cases. There is a more
        detailed discussion of partial and multi-segment matching,
        with examples, in the <a class="link" href="../htmlman3/pcre2partial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2partial</span>(3)</span></a>
        documentation.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_DFA_SHORTEST
</pre>
        </div>
        <p>Setting the PCRE2_DFA_SHORTEST option causes the
        matching algorithm to stop as soon as it has found one
        match. Because of the way the alternative algorithm works,
        this is necessarily the shortest possible match at the
        first possible matching point in the subject string.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_DFA_RESTART
</pre>
        </div>
        <p>When <code class="function">pcre2_dfa_match</code>()
        returns a partial match, it is possible to call it again,
        with additional subject characters, and have it continue
        with the same match. The PCRE2_DFA_RESTART option requests
        this action; when it is set, the <code class="function">workspace</code> and <code class="function">wscount</code> options must reference the same
        vector as before because data about the match so far is
        left in them after a partial match. There is more
        discussion of this facility in the <a class="link" href="../htmlman3/pcre2partial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2partial</span>(3)</span></a>
        documentation.</p>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect54" name="pcre2api-3_sect54" shape="rect"> </a>
        <h3>Successful returns from <code class="function">pcre2_dfa_match</code>()</h3>
        <p>When <code class="function">pcre2_dfa_match</code>()
        succeeds, it may have matched more than one substring in
        the subject. Note, however, that all the matches from one
        run of the function start at the same point in the subject.
        The shorter matches are all initial substrings of the
        longer matches. For example, if the pattern</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
&lt;.*&gt;
</pre>
        </div>
        <p>is matched against the string</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
This is &lt;something&gt; &lt;something else&gt; &lt;something further&gt; no more
</pre>
        </div>
        <p>the three matched strings are</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 &lt;something&gt; &lt;something else&gt; &lt;something further&gt;
 &lt;something&gt; &lt;something else&gt;
 &lt;something&gt;
</pre>
        </div>
        <p>On success, the yield of the function is a number
        greater than zero, which is the number of matched
        substrings. The offsets of the substrings are returned in
        the ovector, and can be extracted by number in the same way
        as for <code class="function">pcre2_match</code>(), but the
        numbers bear no relation to any capture groups that may
        exist in the pattern, because DFA matching does not support
        capturing.</p>
        <p>Calls to the convenience functions that extract
        substrings by name return the error PCRE2_ERROR_DFA_UFUNC
        (unsupported function) if used after a DFA match. The
        convenience functions that extract substrings by number
        never return PCRE2_ERROR_NOSUBSTRING.</p>
        <p>The matched strings are stored in the ovector in reverse
        order of length; that is, the longest matching string is
        first. If there were too many matches to fit into the
        ovector, the yield of the function is zero, and the vector
        is filled with the longest matches.</p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Note">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25" colspan="1"><img alt="[Note]" src="../stylesheet/note.png" /></td>
              <th align="left" rowspan="1" colspan="1">Note</th>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">
                <p>PCRE2's "auto-possessification" optimization
                usually applies to character repeats at the end of
                a pattern (as well as internally). For example, the
                pattern "a\d+" is compiled as if it were "a\d++".
                For DFA matching, this means that only one possible
                match is found. If you really do want multiple
                matches in such cases, either use an ungreedy
                repeat such as "a\d+?" or set the
                PCRE2_NO_AUTO_POSSESS option when compiling.</p>
              </td>
            </tr>
          </table>
        </div>
      </div>
      <div class="refsect2">
        <a id="pcre2api-3_sect55" name="pcre2api-3_sect55" shape="rect"> </a>
        <h3>Error returns from <code class="function">pcre2_dfa_match</code>()</h3>
        <p>The <code class="function">pcre2_dfa_match</code>()
        function returns a negative number when it fails. Many of
        the errors are the same as for <code class="function">pcre2_match</code>(), as described above. There
        are in addition the following errors that are specific to
        <code class="function">pcre2_dfa_match</code>():</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_DFA_UITEM
</pre>
        </div>
        <p>This return is given if <code class="function">pcre2_dfa_match</code>() encounters an item in
        the pattern that it does not support, for instance, the use
        of \C in a UTF mode or a backreference.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_DFA_UCOND
</pre>
        </div>
        <p>This return is given if <code class="function">pcre2_dfa_match</code>() encounters a condition
        item that uses a backreference for the condition, or a test
        for recursion in a specific capture group. These are not
        supported.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_DFA_UINVALID_UTF
</pre>
        </div>
        <p>This return is given if <code class="function">pcre2_dfa_match</code>() is called for a pattern
        that was compiled with PCRE2_MATCH_INVALID_UTF. This is not
        supported for DFA matching.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_DFA_WSSIZE
</pre>
        </div>
        <p>This return is given if <code class="function">pcre2_dfa_match</code>() runs out of space in
        the <code class="function">workspace</code> vector.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_DFA_RECURSE
</pre>
        </div>
        <p>When a recursion or subroutine call is processed, the
        matching function calls itself recursively, using private
        memory for the ovector and <code class="function">workspace</code>. This error is given if the
        internal ovector is not large enough. This should be
        extremely rare, as a vector of size 1000 is used.</p>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE2_ERROR_DFA_BADRESTART
</pre>
        </div>
        <p>When <code class="function">pcre2_dfa_match</code>() is
        called with the <code class="constant">PCRE2_DFA_RESTART</code> option, some
        plausibility checks are made on the contents of the
        workspace, which should contain data about the previous
        partial match. If any of these checks fail, this error is
        given.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect56" name="pcre2api-3_sect56" shape="rect"> </a>
      <h2>SEE ALSO</h2>
      <p><a class="link" href="../htmlman3/pcre2build.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2build</span>(3)</span></a>, <a class="link" href="../htmlman3/pcre2callout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2callout</span>(3)</span></a>, <em class="replaceable"><code>pcre2demo(3)</code></em>, <a class="link" href="../htmlman3/pcre2matching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2matching</span>(3)</span></a>, <a class="link" href="../htmlman3/pcre2partial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2partial</span>(3)</span></a>, <a class="link" href="../htmlman3/pcre2posix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2posix</span>(3)</span></a>, <a class="link" href="../htmlman3/pcre2sample.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2sample</span>(3)</span></a>, <a class="link" href="../htmlman3/pcre2unicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre2unicode</span>(3)</span></a>.</p>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect57" name="pcre2api-3_sect57" shape="rect"> </a>
      <h2>AUTHOR</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
Philip Hazel
University Computing Service
Cambridge, England.
</pre>
      </div>
    </div>
    <div class="refsect1">
      <a id="pcre2api-3_sect58" name="pcre2api-3_sect58" shape="rect"> </a>
      <h2>REVISION</h2>
      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
Last updated: 04 November 2020
Copyright (c) 1997-2020 University of Cambridge.
</pre>
      </div>
      <div class="license">
        <table class="license" style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>
          <thead>
            <tr>
              <th style="" rowspan="1" colspan="1">COPYRIGHT</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <p>This manual page is taken from the <a class="ulink" href="http://www.PCRE.org/" target="_top" shape="rect">PCRE library</a>, which is distributed under
                the BSD license.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>

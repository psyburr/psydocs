<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>fanotify(7) — Linux manual pages</title>
  <link rel="stylesheet" type="text/css" href="../stylesheet/manpages.css" />
  
  <link rel="home" href="../index.html" title="fanotify(7) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve"> </script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>
<body onload="javascript:init()">
  <div class="navheader">
    <table width="100%">
      <tbody>
        <tr>
          <td style="width: 33%" rowspan="1" colspan="1"><a href="../index.html" shape="rect">Linux
          manual pages</a></td>
          <th rowspan="1" colspan="1"><a href="../index7.html" shape="rect">Section 7</a></th>
          <td style="width: 33%" rowspan="1" colspan="1"> </td>
        </tr>
      </tbody>
    </table>
    <hr />
  </div>
  <div class="refentry">
    <a id="fanotify.7" name="fanotify.7" shape="rect"> </a>
    <div class="titlepage"> </div>
    <div class="refnamediv">
      <h2>Name</h2>
      <p>fanotify — monitoring filesystem events</p>
    </div>
    <div class="refsect1">
      <a id="fanotify-7_sect1" name="fanotify-7_sect1" shape="rect"> </a>
      <h2>DESCRIPTION</h2>
      <p>The fanotify API provides notification and interception of
      filesystem events. Use cases include virus scanning and
      hierarchical storage management. In the original fanotify
      API, only a limited set of events was supported. In
      particular, there was no support for create, delete, and move
      events. The support for those events was added in Linux 5.1.
      (See <a class="link" href="../htmlman7/inotify.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">inotify</span>(7)</span></a> for details of
      an API that did notify those events pre Linux 5.1.)</p>
      <p>Additional capabilities compared to the <a class="link" href="../htmlman7/inotify.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">inotify</span>(7)</span></a> API include the
      ability to monitor all of the objects in a mounted
      filesystem, the ability to make access permission decisions,
      and the possibility to read or modify files before access by
      other applications.</p>
      <p>The following system calls are used with this API:
      <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a>, <a class="link" href="../htmlman2/fanotify_mark.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_mark</span>(2)</span></a>, <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a>, <a class="link" href="../htmlman2/write.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">write</span>(2)</span></a>, and <a class="link" href="../htmlman2/close.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">close</span>(2)</span></a>.</p>
      <div class="refsect2">
        <a id="fanotify-7_sect2" name="fanotify-7_sect2" shape="rect"> </a>
        <h3>fanotify_init(), fanotify_mark(), and notification
        groups</h3>
        <p>The <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a> system
        call creates and initializes an fanotify notification group
        and returns a file descriptor referring to it.</p>
        <p>An fanotify notification group is a kernel-internal
        object that holds a list of files, directories,
        filesystems, and mount points for which events shall be
        created.</p>
        <p>For each entry in an fanotify notification group, two
        bit masks exist: the <em class="replaceable"><code>mark</code></em> mask and the
        <em class="replaceable"><code>ignore</code></em> mask. The
        mark mask defines file activities for which an event shall
        be created. The ignore mask defines activities for which no
        event shall be generated. Having these two types of masks
        permits a filesystem, mount point, or directory to be
        marked for receiving events, while at the same time
        ignoring events for specific objects under a mount point or
        directory.</p>
        <p>The <a class="link" href="../htmlman2/fanotify_mark.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_mark</span>(2)</span></a> system
        call adds a file, directory, filesystem, or mount point to
        a notification group and specifies which events shall be
        reported (or ignored), or removes or modifies such an
        entry.</p>
        <p>A possible usage of the ignore mask is for a file cache.
        Events of interest for a file cache are modification of a
        file and closing of the same. Hence, the cached directory
        or mount point is to be marked to receive these events.
        After receiving the first event informing that a file has
        been modified, the corresponding cache entry will be
        invalidated. No further modification events for this file
        are of interest until the file is closed. Hence, the modify
        event can be added to the ignore mask. Upon receiving the
        close event, the modify event can be removed from the
        ignore mask and the file cache entry can be updated.</p>
        <p>The entries in the fanotify notification groups refer to
        files and directories via their inode number and to mounts
        via their mount ID. If files or directories are renamed or
        moved within the same mount, the respective entries
        survive. If files or directories are deleted or moved to
        another mount or if filesystems or mounts are unmounted,
        the corresponding entries are deleted.</p>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect3" name="fanotify-7_sect3" shape="rect"> </a>
        <h3>The event queue</h3>
        <p>As events occur on the filesystem objects monitored by a
        notification group, the fanotify system generates events
        that are collected in a queue. These events can then be
        read (using <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> or similar) from
        the fanotify file descriptor returned by <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a>.</p>
        <p>Two types of events are generated: <em class="replaceable"><code>notification</code></em> events and
        <em class="replaceable"><code>permission</code></em>
        events. Notification events are merely informative and
        require no action to be taken by the receiving application
        with one exception: if a valid file descriptor is provided
        within a generic event, the file descriptor must be closed.
        Permission events are requests to the receiving application
        to decide whether permission for a file access shall be
        granted. For these events, the recipient must write a
        response which decides whether access is granted or
        not.</p>
        <p>An event is removed from the event queue of the fanotify
        group when it has been read. Permission events that have
        been read are kept in an internal list of the fanotify
        group until either a permission decision has been taken by
        writing to the fanotify file descriptor or the fanotify
        file descriptor is closed.</p>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect4" name="fanotify-7_sect4" shape="rect"> </a>
        <h3>Reading fanotify events</h3>
        <p>Calling <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> for the file
        descriptor returned by <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a> blocks
        (if the flag <code class="constant">FAN_NONBLOCK</code> is
        not specified in the call to <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a>) until
        either a file event occurs or the call is interrupted by a
        signal (see <a class="link" href="../htmlman7/signal.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">signal</span>(7)</span></a>).</p>
        <p>The use of one of the flags <code class="constant">FAN_REPORT_FID</code>, <code class="constant">FAN_REPORT_DIR_FID</code> in <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a>
        influences what data structures are returned to the event
        listener for each event. Events reported to a group
        initialized with one of these flags will use file handles
        to identify filesystem objects instead of file
        descriptors.</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term">After a successful</span></dt>
            <dd>
              <p><a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a>, the read
              buffer contains one or more of the following
              structures:</p>
            </dd>
          </dl>
        </div>
        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="structdef">
              <table class="structdef" style="border-collapse: collapse;">
                <colgroup span="1">
                  <col class="c1" span="1" />
                  <col class="c2" span="1" />
                  <col class="c3" span="1" />
                  <col class="c4" span="1" />
                  <col class="c5" span="1" />
                </colgroup>
                <tbody>
                  <tr>
                    <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">
                    struct</td>
                    <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">fanotify_event_metadata</span> {</td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__u32</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>event_len</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__u8</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>vers</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__u8</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>reserved</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__u16</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>metadata_len</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__aligned_u64</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>mask</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__s32</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>fd</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__s32</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>pid</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </blockquote>
        </div>
        <p>In case of an fanotify group that identifies filesystem
        objects by file handles, you should also expect to receive
        one or more additional information records of the structure
        detailed below following the generic <em class="replaceable"><code>fanotify_event_metadata</code></em>
        structure within the read buffer:</p>
        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="structdef">
              <table class="structdef" style="border-collapse: collapse;">
                <colgroup span="1">
                  <col class="c1" span="1" />
                  <col class="c2" span="1" />
                  <col class="c3" span="1" />
                  <col class="c4" span="1" />
                  <col class="c5" span="1" />
                </colgroup>
                <tbody>
                  <tr>
                    <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">
                    struct</td>
                    <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">fanotify_event_info_header</span> {</td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__u8</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>info_type</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__u8</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>pad</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__u16</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>len</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>
                  <tr>
                    <td class="structsep" style="" colspan="5" align="left" rowspan="1"></td>
                  </tr>
                  <tr>
                    <td class="structdefhdr2" style="" align="left" rowspan="1" colspan="1">struct</td>
                    <td class="structdefhdr2" style="" colspan="4" align="left" rowspan="1"><span class="structname">fanotify_event_info_fid</span> {</td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">struct fanotify_event_info_header</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>hdr</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__kernel_fsid_t</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>fsid</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">unsigned char</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>file_handle</code></em>[0];</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </blockquote>
        </div>
        <p>For performance reasons, it is recommended to use a
        large buffer size (for example, 4096 bytes), so that
        multiple events can be retrieved by a single <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a>.</p>
        <p>The return value of <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> is the number of
        bytes placed in the buffer, or −1 in case of an error
        (but see BUGS).</p>
        <p>The fields of the <em class="replaceable"><code>fanotify_event_metadata</code></em>
        structure are as follows:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><em class="parameter"><code>event_len</code></em></span></dt>
            <dd>
              <p>This is the length of the data for the current
              event and the offset to the next event in the buffer.
              Unless the group identifies filesystem objects by
              file handles, the value of <em class="parameter"><code>event_len</code></em> is always
              <code class="constant">FAN_EVENT_METADATA_LEN</code>.
              For a group that identifies filesystem objects by
              file handles, <em class="parameter"><code>event_len</code></em> also includes
              the variable length file identifier records.</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>vers</code></em></span></dt>
            <dd>
              <p>This field holds a version number for the
              structure. It must be compared to <code class="constant">FANOTIFY_METADATA_VERSION</code> to verify
              that the structures returned at run time match the
              structures defined at compile time. In case of a
              mismatch, the application should abandon trying to
              use the fanotify file descriptor.</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>reserved</code></em></span></dt>
            <dd>
              <p>This field is not used.</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>metadata_len</code></em></span></dt>
            <dd>
              <p>This is the length of the structure. The field was
              introduced to facilitate the implementation of
              optional headers per event type. No such optional
              headers exist in the current implementation.</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>mask</code></em></span></dt>
            <dd>
              <p>This is a bit mask describing the event (see
              below).</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt>
            <dd>
              <p>This is an open file descriptor for the object
              being accessed, or <code class="constant">FAN_NOFD</code> if a queue overflow
              occurred. With an fanotify group that identifies
              filesystem objects by file handles, applications
              should expect this value to be set to <code class="constant">FAN_NOFD</code> for each event that is
              received. The file descriptor can be used to access
              the contents of the monitored file or directory. The
              reading application is responsible for closing this
              file descriptor.</p>
              <p>When calling <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a>,
              the caller may specify (via the <em class="replaceable"><code>event_f_flags</code></em>
              argument) various file status flags that are to be
              set on the open file description that corresponds to
              this file descriptor. In addition, the
              (kernel-internal) <code class="constant">FMODE_NONOTIFY</code> file status flag is
              set on the open file description. This flag
              suppresses fanotify event generation. Hence, when the
              receiver of the fanotify event accesses the notified
              file or directory using this file descriptor, no
              additional events will be created.</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>pid</code></em></span></dt>
            <dd>
              <p>If flag <code class="constant">FAN_REPORT_TID</code> was set in <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a>,
              this is the TID of the thread that caused the event.
              Otherwise, this the PID of the process that caused
              the event.</p>
            </dd>
          </dl>
        </div>
        <p>A program listening to fanotify events can compare this
        PID to the PID returned by <a class="link" href="../htmlman2/getpid.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">getpid</span>(2)</span></a>, to determine
        whether the event is caused by the listener itself, or is
        due to a file access by another process.</p>
        <p>The bit mask in <em class="parameter"><code>mask</code></em> indicates which events
        have occurred for a single filesystem object. Multiple bits
        may be set in this mask, if more than one event occurred
        for the monitored filesystem object. In particular,
        consecutive events for the same filesystem object and
        originating from the same process may be merged into a
        single event, with the exception that two permission events
        are never merged into one queue entry.</p>
        <p>The bits that may appear in <em class="parameter"><code>mask</code></em> are as follows:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><code class="constant">FAN_ACCESS</code></span></dt>
            <dd>
              <p>A file or a directory (but see BUGS) was accessed
              (read).</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_OPEN</code></span></dt>
            <dd>
              <p>A file or a directory was opened.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_OPEN_EXEC</code></span></dt>
            <dd>
              <p>A file was opened with the intent to be executed.
              See NOTES in <a class="link" href="../htmlman2/fanotify_mark.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_mark</span>(2)</span></a>
              for additional details.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_ATTRIB</code></span></dt>
            <dd>
              <p>A file or directory metadata was changed.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_CREATE</code></span></dt>
            <dd>
              <p>A child file or directory was created in a watched
              parent.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_DELETE</code></span></dt>
            <dd>
              <p>A child file or directory was deleted in a watched
              parent.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_DELETE_SELF</code></span></dt>
            <dd>
              <p>A watched file or directory was deleted.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_MOVED_FROM</code></span></dt>
            <dd>
              <p>A file or directory has been moved from a watched
              parent directory.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_MOVED_TO</code></span></dt>
            <dd>
              <p>A file or directory has been moved to a watched
              parent directory.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_MOVE_SELF</code></span></dt>
            <dd>
              <p>A watched file or directory was moved.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_MODIFY</code></span></dt>
            <dd>
              <p>A file was modified.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_CLOSE_WRITE</code></span></dt>
            <dd>
              <p>A file that was opened for writing (<code class="constant">O_WRONLY</code> or <code class="constant">O_RDWR</code>) was closed.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_CLOSE_NOWRITE</code></span></dt>
            <dd>
              <p>A file or directory that was opened read-only
              (<code class="constant">O_RDONLY</code>) was
              closed.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_Q_OVERFLOW</code></span></dt>
            <dd>
              <p>The event queue exceeded the limit of 16384
              entries. This limit can be overridden by specifying
              the <code class="constant">FAN_UNLIMITED_QUEUE</code>
              flag when calling <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a>.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_ACCESS_PERM</code></span></dt>
            <dd>
              <p>An application wants to read a file or directory,
              for example using <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> or
              <a class="link" href="../htmlman2/readdir.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">readdir</span>(2)</span></a>. The
              reader must write a response (as described below)
              that determines whether the permission to access the
              filesystem object shall be granted.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_OPEN_PERM</code></span></dt>
            <dd>
              <p>An application wants to open a file or directory.
              The reader must write a response that determines
              whether the permission to open the filesystem object
              shall be granted.</p>
            </dd>
            <dt><span class="term"><code class="constant">FAN_OPEN_EXEC_PERM</code></span></dt>
            <dd>
              <p>An application wants to open a file for execution.
              The reader must write a response that determines
              whether the permission to open the filesystem object
              for execution shall be granted. See NOTES in
              <a class="link" href="../htmlman2/fanotify_mark.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_mark</span>(2)</span></a>
              for additional details.</p>
            </dd>
          </dl>
        </div>
        <p>To check for any close event, the following bit mask may
        be used:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><code class="constant">FAN_CLOSE</code></span></dt>
            <dd>
              <p>A file was closed. This is a synonym for:</p>
              <p>FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE</p>
            </dd>
          </dl>
        </div>
        <p>To check for any move event, the following bit mask may
        be used:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><code class="constant">FAN_MOVE</code></span></dt>
            <dd>
              <p>A file or directory was moved. This is a synonym
              for:</p>
              <p>FAN_MOVED_FROM | FAN_MOVED_TO</p>
            </dd>
          </dl>
        </div>
        <p>The following bits may appear in <em class="parameter"><code>mask</code></em> only in conjunction with
        other event type bits:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><code class="constant">FAN_ONDIR</code></span></dt>
            <dd>
              <p>The events described in the <em class="parameter"><code>mask</code></em> have occurred on a
              directory object. Reporting events on directories
              requires setting this flag in the mark mask. See
              <a class="link" href="../htmlman2/fanotify_mark.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_mark</span>(2)</span></a>
              for additional details. The <code class="constant">FAN_ONDIR</code> flag is reported in an
              event mask only if the fanotify group identifies
              filesystem objects by file handles.</p>
            </dd>
          </dl>
        </div>
        <p>The fields of the <em class="replaceable"><code>fanotify_event_info_fid</code></em>
        structure are as follows:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><em class="parameter"><code>hdr</code></em></span></dt>
            <dd>
              <p>This is a structure of type <em class="replaceable"><code>fanotify_event_info_header</code></em>.
              It is a generic header that contains information used
              to describe an additional information record attached
              to the event. For example, when an fanotify file
              descriptor is created using <code class="constant">FAN_REPORT_FID</code>, a single
              information record is expected to be attached to the
              event with <em class="parameter"><code>info_type</code></em> field value
              of <code class="constant">FAN_EVENT_INFO_TYPE_FID</code>. When an
              fanotify file descriptor is created using the
              combination of <code class="constant">FAN_REPORT_FID</code> and <code class="constant">FAN_REPORT_DIR_FID</code>, there may be
              two information records attached to the event: one
              with <em class="parameter"><code>info_type</code></em> field value
              of <code class="constant">FAN_EVENT_INFO_TYPE_DFID</code>,
              identifying a parent directory object, and one with
              <em class="parameter"><code>info_type</code></em>
              field value of <code class="constant">FAN_EVENT_INFO_TYPE_FID</code>,
              identifying a non-directory object. The <em class="replaceable"><code>fanotify_event_info_header</code></em>
              contains a <em class="parameter"><code>len</code></em> field. The value of
              <em class="parameter"><code>len</code></em> is the
              size of the additional information record including
              the <em class="replaceable"><code>fanotify_event_info_header</code></em>
              itself. The total size of all additional information
              records is not expected to be bigger than (
              <em class="parameter"><code>event_len</code></em>
              − <em class="parameter"><code>metadata_len</code></em> ).</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>fsid</code></em></span></dt>
            <dd>
              <p>This is a unique identifier of the filesystem
              containing the object associated with the event. It
              is a structure of type <em class="replaceable"><code>__kernel_fsid_t</code></em> and
              contains the same value as <em class="replaceable"><code>f_fsid</code></em> when calling
              <a class="link" href="../htmlman2/statfs.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">statfs</span>(2)</span></a>.</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>file_handle</code></em></span></dt>
            <dd>
              <p>This is a variable length structure of type struct
              file_handle. It is an opaque handle that corresponds
              to a specified object on a filesystem as returned by
              <a class="link" href="../htmlman2/open_by_handle_at.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">name_to_handle_at</span>(2)</span></a>.
              It can be used to uniquely identify a file on a
              filesystem and can be passed as an argument to
              <a class="link" href="../htmlman2/open_by_handle_at.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">open_by_handle_at</span>(2)</span></a>.
              Note that for the directory entry modification events
              <code class="constant">FAN_CREATE</code>,
              <code class="constant">FAN_DELETE</code>, and
              <code class="constant">FAN_MOVE</code>, the
              <em class="parameter"><code>file_handle</code></em>
              identifies the modified directory and not the
              created/deleted/moved child object. If the value of
              <em class="parameter"><code>info_type</code></em>
              field is <code class="constant">FAN_EVENT_INFO_TYPE_DFID_NAME</code>, the
              file handle is followed by a null terminated string
              that identifies the created/deleted/moved directory
              entry name. For other events such as <code class="constant">FAN_OPEN</code>, <code class="constant">FAN_ATTRIB</code>, <code class="constant">FAN_DELETE_SELF</code>, and <code class="constant">FAN_MOVE_SELF</code>, if the value of
              <em class="parameter"><code>info_type</code></em>
              field is <code class="constant">FAN_EVENT_INFO_TYPE_FID</code>, the
              <em class="parameter"><code>file_handle</code></em>
              identifies the object correlated to the event. If the
              value of <em class="parameter"><code>info_type</code></em> field is
              <code class="constant">FAN_EVENT_INFO_TYPE_DFID</code>, the
              <em class="parameter"><code>file_handle</code></em>
              identifies the directory object correlated to the
              event or the parent directory of a non-directory
              object correlated to the event. If the value of
              <em class="parameter"><code>info_type</code></em>
              field is <code class="constant">FAN_EVENT_INFO_TYPE_DFID_NAME</code>, the
              <em class="parameter"><code>file_handle</code></em>
              identifies the same directory object that would be
              reported with <code class="constant">FAN_EVENT_INFO_TYPE_DFID</code> and the
              file handle is followed by a null terminated string
              that identifies the name of a directory entry in that
              directory, or '.' to identify the directory object
              itself.</p>
            </dd>
          </dl>
        </div>
        <p>The following macros are provided to iterate over a
        buffer containing fanotify event metadata returned by a
        <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> from an fanotify
        file descriptor:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><span class="emphasis"><em>FAN_EVENT_OK(meta,
            len)</em></span></span></dt>
            <dd>
              <p>This macro checks the remaining length <em class="parameter"><code>len</code></em> of the buffer
              <em class="replaceable"><code>meta</code></em>
              against the length of the metadata structure and the
              <em class="parameter"><code>event_len</code></em>
              field of the first metadata structure in the
              buffer.</p>
            </dd>
            <dt><span class="term"><span class="emphasis"><em>FAN_EVENT_NEXT(meta,
            len)</em></span></span></dt>
            <dd>
              <p>This macro uses the length indicated in the
              <em class="parameter"><code>event_len</code></em>
              field of the metadata structure pointed to by
              <em class="replaceable"><code>meta</code></em> to
              calculate the address of the next metadata structure
              that follows <em class="replaceable"><code>meta</code></em>. <em class="parameter"><code>len</code></em> is the number of
              bytes of metadata that currently remain in the
              buffer. The macro returns a pointer to the next
              metadata structure that follows <em class="replaceable"><code>meta</code></em>, and reduces
              <em class="parameter"><code>len</code></em> by the
              number of bytes in the metadata structure that has
              been skipped over (i.e., it subtracts <em class="replaceable"><code>meta−&gt;event_len</code></em>
              from <em class="parameter"><code>len</code></em>).</p>
            </dd>
          </dl>
        </div>
        <p>In addition, there is:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><code class="constant">FAN_EVENT_METADATA_LEN</code></span></dt>
            <dd>
              <p>This macro returns the size (in bytes) of the
              structure <em class="replaceable"><code>fanotify_event_metadata</code></em>.
              This is the minimum size (and currently the only
              size) of any event metadata.</p>
            </dd>
          </dl>
        </div>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect5" name="fanotify-7_sect5" shape="rect"> </a>
        <h3>Monitoring an fanotify file descriptor for events</h3>
        <p>When an fanotify event occurs, the fanotify file
        descriptor indicates as readable when passed to <a class="link" href="../htmlman7/epoll.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">epoll</span>(7)</span></a>, <a class="link" href="../htmlman2/poll.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">poll</span>(2)</span></a>, or <a class="link" href="../htmlman2/select.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">select</span>(2)</span></a>.</p>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect6" name="fanotify-7_sect6" shape="rect"> </a>
        <h3>Dealing with permission events</h3>
        <p>For permission events, the application must <a class="link" href="../htmlman2/write.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">write</span>(2)</span></a> a structure of
        the following form to the fanotify file descriptor:</p>
        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="structdef">
              <table class="structdef" style="border-collapse: collapse;">
                <colgroup span="1">
                  <col class="c1" span="1" />
                  <col class="c2" span="1" />
                  <col class="c3" span="1" />
                  <col class="c4" span="1" />
                  <col class="c5" span="1" />
                </colgroup>
                <tbody>
                  <tr>
                    <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">
                    struct</td>
                    <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">fanotify_response</span> {</td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__s32</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>fd</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>
                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">__u32</span></td>
                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>
                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>response</code></em>;</td>
                    <td style="" align="left" rowspan="1" colspan="1"> </td>
                  </tr>
                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </blockquote>
        </div>
        <p>The fields of this structure are as follows:</p>
        <div class="variablelist">
          <dl class="variablelist">
            <dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt>
            <dd>
              <p>This is the file descriptor from the structure
              <em class="replaceable"><code>fanotify_event_metadata</code></em>.</p>
            </dd>
            <dt><span class="term"><em class="parameter"><code>response</code></em></span></dt>
            <dd>
              <p>This field indicates whether or not the permission
              is to be granted. Its value must be either
              <code class="constant">FAN_ALLOW</code> to allow the
              file operation or <code class="constant">FAN_DENY</code> to deny the file
              operation.</p>
            </dd>
          </dl>
        </div>
        <p>If access is denied, the requesting application call
        will receive an <span class="errorname">EPERM</span> error.
        Additionally, if the notification group has been created
        with the <code class="constant">FAN_ENABLE_AUDIT</code>
        flag, then the <code class="constant">FAN_AUDIT</code> flag
        can be set in the <em class="parameter"><code>response</code></em> field. In that case,
        the audit subsystem will log information about the access
        decision to the audit logs.</p>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect7" name="fanotify-7_sect7" shape="rect"> </a>
        <h3>Closing the fanotify file descriptor</h3>
        <p>When all file descriptors referring to the fanotify
        notification group are closed, the fanotify group is
        released and its resources are freed for reuse by the
        kernel. Upon <a class="link" href="../htmlman2/close.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">close</span>(2)</span></a>, outstanding
        permission events will be set to allowed.</p>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect8" name="fanotify-7_sect8" shape="rect"> </a>
        <h3>/proc/[pid]/fdinfo</h3>
        <p>The file <code class="filename">/proc/[pid]/fdinfo/[fd]</code> contains
        information about fanotify marks for file descriptor
        <em class="parameter"><code>fd</code></em> of process
        <em class="parameter"><code>pid</code></em>. See <a class="link" href="../htmlman5/proc.5.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">proc</span>(5)</span></a> for details.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="fanotify-7_sect9" name="fanotify-7_sect9" shape="rect"> </a>
      <h2>ERRORS</h2>
      <p>In addition to the usual errors for <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a>, the following
      errors can occur when reading from the fanotify file
      descriptor:</p>
      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><span class="errorname">EINVAL</span></span></dt>
          <dd>
            <p>The buffer is too small to hold the event.</p>
          </dd>
          <dt><span class="term"><span class="errorname">EMFILE</span></span></dt>
          <dd>
            <p>The per-process limit on the number of open files
            has been reached. See the description of <code class="constant">RLIMIT_NOFILE</code> in <a class="link" href="../htmlman2/getrlimit.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">getrlimit</span>(2)</span></a>.</p>
          </dd>
          <dt><span class="term"><span class="errorname">ENFILE</span></span></dt>
          <dd>
            <p>The system-wide limit on the total number of open
            files has been reached. See <code class="filename">/proc/sys/fs/file−max</code> in
            <a class="link" href="../htmlman5/proc.5.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">proc</span>(5)</span></a>.</p>
          </dd>
          <dt><span class="term"><span class="errorname">ETXTBSY</span></span></dt>
          <dd>
            <p>This error is returned by <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> if
            <code class="constant">O_RDWR</code> or <code class="constant">O_WRONLY</code> was specified in the
            <em class="replaceable"><code>event_f_flags</code></em>
            argument when calling <a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a> and
            an event occurred for a monitored file that is
            currently being executed.</p>
          </dd>
        </dl>
      </div>
      <p>In addition to the usual errors for <a class="link" href="../htmlman2/write.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">write</span>(2)</span></a>, the following
      errors can occur when writing to the fanotify file
      descriptor:</p>
      <div class="variablelist">
        <dl class="variablelist">
          <dt><span class="term"><span class="errorname">EINVAL</span></span></dt>
          <dd>
            <p>Fanotify access permissions are not enabled in the
            kernel configuration or the value of <em class="parameter"><code>response</code></em> in the response
            structure is not valid.</p>
          </dd>
          <dt><span class="term"><span class="errorname">ENOENT</span></span></dt>
          <dd>
            <p>The file descriptor <em class="parameter"><code>fd</code></em> in the response
            structure is not valid. This may occur when a response
            for the permission event has already been written.</p>
          </dd>
        </dl>
      </div>
    </div>
    <div class="refsect1">
      <a id="fanotify-7_sect10" name="fanotify-7_sect10" shape="rect"> </a>
      <h2>VERSIONS</h2>
      <p>The fanotify API was introduced in version 2.6.36 of the
      Linux kernel and enabled in version 2.6.37. Fdinfo support
      was added in version 3.8.</p>
    </div>
    <div class="refsect1">
      <a id="fanotify-7_sect11" name="fanotify-7_sect11" shape="rect"> </a>
      <h2>CONFORMING TO</h2>
      <p>The fanotify API is Linux-specific.</p>
    </div>
    <div class="refsect1">
      <a id="fanotify-7_sect12" name="fanotify-7_sect12" shape="rect"> </a>
      <h2>NOTES</h2>
      <p>The fanotify API is available only if the kernel was built
      with the <code class="constant">CONFIG_FANOTIFY</code>
      configuration option enabled. In addition, fanotify
      permission handling is available only if the <code class="constant">CONFIG_FANOTIFY_ACCESS_PERMISSIONS</code>
      configuration option is enabled.</p>
      <div class="refsect2">
        <a id="fanotify-7_sect13" name="fanotify-7_sect13" shape="rect"> </a>
        <h3>Limitations and caveats</h3>
        <p>Fanotify reports only events that a user-space program
        triggers through the filesystem API. As a result, it does
        not catch remote events that occur on network
        filesystems.</p>
        <p>The fanotify API does not report file accesses and
        modifications that may occur because of <a class="link" href="../htmlman2/mmap.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span></a>, <a class="link" href="../htmlman2/msync.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">msync</span>(2)</span></a>, and <a class="link" href="../htmlman2/mmap.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">munmap</span>(2)</span></a>.</p>
        <p>Events for directories are created only if the directory
        itself is opened, read, and closed. Adding, removing, or
        changing children of a marked directory does not create
        events for the monitored directory itself.</p>
        <p>Fanotify monitoring of directories is not recursive: to
        monitor subdirectories under a directory, additional marks
        must be created. The <code class="constant">FAN_CREATE</code> event can be used for
        detecting when a subdirectory has been created under a
        marked directory. An additional mark must then be set on
        the newly created subdirectory. This approach is racy,
        because it can lose events that occurred inside the newly
        created subdirectory, before a mark is added on that
        subdirectory. Monitoring mounts offers the capability to
        monitor a whole directory tree in a race-free manner.
        Monitoring filesystems offers the capability to monitor
        changes made from any mount of a filesystem instance in a
        race-free manner.</p>
        <p>The event queue can overflow. In this case, events are
        lost.</p>
      </div>
    </div>
    <div class="refsect1">
      <a id="fanotify-7_sect14" name="fanotify-7_sect14" shape="rect"> </a>
      <h2>BUGS</h2>
      <p>Before Linux 3.19, <a class="link" href="../htmlman2/fallocate.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fallocate</span>(2)</span></a> did not
      generate fanotify events. Since Linux 3.19, calls to
      <a class="link" href="../htmlman2/fallocate.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fallocate</span>(2)</span></a> generate
      <code class="constant">FAN_MODIFY</code> events.</p>
      <p>As of Linux 3.17, the following bugs exist:</p>
      <div class="itemizedlist">
        <ul class="itemizedlist" style="list-style-type: disc;">
          <li class="listitem">
            <p>On Linux, a filesystem object may be accessible
            through multiple paths, for example, a part of a
            filesystem may be remounted using the <code class="option">−−bind</code> option of <a class="link" href="../htmlman8/mount.8.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">mount</span>(8)</span></a>. A listener
            that marked a mount will be notified only of events
            that were triggered for a filesystem object using the
            same mount. Any other event will pass unnoticed.</p>
          </li>
          <li class="listitem">
            <p>When an event is generated, no check is made to see
            whether the user ID of the receiving process has
            authorization to read or write the file before passing
            a file descriptor for that file. This poses a security
            risk, when the <code class="constant">CAP_SYS_ADMIN</code> capability is set for
            programs executed by unprivileged users.</p>
          </li>
          <li class="listitem">
            <p>If a call to <a class="link" href="../htmlman2/read.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">read</span>(2)</span></a> processes
            multiple events from the fanotify queue and an error
            occurs, the return value will be the total length of
            the events successfully copied to the user-space buffer
            before the error occurred. The return value will not be
            −1, and <code class="varname">errno</code> will
            not be set. Thus, the reading application has no way to
            detect the error.</p>
          </li>
        </ul>
      </div>
    </div>
    <div class="refsect1">
      <a id="fanotify-7_sect15" name="fanotify-7_sect15" shape="rect"> </a>
      <h2>EXAMPLES</h2>
      <p>The two example programs below demonstrate the usage of
      the fanotify API.</p>
      <div class="refsect2">
        <a id="fanotify-7_sect16" name="fanotify-7_sect16" shape="rect"> </a>
        <h3>Example program: fanotify_example.c</h3>
        <p>The first program is an example of fanotify being used
        with its event object information passed in the form of a
        file descriptor. The program marks the mount point passed
        as a command-line argument and waits for events of type
        <code class="constant">FAN_OPEN_PERM</code> and
        <code class="constant">FAN_CLOSE_WRITE</code>. When a
        permission event occurs, a <code class="constant">FAN_ALLOW</code> response is given.</p>
        <p>The following shell session shows an example of running
        this program. This session involved editing the file
        <code class="filename">/home/user/temp/notes</code>. Before
        the file was opened, a <code class="constant">FAN_OPEN_PERM</code> event occurred. After the
        file was closed, a <code class="constant">FAN_CLOSE_WRITE</code> event occurred. Execution
        of the program ends when the user presses the ENTER
        key.</p>
        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
# <span class="emphasis"><em>./fanotify_example /home</em></span>
Press enter key to terminate.
Listening for events.
FAN_OPEN_PERM: File /home/user/temp/notes
FAN_CLOSE_WRITE: File /home/user/temp/notes

Listening for events stopped.
</pre>
            </div>
          </blockquote>
        </div>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect17" name="fanotify-7_sect17" shape="rect"> </a>
        <h3>Program source: fanotify_example.c</h3>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;poll.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/fanotify.h&gt;
#include &lt;unistd.h&gt;

/* Read all available fanotify events from the file descriptor 'fd'. */

static void
handle_events(int fd)
{
    const struct fanotify_event_metadata *metadata;
    struct fanotify_event_metadata buf[200];
    ssize_t len;
    char path[PATH_MAX];
    ssize_t path_len;
    char procfd_path[PATH_MAX];
    struct fanotify_response response;

    /* Loop while events can be read from fanotify file descriptor. */

    for (;;) {

        /* Read some events. */

        len = read(fd, buf, sizeof(buf));
        if (len == −1 &amp;&amp; errno != EAGAIN) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        /* Check if end of available data reached. */

        if (len &lt;= 0)
            break;

        /* Point to the first event in the buffer. */

        metadata = buf;

        /* Loop over all events in the buffer. */

        while (FAN_EVENT_OK(metadata, len)) {

            /* Check that run−time and compile−time structures match. */

            if (metadata−&gt;vers != FANOTIFY_METADATA_VERSION) {
                fprintf(stderr,
                        "Mismatch of fanotify metadata version.\n");
                exit(EXIT_FAILURE);
            }

            /* metadata−&gt;fd contains either FAN_NOFD, indicating a
               queue overflow, or a file descriptor (a nonnegative
               integer). Here, we simply ignore queue overflow. */

            if (metadata−&gt;fd &gt;= 0) {

                /* Handle open permission event. */

                if (metadata−&gt;mask &amp; FAN_OPEN_PERM) {
                    printf("FAN_OPEN_PERM: ");

                    /* Allow file to be opened. */

                    response.fd = metadata−&gt;fd;
                    response.response = FAN_ALLOW;
                    write(fd, &amp;response, sizeof(response));
                }

                /* Handle closing of writable file event. */

                if (metadata−&gt;mask &amp; FAN_CLOSE_WRITE)
                    printf("FAN_CLOSE_WRITE: ");

                /* Retrieve and print pathname of the accessed file. */

                snprintf(procfd_path, sizeof(procfd_path),
                         "/proc/self/fd/%d", metadata−&gt;fd);
                path_len = readlink(procfd_path, path,
                                    sizeof(path) − 1);
                if (path_len == −1) {
                    perror("readlink");
                    exit(EXIT_FAILURE);
                }

                path[path_len] = '\0';
                printf("File %s\n", path);

                /* Close the file descriptor of the event. */

                close(metadata−&gt;fd);
            }

            /* Advance to next event. */

            metadata = FAN_EVENT_NEXT(metadata, len);
        }
    }
}

int
main(int argc, char *argv[])
{
    char buf;
    int fd, poll_num;
    nfds_t nfds;
    struct pollfd fds[2];

    /* Check mount point is supplied. */

    if (argc != 2) {
        fprintf(stderr, "Usage: %s MOUNT\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    printf("Press enter key to terminate.\n");

    /* Create the file descriptor for accessing the fanotify API. */

    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,
                       O_RDONLY | O_LARGEFILE);
    if (fd == −1) {
        perror("fanotify_init");
        exit(EXIT_FAILURE);
    }

    /* Mark the mount for:
       − permission events before opening files
       − notification events after closing a write−enabled
         file descriptor. */

    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,
                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,
                      argv[1]) == −1) {
        perror("fanotify_mark");
        exit(EXIT_FAILURE);
    }

    /* Prepare for polling. */

    nfds = 2;

    fds[0].fd = STDIN_FILENO;       /* Console input */
    fds[0].events = POLLIN;

    fds[1].fd = fd;                 /* Fanotify input */
    fds[1].events = POLLIN;

    /* This is the loop to wait for incoming events. */

    printf("Listening for events.\n");

    while (1) {
        poll_num = poll(fds, nfds, −1);
        if (poll_num == −1) {
            if (errno == EINTR)     /* Interrupted by a signal */
                continue;           /* Restart poll() */

            perror("poll");         /* Unexpected error */
            exit(EXIT_FAILURE);
        }

        if (poll_num &gt; 0) {
            if (fds[0].revents &amp; POLLIN) {

                /* Console input is available: empty stdin and quit. */

                while (read(STDIN_FILENO, &amp;buf, 1) &gt; 0 &amp;&amp; buf != '\n')
                    continue;
                break;
            }

            if (fds[1].revents &amp; POLLIN) {

                /* Fanotify events are available. */

                handle_events(fd);
            }
        }
    }

    printf("Listening for events stopped.\n");
    exit(EXIT_SUCCESS);
}
</pre>
        </div>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect18" name="fanotify-7_sect18" shape="rect"> </a>
        <h3>Example program: fanotify_fid.c</h3>
        <p>The second program is an example of fanotify being used
        with a group that identifies objects by file handles. The
        program marks the filesystem object that is passed as a
        command-line argument and waits until an event of type
        <code class="constant">FAN_CREATE</code> has occurred. The
        event mask indicates which type of filesystem
        object—either a file or a directory—was
        created. Once all events have been read from the buffer and
        processed accordingly, the program simply terminates.</p>
        <p>The following shell sessions show two different
        invocations of this program, with different actions
        performed on a watched object.</p>
        <p>The first session shows a mark being placed on
        <code class="filename">/home/user</code>. This is followed
        by the creation of a regular file, <code class="filename">/home/user/testfile.txt</code>. This results in
        a <code class="constant">FAN_CREATE</code> event being
        generated and reported against the file's parent watched
        directory object and with the created file name. Program
        execution ends once all events captured within the buffer
        have been processed.</p>
        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
# <span class="emphasis"><em>./fanotify_fid /home/user</em></span>
Listening for events.
FAN_CREATE (file created):
        Directory /home/user has been modified.
        Entry 'testfile.txt' is not a subdirectory.
All events processed successfully. Program exiting.

$ <span class="emphasis"><em>touch /home/user/testfile.txt</em></span>              # In another terminal
</pre>
            </div>
          </blockquote>
        </div>
        <p>The second session shows a mark being placed on
        <code class="filename">/home/user</code>. This is followed
        by the creation of a directory, <code class="filename">/home/user/testdir</code>. This specific action
        results in a <code class="constant">FAN_CREATE</code> event
        being generated and is reported with the <code class="constant">FAN_ONDIR</code> flag set and with the created
        directory name.</p>
        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
# <span class="emphasis"><em>./fanotify_fid /home/user</em></span>
Listening for events.
FAN_CREATE | FAN_ONDIR (subdirectory created):
        Directory /home/user has been modified.
        Entry 'testdir' is a subdirectory.
All events processed successfully. Program exiting.

$ <span class="emphasis"><em>mkdir −p /home/user/testdir</em></span>          # In another terminal
</pre>
            </div>
          </blockquote>
        </div>
      </div>
      <div class="refsect2">
        <a id="fanotify-7_sect19" name="fanotify-7_sect19" shape="rect"> </a>
        <h3>Program source: fanotify_fid.c</h3>
        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
#define _GNU_SOURCE
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/fanotify.h&gt;
#include &lt;unistd.h&gt;

#define BUF_SIZE 256

int
main(int argc, char **argv)
{
    int fd, ret, event_fd, mount_fd;
    ssize_t len, path_len;
    char path[PATH_MAX];
    char procfd_path[PATH_MAX];
    char events_buf[BUF_SIZE];
    struct file_handle *file_handle;
    struct fanotify_event_metadata *metadata;
    struct fanotify_event_info_fid *fid;
    const char *file_name;
    struct stat sb;

    if (argc != 2) {
        fprintf(stderr, "Invalid number of command line arguments.\n");
        exit(EXIT_FAILURE);
    }

    mount_fd = open(argv[1], O_DIRECTORY | O_RDONLY);
    if (mount_fd == −1) {
        perror(argv[1]);
        exit(EXIT_FAILURE);
    }


    /* Create an fanotify file descriptor with FAN_REPORT_DFID_NAME as
       a flag so that program can receive fid events with directory
       entry name. */

    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_DFID_NAME, 0);
    if (fd == −1) {
        perror("fanotify_init");
        exit(EXIT_FAILURE);
    }

    /* Place a mark on the filesystem object supplied in argv[1]. */

    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,
                        FAN_CREATE | FAN_ONDIR,
                        AT_FDCWD, argv[1]);
    if (ret == −1) {
        perror("fanotify_mark");
        exit(EXIT_FAILURE);
    }

    printf("Listening for events.\n");

    /* Read events from the event queue into a buffer. */

    len = read(fd, events_buf, sizeof(events_buf));
    if (len == −1 &amp;&amp; errno != EAGAIN) {
        perror("read");
        exit(EXIT_FAILURE);
    }

    /* Process all events within the buffer. */

    for (metadata = (struct fanotify_event_metadata *) events_buf;
            FAN_EVENT_OK(metadata, len);
            metadata = FAN_EVENT_NEXT(metadata, len)) {
        fid = (struct fanotify_event_info_fid *) (metadata + 1);
        file_handle = (struct file_handle *) fid−&gt;handle;

        /* Ensure that the event info is of the correct type. */

        if (fid−&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_FID ||
            fid−&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_DFID) {
            file_name = NULL;
        } else if (fid−&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_DFID_NAME) {
            file_name = file_handle−&gt;f_handle +
                        file_handle−&gt;handle_bytes;
        } else {
            fprintf(stderr, "Received unexpected event info type.\n");
            exit(EXIT_FAILURE);
        }

        if (metadata−&gt;mask == FAN_CREATE)
            printf("FAN_CREATE (file created):\n");

        if (metadata−&gt;mask == (FAN_CREATE | FAN_ONDIR))
            printf("FAN_CREATE | FAN_ONDIR (subdirectory created):\n");

        /* metadata−&gt;fd is set to FAN_NOFD when the group identifies
           objects by file handles.  To obtain a file descriptor for
           the file object corresponding to an event you can use the
           struct file_handle that's provided within the
           fanotify_event_info_fid in conjunction with the
           open_by_handle_at(2) system call.  A check for ESTALE is
           done to accommodate for the situation where the file handle
           for the object was deleted prior to this system call. */

        event_fd = open_by_handle_at(mount_fd, file_handle, O_RDONLY);
        if (event_fd == −1) {
            if (errno == ESTALE) {
                printf("File handle is no longer valid. "
                        "File has been deleted\n");
                continue;
            } else {
                perror("open_by_handle_at");
                exit(EXIT_FAILURE);
            }
        }

        snprintf(procfd_path, sizeof(procfd_path), "/proc/self/fd/%d",
                event_fd);

        /* Retrieve and print the path of the modified dentry. */

        path_len = readlink(procfd_path, path, sizeof(path) − 1);
        if (path_len == −1) {
            perror("readlink");
            exit(EXIT_FAILURE);
        }

        path[path_len] = '\0';
        printf("\tDirectory '%s' has been modified.\n", path);

        if (file_name) {
            ret = fstatat(event_fd, file_name, &amp;sb, 0);
            if (ret == −1) {
                if (errno != ENOENT) {
                    perror("fstatat");
                    exit(EXIT_FAILURE);
                }
                printf("\tEntry '%s' does not exist.\n", file_name);
            } else if ((sb.st_mode &amp; S_IFMT) == S_IFDIR) {
                printf("\tEntry '%s' is a subdirectory.\n", file_name);
            } else {
                printf("\tEntry '%s' is not a subdirectory.\n",
                        file_name);
            }
        }

        /* Close associated file descriptor for this event. */

        close(event_fd);
    }

    printf("All events processed successfully. Program exiting.\n");
    exit(EXIT_SUCCESS);
}
</pre>
        </div>
      </div>
    </div>
    <div class="refsect1">
      <a id="fanotify-7_sect20" name="fanotify-7_sect20" shape="rect"> </a>
      <h2>SEE ALSO</h2>
      <p><a class="link" href="../htmlman2/fanotify_init.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_init</span>(2)</span></a>, <a class="link" href="../htmlman2/fanotify_mark.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">fanotify_mark</span>(2)</span></a>, <a class="link" href="../htmlman7/inotify.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">inotify</span>(7)</span></a></p>
    </div>
    <div class="colophon">
      <a id="fanotify-7_sect21" name="fanotify-7_sect21" shape="rect"> </a>
      <h2>COLOPHON</h2>
      <p>This page is part of release 5.11 of the Linux <em class="replaceable"><code>man-pages</code></em> project. A
      description of the project, information about reporting bugs,
      and the latest version of this page, can be found at
      https://www.kernel.org/doc/man−pages/.</p>
      <div class="license">
        <table class="license" style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>
          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <div class="literallayout">
                  <br />
                    Copyright (C) 2013, Heinrich Schuchardt &lt;xypron.glpk<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>gmx.de&gt;<br />

                  and Copyright (C) 2014, Michael Kerrisk &lt;mtk.manpages<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>gmail.com&gt;<br />

                  <br />
                  %%%LICENSE_START(VERBATIM)<br />
                  Permission is granted to make and distribute verbatim copies of this<br />

                  manual provided the copyright notice and this permission notice are<br />

                  preserved on all copies.<br />
                  <br />
                  Permission is granted to copy and distribute modified versions of<br />

                  this manual under the conditions for verbatim copying, provided that<br />

                  the entire resulting derived work is distributed under the terms of<br />

                  a permission notice identical to this one.<br />

                  <br />
                  Since the Linux kernel and libraries are constantly changing, this<br />

                  manual page may be incorrect or out-of-date.  The author(s) assume.<br />

                  no responsibility for errors or omissions, or for damages resulting.<br />

                  from the use of the information contained herein.  The author(s) may.<br />

                  not have taken the same level of care in the production of this.<br />

                  manual, which is licensed free of charge, as they might when working.<br />

                  professionally.<br />
                  <br />
                  Formatted or processed versions of this manual, if unaccompanied by<br />

                  the source, must acknowledge the copyright and authors of this work.<br />

                  %%%LICENSE_END<br />
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>

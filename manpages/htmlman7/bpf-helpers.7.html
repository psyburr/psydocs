<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>bpf-helpers(7) — Linux manual pages</title>
  <link rel="stylesheet" type="text/css" href="../stylesheet/manpages.css" />
  
  <link rel="home" href="../index.html" title="bpf-helpers(7) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve"> </script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>
<body onload="javascript:init()">
  <div class="navheader">
    <table width="100%">
      <tbody>
        <tr>
          <td style="width: 33%" rowspan="1" colspan="1"><a href="../index.html" shape="rect">Linux
          manual pages</a></td>
          <th rowspan="1" colspan="1"><a href="../index7.html" shape="rect">Section 7</a></th>
          <td style="width: 33%" rowspan="1" colspan="1"> </td>
        </tr>
      </tbody>
    </table>
    <hr />
  </div>
  <div class="refentry">
    <a id="bpf-helpers.7" name="bpf-helpers.7" shape="rect"> </a>
    <div class="titlepage"> </div>
    <div class="refnamediv">
      <h2>Name</h2>
      <p>BPF-HELPERS — list of eBPF helper functions</p>
    </div>
    <div class="refsect1">
      <a id="bpf-helpers-7_sect1" name="bpf-helpers-7_sect1" shape="rect"> </a>
      <h2>DESCRIPTION</h2>
      <p>The extended Berkeley Packet Filter (eBPF) subsystem
      consists in programs written in a pseudo−assembly
      language, then attached to one of the several kernel hooks
      and run in reaction of specific events. This framework
      differs from the older, "classic" BPF (or "cBPF") in several
      aspects, one of them being the ability to call special
      functions (or "helpers") from within a program. These
      functions are restricted to a white−list of helpers
      defined in the kernel.</p>
      <p>These helpers are used by eBPF programs to interact with
      the system, or with the context in which they work. For
      instance, they can be used to print debugging messages, to
      get the time since the system was booted, to interact with
      eBPF maps, or to manipulate network packets. Since there are
      several eBPF program types, and that they do not run in the
      same context, each program type can only call a subset of
      those helpers.</p>
      <p>Due to eBPF conventions, a helper can not have more than
      five arguments.</p>
      <p>Internally, eBPF programs call directly into the compiled
      helper functions without requiring any foreign−function
      interface. As a result, calling helpers introduces no
      overhead, thus offering excellent performance.</p>
      <p>This document is an attempt to list and document the
      helpers available to eBPF developers. They are sorted by
      chronological order (the oldest helpers in the kernel at the
      top).</p>
    </div>
    <div class="refsect1">
      <a id="bpf-helpers-7_sect2" name="bpf-helpers-7_sect2" shape="rect"> </a>
      <h2>HELPERS</h2>
      <div class="blockquote">
        <blockquote class="blockquote">
          <div class="variablelist">
            <dl class="variablelist">
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>void
              *bpf_map_lookup_elem(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>key</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Perform a lookup in <em class="replaceable"><code>map</code></em> for
                          an entry associated to <em class="replaceable"><code>key</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Map value associated to <em class="replaceable"><code>key</code></em>, or
                          <code class="constant">NULL</code> if no
                          entry was found.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_map_update_elem(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>key</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>value</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Add or update the value of the entry
                          associated to <em class="replaceable"><code>key</code></em> in
                          <em class="replaceable"><code>map</code></em> with
                          <em class="replaceable"><code>value</code></em>.
                          <em class="replaceable"><code>flags</code></em> is
                          one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_NOEXIST</code></span></dt>
                                  <dd>
                                    <p>The entry for <em class="replaceable"><code>key</code></em>
                                    must not exist in the map.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_EXIST</code></span></dt>
                                  <dd>
                                    <p>The entry for <em class="replaceable"><code>key</code></em>
                                    must already exist in the
                                    map.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_ANY</code></span></dt>
                                  <dd>
                                    <p>No condition on the
                                    existence of the entry for
                                    <em class="replaceable"><code>key</code></em>.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>Flag value <code class="constant">BPF_NOEXIST</code> cannot be
                          used for maps of types <code class="constant">BPF_MAP_TYPE_ARRAY</code> or
                          <code class="constant">BPF_MAP_TYPE_PERCPU_ARRAY</code>
                          (all elements always exist), the helper
                          would return an error.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_map_delete_elem(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>key</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Delete entry with <em class="replaceable"><code>key</code></em> from
                          <em class="replaceable"><code>map</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_probe_read(void *</em></span><em class="replaceable"><code>dst</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>unsafe_ptr</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>For tracing programs, safely attempt
                          to read <em class="replaceable"><code>size</code></em>
                          bytes from kernel space address
                          <em class="replaceable"><code>unsafe_ptr</code></em>
                          and store the data in <em class="replaceable"><code>dst</code></em>.</p>
                          <p>Generally, use <code class="function">bpf_probe_read_user</code>()
                          or <code class="function">bpf_probe_read_kernel</code>()
                          instead.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_ktime_get_ns(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return the time elapsed since system
                          boot, in nanoseconds. Does not include
                          time the system was suspended. See:
                          <code class="function">clock_gettime</code>(<code class="constant">CLOCK_MONOTONIC</code>)</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Current <em class="replaceable"><code>ktime</code></em>.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_trace_printk(const char *</em></span><em class="replaceable"><code>fmt</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>fmt_size</code></em><span class="emphasis"><em>,
              ...)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper is a "printk()−like"
                          facility for debugging. It prints a
                          message defined by format <em class="replaceable"><code>fmt</code></em> (of
                          size <em class="replaceable"><code>fmt_size</code></em>)
                          to file <code class="filename">/sys/kernel/debug/tracing/trace</code>
                          from DebugFS, if available. It can take
                          up to three additional <em class="replaceable"><code>u64</code></em>
                          arguments (as an eBPF helpers, the total
                          number of arguments is limited to
                          five).</p>
                          <p>Each time the helper is called, it
                          appends a line to the trace. Lines are
                          discarded while <code class="filename">/sys/kernel/debug/tracing/trace</code>
                          is open, use <code class="filename">/sys/kernel/debug/tracing/trace_pipe</code>
                          to avoid this. The format of the trace is
                          customizable, and the exact output one
                          will get depends on the options set in
                          <code class="filename">/sys/kernel/debug/tracing/trace_options</code>
                          (see also the <code class="constant">README</code> file under the
                          same directory). However, it usually
                          defaults to something like:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="informalexample">
                                    <pre class="programlisting" xml:space="preserve">
telnet−470   [001] .N.. 419421.045894: 0x00000001: &lt;formatted msg&gt;
</pre>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                          <p>In the above:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="blockquote">
                                    <blockquote class="blockquote">
                                      <div class="itemizedlist">
                                        <ul class="itemizedlist" style="list-style-type: disc;">
                                          <li class="listitem">
                                            <p><em class="replaceable"><code>telnet</code></em>
                                            is the name of the
                                            current task.</p>
                                          </li>
                                          <li class="listitem">
                                            <p><code class="constant">470</code>
                                            is the PID of the
                                            current task.</p>
                                          </li>
                                          <li class="listitem">
                                            <p><code class="constant">001</code>
                                            is the CPU number on
                                            which the task is
                                            running.</p>
                                          </li>
                                          <li class="listitem">
                                            <p>In <em class="replaceable"><code>.N..</code></em>,
                                            each character refers
                                            to a set of options
                                            (whether irqs are
                                            enabled, scheduling
                                            options, whether
                                            hard/softirqs are
                                            running, level of
                                            preempt_disabled
                                            respectively).
                                            <code class="constant">N</code>
                                            means that <code class="constant">TIF_NEED_RESCHED</code>
                                            and <code class="constant">PREEMPT_NEED_RESCHED</code>
                                            are set.</p>
                                          </li>
                                          <li class="listitem">
                                            <p><em class="replaceable"><code>419421.045894</code></em>
                                            is a timestamp.</p>
                                          </li>
                                          <li class="listitem">
                                            <p><em class="replaceable"><code>0x00000001</code></em>
                                            is a fake value used by
                                            BPF for the instruction
                                            pointer register.</p>
                                          </li>
                                          <li class="listitem">
                                            <p><span class="emphasis"><em>&lt;formatted
                                            msg&gt;</em></span> is
                                            the message formatted
                                            with <em class="replaceable"><code>fmt</code></em>.</p>
                                          </li>
                                        </ul>
                                      </div>
                                    </blockquote>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                          <p>The conversion specifiers supported by
                          <em class="replaceable"><code>fmt</code></em> are
                          similar, but more limited than for
                          printk(). They are <em class="replaceable"><code>%d</code></em>,
                          <em class="replaceable"><code>%i</code></em>,
                          <em class="replaceable"><code>%u</code></em>,
                          <em class="replaceable"><code>%x</code></em>,
                          <em class="replaceable"><code>%ld</code></em>,
                          <em class="replaceable"><code>%li</code></em>,
                          <em class="replaceable"><code>%lu</code></em>,
                          <em class="replaceable"><code>%lx</code></em>,
                          <em class="replaceable"><code>%lld</code></em>,
                          <em class="replaceable"><code>%lli</code></em>,
                          <em class="replaceable"><code>%llu</code></em>,
                          <em class="replaceable"><code>%llx</code></em>,
                          <em class="replaceable"><code>%p</code></em>,
                          <em class="replaceable"><code>%s</code></em>. No
                          modifier (size of field, padding with
                          zeroes, etc.) is available, and the
                          helper will return <code class="option">−EINVAL</code> (but print
                          nothing) if it encounters an unknown
                          specifier.</p>
                          <p>Also, note that <code class="function">bpf_trace_printk</code>() is
                          slow, and should only be used for
                          debugging purposes. For this reason, a
                          notice block (spanning several lines) is
                          printed to kernel logs and states that
                          the helper should not be used "for
                          production use" the first time this
                          helper is used (or more precisely, when
                          <code class="function">trace_printk</code>() buffers
                          are allocated). For passing values to
                          user space, perf events should be
                          preferred.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The number of bytes written to the
                          buffer, or a negative error in case of
                          failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u32
              bpf_get_prandom_u32(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get a pseudo−random number.</p>
                          <p>From a security point of view, this
                          helper uses its own pseudo−random
                          internal state, and cannot be used to
                          infer the seed of other random functions
                          in the kernel. However, it is essential
                          to note that the generator used by the
                          helper is not cryptographically
                          secure.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A random 32−bit unsigned
                          value.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u32
              bpf_get_smp_processor_id(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get the SMP (symmetric
                          multiprocessing) processor id. Note that
                          all programs run with preemption
                          disabled, which means that the SMP
                          processor id is stable during all the
                          execution of the program.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The SMP id of the processor running
                          the program.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_store_bytes(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>offset</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>from</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Store <em class="replaceable"><code>len</code></em> bytes
                          from address <em class="replaceable"><code>from</code></em> into
                          the packet associated to <em class="replaceable"><code>skb</code></em>, at
                          <em class="replaceable"><code>offset</code></em>.
                          <em class="replaceable"><code>flags</code></em> are
                          a combination of <code class="constant">BPF_F_RECOMPUTE_CSUM</code>
                          (automatically recompute the checksum for
                          the packet after storing the bytes) and
                          <code class="constant">BPF_F_INVALIDATE_HASH</code>
                          (set <em class="replaceable"><code>skb</code></em><code class="option">−&gt;hash</code>,
                          <em class="replaceable"><code>skb</code></em><code class="option">−&gt;swhash</code>
                          and <em class="replaceable"><code>skb</code></em><code class="option">−&gt;l4hash</code>
                          to 0).</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_l3_csum_replace(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>offset</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>from</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>to</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Recompute the layer 3 (e.g. IP)
                          checksum for the packet associated to
                          <em class="replaceable"><code>skb</code></em>.
                          Computation is incremental, so the helper
                          must know the former value of the header
                          field that was modified (<em class="replaceable"><code>from</code></em>),
                          the new value of this field (<em class="replaceable"><code>to</code></em>), and
                          the number of bytes (2 or 4) for this
                          field, stored in <em class="replaceable"><code>size</code></em>.
                          Alternatively, it is possible to store
                          the difference between the previous and
                          the new values of the header field in
                          <em class="replaceable"><code>to</code></em>, by
                          setting <em class="replaceable"><code>from</code></em> and
                          <em class="replaceable"><code>size</code></em> to
                          0. For both methods, <em class="replaceable"><code>offset</code></em>
                          indicates the location of the IP checksum
                          within the packet.</p>
                          <p>This helper works in combination with
                          <code class="function">bpf_csum_diff</code>(), which
                          does not update the checksum
                          in−place, but offers more
                          flexibility and can handle sizes larger
                          than 2 or 4 for the checksum to
                          update.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_l4_csum_replace(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>offset</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>from</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>to</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Recompute the layer 4 (e.g. TCP, UDP,
                          or ICMP) checksum for the packet
                          associated to <em class="replaceable"><code>skb</code></em>.
                          Computation is incremental, so the helper
                          must know the former value of the header
                          field that was modified (<em class="replaceable"><code>from</code></em>),
                          the new value of this field (<em class="replaceable"><code>to</code></em>), and
                          the number of bytes (2 or 4) for this
                          field, stored on the lowest four bits of
                          <em class="replaceable"><code>flags</code></em>.
                          Alternatively, it is possible to store
                          the difference between the previous and
                          the new values of the header field in
                          <em class="replaceable"><code>to</code></em>, by
                          setting <em class="replaceable"><code>from</code></em> and
                          the four lowest bits of <em class="replaceable"><code>flags</code></em> to
                          0. For both methods, <em class="replaceable"><code>offset</code></em>
                          indicates the location of the IP checksum
                          within the packet. In addition to the
                          size of the field, <em class="replaceable"><code>flags</code></em> can
                          be added (bitwise OR) actual flags. With
                          <code class="constant">BPF_F_MARK_MANGLED_0</code>, a
                          null checksum is left untouched (unless
                          <code class="constant">BPF_F_MARK_ENFORCE</code> is
                          added as well), and for updates resulting
                          in a null checksum the value is set to
                          <code class="constant">CSUM_MANGLED_0</code> instead.
                          Flag <code class="constant">BPF_F_PSEUDO_HDR</code>
                          indicates the checksum is to be computed
                          against a pseudo−header.</p>
                          <p>This helper works in combination with
                          <code class="function">bpf_csum_diff</code>(), which
                          does not update the checksum
                          in−place, but offers more
                          flexibility and can handle sizes larger
                          than 2 or 4 for the checksum to
                          update.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_tail_call(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>prog_array_map</code></em><span class="emphasis"><em>,
              u32</em></span> <em class="replaceable"><code>index</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This special helper is used to trigger
                          a "tail call", or in other words, to jump
                          into another eBPF program. The same stack
                          frame is used (but values on stack and in
                          registers for the caller are not
                          accessible to the callee). This mechanism
                          allows for program chaining, either for
                          raising the maximum number of available
                          eBPF instructions, or to execute given
                          programs in conditional blocks. For
                          security reasons, there is an upper limit
                          to the number of successive tail calls
                          that can be performed.</p>
                          <p>Upon call of this helper, the program
                          attempts to jump into a program
                          referenced at index <em class="replaceable"><code>index</code></em> in
                          <em class="replaceable"><code>prog_array_map</code></em>,
                          a special map of type <code class="constant">BPF_MAP_TYPE_PROG_ARRAY</code>,
                          and passes <em class="replaceable"><code>ctx</code></em>, a
                          pointer to the context.</p>
                          <p>If the call succeeds, the kernel
                          immediately runs the first instruction of
                          the new program. This is not a function
                          call, and it never returns to the
                          previous program. If the call fails, then
                          the helper has no effect, and the caller
                          continues to run its subsequent
                          instructions. A call can fail if the
                          destination program for the jump does not
                          exist (i.e. <em class="replaceable"><code>index</code></em> is
                          superior to the number of entries in
                          <em class="replaceable"><code>prog_array_map</code></em>),
                          or if the maximum number of tail calls
                          has been reached for this chain of
                          programs. This limit is defined in the
                          kernel by the macro <code class="constant">MAX_TAIL_CALL_CNT</code> (not
                          accessible to user space), which is
                          currently set to 32.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_clone_redirect(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>ifindex</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Clone and redirect the packet
                          associated to <em class="replaceable"><code>skb</code></em> to
                          another net device of index <em class="replaceable"><code>ifindex</code></em>.
                          Both ingress and egress interfaces can be
                          used for redirection. The <code class="constant">BPF_F_INGRESS</code> value in
                          <em class="replaceable"><code>flags</code></em> is
                          used to make the distinction (ingress
                          path is selected if the flag is present,
                          egress path otherwise). This is the only
                          flag supported for now.</p>
                          <p>In comparison with <code class="function">bpf_redirect</code>() helper,
                          <code class="function">bpf_clone_redirect</code>()
                          has the associated cost of duplicating
                          the packet buffer, but this can be
                          executed out of the eBPF program.
                          Conversely, <code class="function">bpf_redirect</code>() is more
                          efficient, but it is handled through an
                          action code where the redirection happens
                          only after the eBPF program has
                          returned.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_current_pid_tgid(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A 64−bit integer containing the
                          current tgid and pid, and created as
                          such: <em class="replaceable"><code>current_task</code></em><code class="option">−&gt;tgid
                          &lt;&lt; 32 |</code> <em class="replaceable"><code>current_task</code></em><code class="option">−&gt;pid</code>.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_current_uid_gid(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A 64−bit integer containing the
                          current GID and UID, and created as such:
                          <em class="replaceable"><code>current_gid</code></em>
                          <span class="emphasis"><em>&lt;&lt; 32
                          |</em></span> <em class="replaceable"><code>current_uid</code></em>.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_get_current_comm(void *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size_of_buf</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Copy the <em class="replaceable"><code>comm</code></em>
                          attribute of the current task into
                          <em class="replaceable"><code>buf</code></em> of
                          <em class="replaceable"><code>size_of_buf</code></em>.
                          The <em class="replaceable"><code>comm</code></em>
                          attribute contains the name of the
                          executable (excluding the path) for the
                          current task. The <em class="replaceable"><code>size_of_buf</code></em>
                          must be strictly positive. On success,
                          the helper makes sure that the <em class="replaceable"><code>buf</code></em> is
                          NUL−terminated. On failure, it is
                          filled with zeroes.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u32
              bpf_get_cgroup_classid(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Retrieve the classid for the current
                          task, i.e. for the net_cls cgroup to
                          which <em class="replaceable"><code>skb</code></em>
                          belongs.</p>
                          <p>This helper can be used on TC egress
                          path, but not on ingress.</p>
                          <p>The net_cls cgroup provides an
                          interface to tag network packets based on
                          a user−provided identifier for all
                          traffic coming from the tasks belonging
                          to the related cgroup. See also the
                          related kernel documentation, available
                          from the Linux sources in file
                          <code class="filename">Documentation/admin−guide/cgroup−v1/net_cls.rst</code>.</p>
                          <p>The Linux kernel has two versions for
                          cgroups: there are cgroups v1 and cgroups
                          v2. Both are available to users, who can
                          use a mixture of them, but note that the
                          net_cls cgroup is for cgroup v1 only.
                          This makes it incompatible with BPF
                          programs run on cgroups, which is a
                          cgroup−v2−only feature (a
                          socket can only hold data for one version
                          of cgroups at a time).</p>
                          <p>This helper is only available is the
                          kernel was compiled with the <code class="constant">CONFIG_CGROUP_NET_CLASSID</code>
                          configuration option set to "<em class="replaceable"><code>y</code></em>" or to
                          "<em class="replaceable"><code>m</code></em>".</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The classid, or 0 for the default
                          unconfigured classid.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_vlan_push(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, __be16</em></span> <em class="replaceable"><code>vlan_proto</code></em><span class="emphasis"><em>,
              u16</em></span> <em class="replaceable"><code>vlan_tci</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Push a <em class="replaceable"><code>vlan_tci</code></em>
                          (VLAN tag control information) of
                          protocol <em class="replaceable"><code>vlan_proto</code></em>
                          to the packet associated to <em class="replaceable"><code>skb</code></em>, then
                          update the checksum. Note that if
                          <em class="replaceable"><code>vlan_proto</code></em>
                          is different from <code class="constant">ETH_P_8021Q</code> and
                          <code class="constant">ETH_P_8021AD</code>, it is
                          considered to be <code class="constant">ETH_P_8021Q</code>.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_vlan_pop(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Pop a VLAN header from the packet
                          associated to <em class="replaceable"><code>skb</code></em>.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_get_tunnel_key(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, struct bpf_tunnel_key
              *</em></span><em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get tunnel metadata. This helper takes
                          a pointer <em class="replaceable"><code>key</code></em> to an
                          empty <span class="emphasis"><em>struct
                          bpf_tunnel_key</em></span> of <em class="replaceable"><code>size</code></em>,
                          that will be filled with tunnel metadata
                          for the packet associated to <em class="replaceable"><code>skb</code></em>. The
                          <em class="replaceable"><code>flags</code></em> can
                          be set to <code class="constant">BPF_F_TUNINFO_IPV6</code>,
                          which indicates that the tunnel is based
                          on IPv6 protocol instead of IPv4.</p>
                          <p>The <span class="emphasis"><em>struct
                          bpf_tunnel_key</em></span> is an object
                          that generalizes the principal parameters
                          used by various tunneling protocols into
                          a single struct. This way, it can be used
                          to easily make a decision based on the
                          contents of the encapsulation header,
                          "summarized" in this struct. In
                          particular, it holds the IP address of
                          the remote end (IPv4 or IPv6, depending
                          on the case) in <em class="replaceable"><code>key</code></em><code class="option">−&gt;remote_ipv4</code>
                          or <em class="replaceable"><code>key</code></em><code class="option">−&gt;remote_ipv6</code>.
                          Also, this struct exposes the <em class="replaceable"><code>key</code></em><code class="option">−&gt;tunnel_id</code>,
                          which is generally mapped to a VNI
                          (Virtual Network Identifier), making it
                          programmable together with the
                          <code class="function">bpf_skb_set_tunnel_key</code>()
                          helper.</p>
                          <p>Let's imagine that the following code
                          is part of a program attached to the TC
                          ingress interface, on one end of a GRE
                          tunnel, and is supposed to filter out all
                          messages coming from remote ends with
                          IPv4 address other than 10.0.0.1:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="informalexample">
                                    <pre class="programlisting" xml:space="preserve">
int ret;
struct bpf_tunnel_key key = {};

ret = bpf_skb_get_tunnel_key(skb, &amp;key, sizeof(key), 0);
if (ret &lt; 0)
        return TC_ACT_SHOT;     // drop packet

if (key.remote_ipv4 != 0x0a000001)
        return TC_ACT_SHOT;     // drop packet

return TC_ACT_OK;               // accept packet
</pre>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                          <p>This interface can also be used with
                          all encapsulation devices that can
                          operate in "collect metadata" mode:
                          instead of having one network device per
                          specific configuration, the "collect
                          metadata" mode only requires a single
                          device where the configuration can be
                          extracted from this helper.</p>
                          <p>This can be used together with various
                          tunnels such as VXLan, Geneve, GRE, or IP
                          in IP (IPIP).</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_set_tunnel_key(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, struct bpf_tunnel_key
              *</em></span><em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Populate tunnel metadata for packet
                          associated to <em class="replaceable"><code>skb.</code></em> The
                          tunnel metadata is set to the contents of
                          <em class="replaceable"><code>key</code></em>, of
                          <em class="replaceable"><code>size</code></em>. The
                          <em class="replaceable"><code>flags</code></em> can
                          be set to a combination of the following
                          values:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_F_TUNINFO_IPV6</code></span></dt>
                                  <dd>
                                    <p>Indicate that the tunnel is
                                    based on IPv6 protocol instead
                                    of IPv4.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_F_ZERO_CSUM_TX</code></span></dt>
                                  <dd>
                                    <p>For IPv4 packets, add a flag
                                    to tunnel metadata indicating
                                    that checksum computation
                                    should be skipped and checksum
                                    set to zeroes.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_F_DONT_FRAGMENT</code></span></dt>
                                  <dd>
                                    <p>Add a flag to tunnel
                                    metadata indicating that the
                                    packet should not be
                                    fragmented.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_F_SEQ_NUMBER</code></span></dt>
                                  <dd>
                                    <p>Add a flag to tunnel
                                    metadata indicating that a
                                    sequence number should be added
                                    to tunnel header before sending
                                    the packet. This flag was added
                                    for GRE encapsulation, but
                                    might be used with other
                                    protocols as well in the
                                    future.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>Here is a typical usage on the
                          transmit path:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="informalexample">
                                    <pre class="programlisting" xml:space="preserve">
struct bpf_tunnel_key key;
     populate key ...
bpf_skb_set_tunnel_key(skb, &amp;key, sizeof(key), 0);
bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);
</pre>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                          <p>See also the description of the
                          <code class="function">bpf_skb_get_tunnel_key</code>()
                          helper for additional information.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_perf_event_read(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Read the value of a perf event
                          counter. This helper relies on a
                          <em class="replaceable"><code>map</code></em> of
                          type <code class="constant">BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>.
                          The nature of the perf event counter is
                          selected when <em class="replaceable"><code>map</code></em> is
                          updated with perf event file descriptors.
                          The <em class="replaceable"><code>map</code></em> is an
                          array whose size is the number of
                          available CPUs, and each cell contains a
                          value relative to one CPU. The value to
                          retrieve is indicated by <em class="replaceable"><code>flags</code></em>,
                          that contains the index of the CPU to
                          look up, masked with <code class="constant">BPF_F_INDEX_MASK</code>.
                          Alternatively, <em class="replaceable"><code>flags</code></em> can
                          be set to <code class="constant">BPF_F_CURRENT_CPU</code> to
                          indicate that the value for the current
                          CPU should be retrieved.</p>
                          <p>Note that before Linux 4.13, only
                          hardware perf event can be retrieved.</p>
                          <p>Also, be aware that the newer helper
                          <code class="function">bpf_perf_event_read_value</code>()
                          is recommended over <code class="function">bpf_perf_event_read</code>()
                          in general. The latter has some ABI
                          quirks where error and counter value are
                          used as a return code (which is wrong to
                          do since ranges may overlap). This issue
                          is fixed with <code class="function">bpf_perf_event_read_value</code>(),
                          which at the same time provides more
                          features over the <code class="function">bpf_perf_event_read</code>()
                          interface. Please refer to the
                          description of <code class="function">bpf_perf_event_read_value</code>()
                          for details.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The value of the perf event counter
                          read from the map, or a negative error
                          code in case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_redirect(u32</em></span> <em class="replaceable"><code>ifindex</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Redirect the packet to another net
                          device of index <em class="replaceable"><code>ifindex</code></em>.
                          This helper is somewhat similar to
                          <code class="function">bpf_clone_redirect</code>(),
                          except that the packet is not cloned,
                          which provides increased performance.</p>
                          <p>Except for XDP, both ingress and
                          egress interfaces can be used for
                          redirection. The <code class="constant">BPF_F_INGRESS</code> value in
                          <em class="replaceable"><code>flags</code></em> is
                          used to make the distinction (ingress
                          path is selected if the flag is present,
                          egress path otherwise). Currently, XDP
                          only supports redirection to the egress
                          interface, and accepts no flag at
                          all.</p>
                          <p>The same effect can also be attained
                          with the more generic <code class="function">bpf_redirect_map</code>(),
                          which uses a BPF map to store the
                          redirect target instead of providing it
                          directly to the helper.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>For XDP, the helper returns
                          <code class="constant">XDP_REDIRECT</code> on success
                          or <code class="constant">XDP_ABORTED</code> on error.
                          For other program types, the values are
                          <code class="constant">TC_ACT_REDIRECT</code> on
                          success or <code class="constant">TC_ACT_SHOT</code> on
                          error.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u32
              bpf_get_route_realm(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Retrieve the realm or the route, that
                          is to say the <em class="replaceable"><code>tclassid</code></em>
                          field of the destination for the
                          <em class="replaceable"><code>skb</code></em>. The
                          identifier retrieved is a
                          user−provided tag, similar to the
                          one used with the net_cls cgroup (see
                          description for <code class="function">bpf_get_cgroup_classid</code>()
                          helper), but here this tag is held by a
                          route (a destination entry), not by a
                          task.</p>
                          <p>Retrieving this identifier works with
                          the clsact TC egress hook (see also
                          <em class="replaceable"><code>tc−bpf(8)</code></em>),
                          or alternatively on conventional classful
                          egress qdiscs, but not on TC ingress
                          path. In case of clsact TC egress hook,
                          this has the advantage that, internally,
                          the destination entry has not been
                          dropped yet in the transmit path.
                          Therefore, the destination entry does not
                          need to be artificially held via
                          <code class="function">netif_keep_dst</code>() for a
                          classful qdisc until the <em class="replaceable"><code>skb</code></em> is
                          freed.</p>
                          <p>This helper is available only if the
                          kernel was compiled with <code class="constant">CONFIG_IP_ROUTE_CLASSID</code>
                          configuration option.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The realm of the route for the packet
                          associated to <em class="replaceable"><code>skb</code></em>, or 0
                          if none was found.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_perf_event_output(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>data</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Write raw <em class="replaceable"><code>data</code></em> blob
                          into a special BPF perf event held by
                          <em class="replaceable"><code>map</code></em> of
                          type <code class="constant">BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>.
                          This perf event must have the following
                          attributes: <code class="constant">PERF_SAMPLE_RAW</code> as
                          <em class="replaceable"><code>sample_type</code></em>,
                          <code class="constant">PERF_TYPE_SOFTWARE</code> as
                          <em class="replaceable"><code>type</code></em>, and
                          <code class="constant">PERF_COUNT_SW_BPF_OUTPUT</code>
                          as <em class="replaceable"><code>config</code></em>.</p>
                          <p>The <em class="replaceable"><code>flags</code></em> are
                          used to indicate the index in <em class="replaceable"><code>map</code></em> for
                          which the value must be put, masked with
                          <code class="constant">BPF_F_INDEX_MASK</code>.
                          Alternatively, <em class="replaceable"><code>flags</code></em> can
                          be set to <code class="constant">BPF_F_CURRENT_CPU</code> to
                          indicate that the index of the current
                          CPU core should be used.</p>
                          <p>The value to write, of <em class="replaceable"><code>size</code></em>, is
                          passed through eBPF stack and pointed by
                          <em class="replaceable"><code>data</code></em>.</p>
                          <p>The context of the program <em class="replaceable"><code>ctx</code></em> needs
                          also be passed to the helper.</p>
                          <p>On user space, a program willing to
                          read the values needs to call
                          <code class="function">perf_event_open</code>()
                          on the perf event (either for one or for
                          all CPUs) and to store the file
                          descriptor into the <em class="replaceable"><code>map</code></em>. This
                          must be done before the eBPF program can
                          send data into it. An example is
                          available in file <code class="filename">samples/bpf/trace_output_user.c</code>
                          in the Linux kernel source tree (the eBPF
                          program counterpart is in <code class="filename">samples/bpf/trace_output_kern.c</code>).</p>
                          <p><code class="function">bpf_perf_event_output</code>()
                          achieves better performance than
                          <code class="function">bpf_trace_printk</code>() for
                          sharing data with user space, and is much
                          better suitable for streaming data from
                          eBPF programs.</p>
                          <p>Note that this helper is not
                          restricted to tracing use cases and can
                          be used with programs attached to TC or
                          XDP as well, where it allows for passing
                          data to user space listeners. Data can
                          be:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p>Only custom structs,</p>
                                  </li>
                                  <li class="listitem">
                                    <p>Only the packet payload,
                                    or</p>
                                  </li>
                                  <li class="listitem">
                                    <p>A combination of both.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_load_bytes(const void *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>offset</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>to</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper was provided as an easy
                          way to load data from a packet. It can be
                          used to load <em class="replaceable"><code>len</code></em> bytes
                          from <em class="replaceable"><code>offset</code></em>
                          from the packet associated to <em class="replaceable"><code>skb</code></em>, into
                          the buffer pointed by <em class="replaceable"><code>to</code></em>.</p>
                          <p>Since Linux 4.7, usage of this helper
                          has mostly been replaced by "direct
                          packet access", enabling packet data to
                          be manipulated with <em class="replaceable"><code>skb</code></em><code class="option">−&gt;data</code>
                          and <em class="replaceable"><code>skb</code></em><code class="option">−&gt;data_end</code>
                          pointing respectively to the first byte
                          of packet data and to the byte after the
                          last byte of packet data. However, it
                          remains useful if one wishes to read
                          large quantities of data at once from a
                          packet into the eBPF stack.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_get_stackid(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Walk a user or a kernel stack and
                          return its id. To achieve this, the
                          helper needs <em class="replaceable"><code>ctx</code></em>,
                          which is a pointer to the context on
                          which the tracing program is executed,
                          and a pointer to a <em class="replaceable"><code>map</code></em> of
                          type <code class="constant">BPF_MAP_TYPE_STACK_TRACE</code>.</p>
                          <p>The last argument, <em class="replaceable"><code>flags</code></em>,
                          holds the number of stack frames to skip
                          (from 0 to 255), masked with <code class="constant">BPF_F_SKIP_FIELD_MASK</code>.
                          The next bits can be used to set a
                          combination of the following flags:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_F_USER_STACK</code></span></dt>
                                  <dd>
                                    <p>Collect a user space stack
                                    instead of a kernel stack.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_F_FAST_STACK_CMP</code></span></dt>
                                  <dd>
                                    <p>Compare stacks by hash
                                    only.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_F_REUSE_STACKID</code></span></dt>
                                  <dd>
                                    <p>If two different stacks hash
                                    into the same <em class="replaceable"><code>stackid</code></em>,
                                    discard the old one.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>The stack id retrieved is a 32 bit
                          long integer handle which can be further
                          combined with other data (including other
                          stack ids) and used as a key into maps.
                          This can be useful for generating a
                          variety of graphs (such as flame graphs
                          or off−cpu graphs).</p>
                          <p>For walking a stack, this helper is an
                          improvement over <code class="function">bpf_probe_read</code>(), which
                          can be used with unrolled loops but is
                          not efficient and consumes a lot of eBPF
                          instructions. Instead, <code class="function">bpf_get_stackid</code>() can
                          collect up to <code class="constant">PERF_MAX_STACK_DEPTH</code>
                          both kernel and user frames. Note that
                          this limit can be controlled with the
                          <em class="replaceable"><code>sysctl</code></em>
                          program, and that it should be manually
                          increased in order to profile long user
                          stacks (such as stacks for Java
                          programs). To do so, use:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="informalexample">
                                    <pre class="programlisting" xml:space="preserve">
# sysctl kernel.perf_event_max_stack=&lt;new value&gt;
</pre>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The positive or null stack id on
                          success, or a negative error in case of
                          failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>s64
              bpf_csum_diff(__be32 *</em></span><em class="replaceable"><code>from</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>from_size</code></em><span class="emphasis"><em>, __be32 *</em></span><em class="replaceable"><code>to</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>to_size</code></em><span class="emphasis"><em>, __wsum</em></span> <em class="replaceable"><code>seed</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Compute a checksum difference, from
                          the raw buffer pointed by <em class="replaceable"><code>from</code></em>, of
                          length <em class="replaceable"><code>from_size</code></em>
                          (that must be a multiple of 4), towards
                          the raw buffer pointed by <em class="replaceable"><code>to</code></em>, of
                          size <em class="replaceable"><code>to_size</code></em>
                          (same remark). An optional <em class="replaceable"><code>seed</code></em> can
                          be added to the value (this can be
                          cascaded, the seed may come from a
                          previous call to the helper).</p>
                          <p>This is flexible enough to be used in
                          several ways:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p>With <em class="replaceable"><code>from_size</code></em>
                                    == 0, <em class="replaceable"><code>to_size</code></em>
                                    &gt; 0 and <em class="replaceable"><code>seed</code></em>
                                    set to checksum, it can be used
                                    when pushing new data.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>With <em class="replaceable"><code>from_size</code></em>
                                    &gt; 0, <em class="replaceable"><code>to_size</code></em>
                                    == 0 and <em class="replaceable"><code>seed</code></em>
                                    set to checksum, it can be used
                                    when removing data from a
                                    packet.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>With <em class="replaceable"><code>from_size</code></em>
                                    &gt; 0, <em class="replaceable"><code>to_size</code></em>
                                    &gt; 0 and <em class="replaceable"><code>seed</code></em>
                                    set to 0, it can be used to
                                    compute a diff. Note that
                                    <em class="replaceable"><code>from_size</code></em>
                                    and <em class="replaceable"><code>to_size</code></em>
                                    do not need to be equal.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>This helper can be used in combination
                          with <code class="function">bpf_l3_csum_replace</code>()
                          and <code class="function">bpf_l4_csum_replace</code>(),
                          to which one can feed in the difference
                          computed with <code class="function">bpf_csum_diff</code>().</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The checksum result, or a negative
                          error code in case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_get_tunnel_opt(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>opt</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Retrieve tunnel options metadata for
                          the packet associated to <em class="replaceable"><code>skb</code></em>, and
                          store the raw tunnel option data to the
                          buffer <em class="replaceable"><code>opt</code></em> of
                          <em class="replaceable"><code>size</code></em>.</p>
                          <p>This helper can be used with
                          encapsulation devices that can operate in
                          "collect metadata" mode (please refer to
                          the related note in the description of
                          <code class="function">bpf_skb_get_tunnel_key</code>()
                          for more details). A particular example
                          where this can be used is in combination
                          with the Geneve encapsulation protocol,
                          where it allows for pushing (with
                          <code class="function">bpf_skb_get_tunnel_opt</code>()
                          helper) and retrieving arbitrary TLVs
                          (Type−Length−Value headers)
                          from the eBPF program. This allows for
                          full customization of these headers.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The size of the option data
                          retrieved.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_set_tunnel_opt(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>opt</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Set tunnel options metadata for the
                          packet associated to <em class="replaceable"><code>skb</code></em> to
                          the option data contained in the raw
                          buffer <em class="replaceable"><code>opt</code></em> of
                          <em class="replaceable"><code>size</code></em>.</p>
                          <p>See also the description of the
                          <code class="function">bpf_skb_get_tunnel_opt</code>()
                          helper for additional information.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_change_proto(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, __be16</em></span> <em class="replaceable"><code>proto</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Change the protocol of the <em class="replaceable"><code>skb</code></em> to
                          <em class="replaceable"><code>proto</code></em>.
                          Currently supported are transition from
                          IPv4 to IPv6, and from IPv6 to IPv4. The
                          helper takes care of the groundwork for
                          the transition, including resizing the
                          socket buffer. The eBPF program is
                          expected to fill the new headers, if any,
                          via <code class="function">skb_store_bytes</code>() and
                          to recompute the checksums with
                          <code class="function">bpf_l3_csum_replace</code>()
                          and <code class="function">bpf_l4_csum_replace</code>().
                          The main case for this helper is to
                          perform NAT64 operations out of an eBPF
                          program.</p>
                          <p>Internally, the GSO type is marked as
                          dodgy so that headers are checked and
                          segments are recalculated by the GSO/GRO
                          engine. The size for GSO target is
                          adapted as well.</p>
                          <p>All values for <em class="replaceable"><code>flags</code></em> are
                          reserved for future usage, and must be
                          left at zero.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_change_type(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>type</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Change the packet type for the packet
                          associated to <em class="replaceable"><code>skb</code></em>. This
                          comes down to setting <em class="replaceable"><code>skb</code></em><code class="option">−&gt;pkt_type</code>
                          to <em class="replaceable"><code>type</code></em>,
                          except the eBPF program does not have a
                          write access to <em class="replaceable"><code>skb</code></em><code class="option">−&gt;pkt_type</code>
                          beside this helper. Using a helper here
                          allows for graceful handling of
                          errors.</p>
                          <p>The major use case is to change
                          incoming <span class="emphasis"><em>skb*s
                          to**PACKET_HOST*</em></span> in a
                          programmatic way instead of having to
                          recirculate via <code class="function">redirect</code>(...,
                          <code class="constant">BPF_F_INGRESS</code>), for
                          example.</p>
                          <p>Note that <em class="replaceable"><code>type</code></em> only
                          allows certain values. At this time, they
                          are:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">PACKET_HOST</code></span></dt>
                                  <dd>
                                    <p>Packet is for us.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">PACKET_BROADCAST</code></span></dt>
                                  <dd>
                                    <p>Send packet to all.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">PACKET_MULTICAST</code></span></dt>
                                  <dd>
                                    <p>Send packet to group.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">PACKET_OTHERHOST</code></span></dt>
                                  <dd>
                                    <p>Send packet to someone
                                    else.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_under_cgroup(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>index</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Check whether <em class="replaceable"><code>skb</code></em> is a
                          descendant of the cgroup2 held by
                          <em class="replaceable"><code>map</code></em> of
                          type <code class="constant">BPF_MAP_TYPE_CGROUP_ARRAY</code>,
                          at <em class="replaceable"><code>index</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The return value depends on the result
                          of the test, and can be:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p>0, if the <em class="replaceable"><code>skb</code></em>
                                    failed the cgroup2 descendant
                                    test.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>1, if the <em class="replaceable"><code>skb</code></em>
                                    succeeded the cgroup2
                                    descendant test.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>A negative error code, if an
                                    error occurred.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u32
              bpf_get_hash_recalc(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Retrieve the hash of the packet,
                          <em class="replaceable"><code>skb</code></em><code class="option">−&gt;hash</code>.
                          If it is not set, in particular if the
                          hash was cleared due to mangling,
                          recompute this hash. Later accesses to
                          the hash can be done directly with
                          <em class="replaceable"><code>skb</code></em><code class="option">−&gt;hash</code>.</p>
                          <p>Calling <code class="function">bpf_set_hash_invalid</code>(),
                          changing a packet prototype with
                          <code class="function">bpf_skb_change_proto</code>(),
                          or calling <code class="function">bpf_skb_store_bytes</code>()
                          with the <code class="constant">BPF_F_INVALIDATE_HASH</code>
                          are actions susceptible to clear the hash
                          and to trigger a new computation for the
                          next call to <code class="function">bpf_get_hash_recalc</code>().</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The 32−bit hash.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_current_task(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A pointer to the current task
                          struct.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_probe_write_user(void *</em></span><em class="replaceable"><code>dst</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>src</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Attempt in a safe way to write
                          <em class="replaceable"><code>len</code></em> bytes
                          from the buffer <em class="replaceable"><code>src</code></em> to
                          <em class="replaceable"><code>dst</code></em> in
                          memory. It only works for threads that
                          are in user context, and <em class="replaceable"><code>dst</code></em> must
                          be a valid user space address.</p>
                          <p>This helper should not be used to
                          implement any kind of security mechanism
                          because of TOC−TOU attacks, but
                          rather to debug, divert, and manipulate
                          execution of semi−cooperative
                          processes.</p>
                          <p>Keep in mind that this feature is
                          meant for experiments, and it has a risk
                          of crashing the system and running
                          programs. Therefore, when an eBPF program
                          using this helper is attached, a warning
                          including PID and process name is printed
                          to kernel logs.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_current_task_under_cgroup(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>index</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Check whether the probe is being run
                          is the context of a given subset of the
                          cgroup2 hierarchy. The cgroup2 to test is
                          held by <em class="replaceable"><code>map</code></em> of
                          type <code class="constant">BPF_MAP_TYPE_CGROUP_ARRAY</code>,
                          at <em class="replaceable"><code>index</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The return value depends on the result
                          of the test, and can be:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p>0, if the <em class="replaceable"><code>skb</code></em>
                                    task belongs to the
                                    cgroup2.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>1, if the <em class="replaceable"><code>skb</code></em>
                                    task does not belong to the
                                    cgroup2.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>A negative error code, if an
                                    error occurred.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_change_tail(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Resize (trim or grow) the packet
                          associated to <em class="replaceable"><code>skb</code></em> to
                          the new <em class="replaceable"><code>len</code></em>. The
                          <em class="replaceable"><code>flags</code></em> are
                          reserved for future usage, and must be
                          left at zero.</p>
                          <p>The basic idea is that the helper
                          performs the needed work to change the
                          size of the packet, then the eBPF program
                          rewrites the rest via helpers like
                          <code class="function">bpf_skb_store_bytes</code>(),
                          <code class="function">bpf_l3_csum_replace</code>(),
                          <code class="function">bpf_l3_csum_replace</code>()
                          and others. This helper is a slow path
                          utility intended for replies with control
                          messages. And because it is targeted for
                          slow path, the helper itself can afford
                          to be slow: it implicitly linearizes,
                          unclones and drops offloads from the
                          <em class="replaceable"><code>skb</code></em>.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_pull_data(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Pull in non−linear data in case
                          the <em class="replaceable"><code>skb</code></em> is
                          non−linear and not all of
                          <em class="replaceable"><code>len</code></em>
                          are part of the linear section. Make
                          <em class="replaceable"><code>len</code></em> bytes
                          from <em class="replaceable"><code>skb</code></em>
                          readable and writable. If a zero value is
                          passed for <em class="replaceable"><code>len</code></em>, then
                          the whole length of the <em class="replaceable"><code>skb</code></em> is
                          pulled.</p>
                          <p>This helper is only needed for reading
                          and writing with direct packet
                          access.</p>
                          <p>For direct packet access, testing that
                          offsets to access are within packet
                          boundaries (test on <em class="replaceable"><code>skb</code></em><code class="option">−&gt;data_end</code>)
                          is susceptible to fail if offsets are
                          invalid, or if the requested data is in
                          non−linear parts of the <em class="replaceable"><code>skb</code></em>. On
                          failure the program can just bail out, or
                          in the case of a non−linear buffer,
                          use a helper to make the data available.
                          The <code class="function">bpf_skb_load_bytes</code>()
                          helper is a first solution to access the
                          data. Another one consists in using
                          <em class="replaceable"><code>bpf_skb_pull_data</code></em>
                          to pull in once the non−linear
                          parts, then retesting and eventually
                          access the data.</p>
                          <p>At the same time, this also makes sure
                          the <em class="replaceable"><code>skb</code></em> is
                          uncloned, which is a necessary condition
                          for direct write. As this needs to be an
                          invariant for the write part only, the
                          verifier detects writes and adds a
                          prologue that is calling <code class="function">bpf_skb_pull_data</code>() to
                          effectively unclone the <em class="replaceable"><code>skb</code></em> from
                          the very beginning in case it is indeed
                          cloned.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>s64
              bpf_csum_update(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>,
              __wsum</em></span> <em class="replaceable"><code>csum</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Add the checksum <em class="replaceable"><code>csum</code></em> into
                          <em class="replaceable"><code>skb</code></em><code class="option">−&gt;csum</code>
                          in case the driver has supplied a
                          checksum for the entire packet into that
                          field. Return an error otherwise. This
                          helper is intended to be used in
                          combination with <code class="function">bpf_csum_diff</code>(), in
                          particular when the checksum needs to be
                          updated after data has been written into
                          the packet through direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The checksum on success, or a negative
                          error code in case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>void
              bpf_set_hash_invalid(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Invalidate the current <em class="replaceable"><code>skb</code></em><code class="option">−&gt;hash</code>.
                          It can be used after mangling on headers
                          through direct packet access, in order to
                          indicate that the hash is outdated and to
                          trigger a recalculation the next time the
                          kernel tries to access this hash or when
                          the <code class="function">bpf_get_hash_recalc</code>()
                          helper is called.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_get_numa_node_id(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return the id of the current NUMA
                          node. The primary use case for this
                          helper is the selection of sockets for
                          the local NUMA node, when the program is
                          attached to sockets using the
                          <code class="constant">SO_ATTACH_REUSEPORT_EBPF</code>
                          option (see also <em class="replaceable"><code>socket(7)</code></em>),
                          but the helper is also available to other
                          eBPF program types, similarly to
                          <code class="function">bpf_get_smp_processor_id</code>().</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The id of current NUMA node.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_change_head(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Grows headroom of packet associated to
                          <em class="replaceable"><code>skb</code></em> and
                          adjusts the offset of the MAC header
                          accordingly, adding <em class="replaceable"><code>len</code></em> bytes
                          of space. It automatically extends and
                          reallocates memory as required.</p>
                          <p>This helper can be used on a layer 3
                          <em class="replaceable"><code>skb</code></em> to
                          push a MAC header for redirection into a
                          layer 2 device.</p>
                          <p>All values for <em class="replaceable"><code>flags</code></em> are
                          reserved for future usage, and must be
                          left at zero.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_xdp_adjust_head(struct xdp_buff
              *</em></span><em class="replaceable"><code>xdp_md</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>delta</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Adjust (move) <em class="replaceable"><code>xdp_md</code></em><code class="option">−&gt;data</code>
                          by <em class="replaceable"><code>delta</code></em>
                          bytes. Note that it is possible to use a
                          negative value for <em class="replaceable"><code>delta</code></em>.
                          This helper can be used to prepare the
                          packet for pushing or popping
                          headers.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_probe_read_str(void *</em></span><em class="replaceable"><code>dst</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>unsafe_ptr</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Copy a NUL terminated string from an
                          unsafe kernel address <em class="replaceable"><code>unsafe_ptr</code></em>
                          to <em class="replaceable"><code>dst</code></em>. See
                          <code class="function">bpf_probe_read_kernel_str</code>()
                          for more details.</p>
                          <p>Generally, use <code class="function">bpf_probe_read_user_str</code>()
                          or <code class="function">bpf_probe_read_kernel_str</code>()
                          instead.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>On success, the strictly positive
                          length of the string, including the
                          trailing NUL character. On error, a
                          negative value.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_socket_cookie(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>If the <span class="emphasis"><em>struct sk_buff</em></span>
                          pointed by <em class="replaceable"><code>skb</code></em> has a
                          known socket, retrieve the cookie
                          (generated by the kernel) of this socket.
                          If no cookie has been set yet, generate a
                          new cookie. Once generated, the socket
                          cookie remains stable for the life of the
                          socket. This helper can be useful for
                          monitoring per socket networking traffic
                          statistics as it provides a global socket
                          identifier that can be assumed
                          unique.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A 8−byte long
                          non−decreasing number on success,
                          or 0 if the socket field is missing
                          inside <em class="replaceable"><code>skb</code></em>.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_socket_cookie(struct bpf_sock_addr
              *</em></span><em class="replaceable"><code>ctx</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Equivalent to bpf_get_socket_cookie()
                          helper that accepts <em class="replaceable"><code>skb</code></em>, but
                          gets socket from <span class="emphasis"><em>struct
                          bpf_sock_addr</em></span> context.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A 8−byte long
                          non−decreasing number.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_socket_cookie(struct bpf_sock_ops
              *</em></span><em class="replaceable"><code>ctx</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Equivalent to <code class="function">bpf_get_socket_cookie</code>()
                          helper that accepts <em class="replaceable"><code>skb</code></em>, but
                          gets socket from <span class="emphasis"><em>struct
                          bpf_sock_ops</em></span> context.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A 8−byte long
                          non−decreasing number.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u32
              bpf_get_socket_uid(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The owner UID of the socket associated
                          to <em class="replaceable"><code>skb</code></em>. If
                          the socket is <code class="constant">NULL</code>, or if it is not a
                          full socket (i.e. if it is a
                          time−wait or a request socket
                          instead), <em class="replaceable"><code>overflowuid</code></em>
                          value is returned (note that <em class="replaceable"><code>overflowuid</code></em>
                          might also be the actual UID value for
                          the socket).</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_set_hash(struct sk_buff *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>hash</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Set the full hash for <em class="replaceable"><code>skb</code></em> (set
                          the field <em class="replaceable"><code>skb</code></em><code class="option">−&gt;hash</code>)
                          to value <em class="replaceable"><code>hash</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_setsockopt(void *</em></span><em class="replaceable"><code>bpf_socket</code></em><span class="emphasis"><em>,
              int</em></span> <em class="replaceable"><code>level</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>optname</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>optval</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>optlen</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Emulate a call to <code class="function">setsockopt</code>() on the
                          socket associated to <em class="replaceable"><code>bpf_socket</code></em>,
                          which must be a full socket. The
                          <em class="replaceable"><code>level</code></em> at
                          which the option resides and the name
                          <em class="replaceable"><code>optname</code></em>
                          of the option must be specified, see
                          <em class="replaceable"><code>setsockopt(2)</code></em>
                          for more information. The option value of
                          length <em class="replaceable"><code>optlen</code></em> is
                          pointed by <em class="replaceable"><code>optval</code></em>.</p>
                          <p><em class="replaceable"><code>bpf_socket</code></em>
                          should be one of the following:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><span class="emphasis"><em>struct
                                    bpf_sock_ops</em></span> for
                                    <code class="constant">BPF_PROG_TYPE_SOCK_OPS</code>.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><span class="emphasis"><em>struct
                                    bpf_sock_addr</em></span> for
                                    <code class="constant">BPF_CGROUP_INET4_CONNECT</code>
                                    and <code class="constant">BPF_CGROUP_INET6_CONNECT</code>.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>This helper actually implements a
                          subset of <code class="function">setsockopt</code>(). It
                          supports the following <em class="replaceable"><code>level</code></em>s:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">SOL_SOCKET</code>,
                                    which supports the following
                                    <em class="replaceable"><code>optname</code></em>s:
                                    <code class="constant">SO_RCVBUF</code>,
                                    <code class="constant">SO_SNDBUF</code>,
                                    <code class="constant">SO_MAX_PACING_RATE</code>,
                                    <code class="constant">SO_PRIORITY</code>,
                                    <code class="constant">SO_RCVLOWAT</code>,
                                    <code class="constant">SO_MARK</code>,
                                    <code class="constant">SO_BINDTODEVICE</code>,
                                    <code class="constant">SO_KEEPALIVE</code>.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">IPPROTO_TCP</code>,
                                    which supports the following
                                    <em class="replaceable"><code>optname</code></em>s:
                                    <code class="constant">TCP_CONGESTION</code>,
                                    <code class="constant">TCP_BPF_IW</code>,
                                    <code class="constant">TCP_BPF_SNDCWND_CLAMP</code>,
                                    <code class="constant">TCP_SAVE_SYN</code>,
                                    <code class="constant">TCP_KEEPIDLE</code>,
                                    <code class="constant">TCP_KEEPINTVL</code>,
                                    <code class="constant">TCP_KEEPCNT</code>,
                                    <code class="constant">TCP_SYNCNT</code>,
                                    <code class="constant">TCP_USER_TIMEOUT</code>.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">IPPROTO_IP</code>,
                                    which supports <em class="replaceable"><code>optname</code></em>
                                    <code class="constant">IP_TOS</code>.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">IPPROTO_IPV6</code>,
                                    which supports <em class="replaceable"><code>optname</code></em>
                                    <code class="constant">IPV6_TCLASS</code>.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_adjust_room(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, s32</em></span> <em class="replaceable"><code>len_diff</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>mode</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Grow or shrink the room for data in
                          the packet associated to <em class="replaceable"><code>skb</code></em> by
                          <em class="replaceable"><code>len_diff</code></em>,
                          and according to the selected <em class="replaceable"><code>mode</code></em>.</p>
                          <p>By default, the helper will reset any
                          offloaded checksum indicator of the skb
                          to CHECKSUM_NONE. This can be avoided by
                          the following flag:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">BPF_F_ADJ_ROOM_NO_CSUM_RESET</code>:
                                    Do not reset offloaded checksum
                                    data of the skb to
                                    CHECKSUM_NONE.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>There are two supported modes at this
                          time:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">BPF_ADJ_ROOM_MAC</code>:
                                    Adjust room at the mac layer
                                    (room space is added or removed
                                    below the layer 2 header).</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_ADJ_ROOM_NET</code>:
                                    Adjust room at the network
                                    layer (room space is added or
                                    removed below the layer 3
                                    header).</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>The following flags are supported at
                          this time:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">BPF_F_ADJ_ROOM_FIXED_GSO</code>:
                                    Do not adjust gso_size.
                                    Adjusting mss in this way is
                                    not allowed for datagrams.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_F_ADJ_ROOM_ENCAP_L3_IPV4</code>,
                                    <code class="constant">BPF_F_ADJ_ROOM_ENCAP_L3_IPV6</code>:
                                    Any new space is reserved to
                                    hold a tunnel header. Configure
                                    skb offsets and other fields
                                    accordingly.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_F_ADJ_ROOM_ENCAP_L4_GRE</code>,
                                    <code class="constant">BPF_F_ADJ_ROOM_ENCAP_L4_UDP</code>:
                                    Use with ENCAP_L3 flags to
                                    further specify the tunnel
                                    type.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_F_ADJ_ROOM_ENCAP_L2</code>(<em class="replaceable"><code>len</code></em>):
                                    Use with ENCAP_L3/L4 flags to
                                    further specify the tunnel
                                    type; <em class="replaceable"><code>len</code></em>
                                    is the length of the inner MAC
                                    header.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_redirect_map(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Redirect the packet to the endpoint
                          referenced by <em class="replaceable"><code>map</code></em> at
                          index <em class="replaceable"><code>key</code></em>.
                          Depending on its type, this <em class="replaceable"><code>map</code></em> can
                          contain references to net devices (for
                          forwarding packets through other ports),
                          or to CPUs (for redirecting XDP frames to
                          another CPU; but this is only implemented
                          for native XDP (with driver support) as
                          of this writing).</p>
                          <p>The lower two bits of <em class="replaceable"><code>flags</code></em> are
                          used as the return code if the map lookup
                          fails. This is so that the return value
                          can be one of the XDP program return
                          codes up to <code class="constant">XDP_TX</code>, as chosen by
                          the caller. Any higher bits in the
                          <em class="replaceable"><code>flags</code></em>
                          argument must be unset.</p>
                          <p>See also <code class="function">bpf_redirect</code>(), which
                          only supports redirecting to an ifindex,
                          but doesn't require a map to do so.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><code class="constant">XDP_REDIRECT</code> on
                          success, or the value of the two lower
                          bits of the <em class="replaceable"><code>flags</code></em>
                          argument on error.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sk_redirect_map(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Redirect the packet to the socket
                          referenced by <em class="replaceable"><code>map</code></em> (of
                          type <code class="constant">BPF_MAP_TYPE_SOCKMAP</code>)
                          at index <em class="replaceable"><code>key</code></em>. Both
                          ingress and egress interfaces can be used
                          for redirection. The <code class="constant">BPF_F_INGRESS</code> value in
                          <em class="replaceable"><code>flags</code></em> is
                          used to make the distinction (ingress
                          path is selected if the flag is present,
                          egress path otherwise). This is the only
                          flag supported for now.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><code class="constant">SK_PASS</code>
                          on success, or <code class="constant">SK_DROP</code> on error.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sock_map_update(struct bpf_sock_ops
              *</em></span><em class="replaceable"><code>skops</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Add an entry to, or update a
                          <em class="replaceable"><code>map</code></em>
                          referencing sockets. The <em class="replaceable"><code>skops</code></em> is
                          used as a new value for the entry
                          associated to <em class="replaceable"><code>key</code></em>.
                          <em class="replaceable"><code>flags</code></em> is
                          one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_NOEXIST</code></span></dt>
                                  <dd>
                                    <p>The entry for <em class="replaceable"><code>key</code></em>
                                    must not exist in the map.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_EXIST</code></span></dt>
                                  <dd>
                                    <p>The entry for <em class="replaceable"><code>key</code></em>
                                    must already exist in the
                                    map.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_ANY</code></span></dt>
                                  <dd>
                                    <p>No condition on the
                                    existence of the entry for
                                    <em class="replaceable"><code>key</code></em>.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>If the <em class="replaceable"><code>map</code></em> has
                          eBPF programs (parser and verdict), those
                          will be inherited by the socket being
                          added. If the socket is already attached
                          to eBPF programs, this results in an
                          error.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_xdp_adjust_meta(struct xdp_buff
              *</em></span><em class="replaceable"><code>xdp_md</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>delta</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Adjust the address pointed by
                          <em class="replaceable"><code>xdp_md</code></em><code class="option">−&gt;data_meta</code>
                          by <em class="replaceable"><code>delta</code></em>
                          (which can be positive or negative). Note
                          that this operation modifies the address
                          stored in <em class="replaceable"><code>xdp_md</code></em><code class="option">−&gt;data</code>,
                          so the latter must be loaded only after
                          the helper has been called.</p>
                          <p>The use of <em class="replaceable"><code>xdp_md</code></em><code class="option">−&gt;data_meta</code>
                          is optional and programs are not required
                          to use it. The rationale is that when the
                          packet is processed with XDP (e.g. as DoS
                          filter), it is possible to push further
                          meta data along with it before passing to
                          the stack, and to give the guarantee that
                          an ingress eBPF program attached as a TC
                          classifier on the same device can pick
                          this up for further
                          post−processing. Since TC works
                          with socket buffers, it remains possible
                          to set from XDP the <em class="replaceable"><code>mark</code></em> or
                          <em class="replaceable"><code>priority</code></em>
                          pointers, or other pointers for the
                          socket buffer. Having this scratch space
                          generic and programmable allows for more
                          flexibility as the user is free to store
                          whatever meta data they need.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_perf_event_read_value(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><span class="emphasis"><em>, struct bpf_perf_event_value
              *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>buf_size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Read the value of a perf event
                          counter, and store it into <em class="replaceable"><code>buf</code></em> of
                          size <em class="replaceable"><code>buf_size</code></em>.
                          This helper relies on a <em class="replaceable"><code>map</code></em> of
                          type <code class="constant">BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>.
                          The nature of the perf event counter is
                          selected when <em class="replaceable"><code>map</code></em> is
                          updated with perf event file descriptors.
                          The <em class="replaceable"><code>map</code></em> is an
                          array whose size is the number of
                          available CPUs, and each cell contains a
                          value relative to one CPU. The value to
                          retrieve is indicated by <em class="replaceable"><code>flags</code></em>,
                          that contains the index of the CPU to
                          look up, masked with <code class="constant">BPF_F_INDEX_MASK</code>.
                          Alternatively, <em class="replaceable"><code>flags</code></em> can
                          be set to <code class="constant">BPF_F_CURRENT_CPU</code> to
                          indicate that the value for the current
                          CPU should be retrieved.</p>
                          <p>This helper behaves in a way close to
                          <code class="function">bpf_perf_event_read</code>()
                          helper, save that instead of just
                          returning the value observed, it fills
                          the <em class="replaceable"><code>buf</code></em>
                          structure. This allows for additional
                          data to be retrieved: in particular, the
                          enabled and running times (in <em class="replaceable"><code>buf</code></em><code class="option">−&gt;enabled</code>
                          and <em class="replaceable"><code>buf</code></em><code class="option">−&gt;running</code>,
                          respectively) are copied. In general,
                          <code class="function">bpf_perf_event_read_value</code>()
                          is recommended over <code class="function">bpf_perf_event_read</code>(),
                          which has some ABI issues and provides
                          fewer functionalities.</p>
                          <p>These values are interesting, because
                          hardware PMU (Performance Monitoring
                          Unit) counters are limited resources.
                          When there are more PMU based perf events
                          opened than available counters, kernel
                          will multiplex these events so each event
                          gets certain percentage (but not all) of
                          the PMU time. In case that multiplexing
                          happens, the number of samples or counter
                          value will not reflect the case compared
                          to when no multiplexing occurs. This
                          makes comparison between different runs
                          difficult. Typically, the counter value
                          should be normalized before comparing to
                          other experiments. The usual
                          normalization is done as follows.</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="informalexample">
                                    <pre class="programlisting" xml:space="preserve">
normalized_counter = counter * t_enabled / t_running
</pre>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                          <p>Where t_enabled is the time enabled
                          for event and t_running is the time
                          running for event since last
                          normalization. The enabled and running
                          times are accumulated since the perf
                          event open. To achieve scaling factor
                          between two invocations of an eBPF
                          program, users can use CPU id as the key
                          (which is typical for perf array usage
                          model) to remember the previous value and
                          do the calculation inside the eBPF
                          program.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_perf_prog_read_value(struct bpf_perf_event_data
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_perf_event_value
              *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>buf_size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>For en eBPF program attached to a perf
                          event, retrieve the value of the event
                          counter associated to <em class="replaceable"><code>ctx</code></em> and
                          store it in the structure pointed by
                          <em class="replaceable"><code>buf</code></em> and
                          of size <em class="replaceable"><code>buf_size</code></em>.
                          Enabled and running times are also stored
                          in the structure (see description of
                          helper <code class="function">bpf_perf_event_read_value</code>()
                          for more details).</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_getsockopt(void *</em></span><em class="replaceable"><code>bpf_socket</code></em><span class="emphasis"><em>,
              int</em></span> <em class="replaceable"><code>level</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>optname</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>optval</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>optlen</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Emulate a call to <code class="function">getsockopt</code>() on the
                          socket associated to <em class="replaceable"><code>bpf_socket</code></em>,
                          which must be a full socket. The
                          <em class="replaceable"><code>level</code></em> at
                          which the option resides and the name
                          <em class="replaceable"><code>optname</code></em>
                          of the option must be specified, see
                          <em class="replaceable"><code>getsockopt(2)</code></em>
                          for more information. The retrieved value
                          is stored in the structure pointed by
                          <em class="replaceable"><code>opval</code></em> and
                          of length <em class="replaceable"><code>optlen</code></em>.</p>
                          <p><em class="replaceable"><code>bpf_socket</code></em>
                          should be one of the following:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><span class="emphasis"><em>struct
                                    bpf_sock_ops</em></span> for
                                    <code class="constant">BPF_PROG_TYPE_SOCK_OPS</code>.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><span class="emphasis"><em>struct
                                    bpf_sock_addr</em></span> for
                                    <code class="constant">BPF_CGROUP_INET4_CONNECT</code>
                                    and <code class="constant">BPF_CGROUP_INET6_CONNECT</code>.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>This helper actually implements a
                          subset of <code class="function">getsockopt</code>(). It
                          supports the following <em class="replaceable"><code>level</code></em>s:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">IPPROTO_TCP</code>,
                                    which supports <em class="replaceable"><code>optname</code></em>
                                    <code class="constant">TCP_CONGESTION</code>.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">IPPROTO_IP</code>,
                                    which supports <em class="replaceable"><code>optname</code></em>
                                    <code class="constant">IP_TOS</code>.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">IPPROTO_IPV6</code>,
                                    which supports <em class="replaceable"><code>optname</code></em>
                                    <code class="constant">IPV6_TCLASS</code>.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_override_return(struct pt_regs
              *</em></span><em class="replaceable"><code>regs</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>rc</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Used for error injection, this helper
                          uses kprobes to override the return value
                          of the probed function, and to set it to
                          <em class="replaceable"><code>rc</code></em>. The
                          first argument is the context <em class="replaceable"><code>regs</code></em> on
                          which the kprobe works.</p>
                          <p>This helper works by setting the PC
                          (program counter) to an override function
                          which is run in place of the original
                          probed function. This means the probed
                          function is not run at all. The
                          replacement function just returns with
                          the required value.</p>
                          <p>This helper has security implications,
                          and thus is subject to restrictions. It
                          is only available if the kernel was
                          compiled with the <code class="constant">CONFIG_BPF_KPROBE_OVERRIDE</code>
                          configuration option, and in this case it
                          only works on functions tagged with
                          <code class="constant">ALLOW_ERROR_INJECTION</code>
                          in the kernel code.</p>
                          <p>Also, the helper is only available for
                          the architectures having the
                          CONFIG_FUNCTION_ERROR_INJECTION option.
                          As of this writing, x86 architecture is
                          the only one to support this feature.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sock_ops_cb_flags_set(struct bpf_sock_ops
              *</em></span><em class="replaceable"><code>bpf_sock</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>argval</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Attempt to set the value of the
                          <em class="replaceable"><code>bpf_sock_ops_cb_flags</code></em>
                          field for the full TCP socket associated
                          to <em class="replaceable"><code>bpf_sock_ops</code></em>
                          to <em class="replaceable"><code>argval</code></em>.</p>
                          <p>The primary use of this field is to
                          determine if there should be calls to
                          eBPF programs of type <code class="constant">BPF_PROG_TYPE_SOCK_OPS</code>
                          at various points in the TCP code. A
                          program of the same type can change its
                          value, per connection and as necessary,
                          when the connection is established. This
                          field is directly accessible for reading,
                          but this helper must be used for updates
                          in order to return an error if an eBPF
                          program tries to set a callback that is
                          not supported in the current kernel.</p>
                          <p><em class="replaceable"><code>argval</code></em> is
                          a flag array which can combine these
                          flags:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">BPF_SOCK_OPS_RTO_CB_FLAG</code>
                                    (retransmission time out)</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_SOCK_OPS_RETRANS_CB_FLAG</code>
                                    (retransmission)</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_SOCK_OPS_STATE_CB_FLAG</code>
                                    (TCP state change)</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_SOCK_OPS_RTT_CB_FLAG</code>
                                    (every RTT)</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>Therefore, this function can be used
                          to clear a callback flag by setting the
                          appropriate bit to zero. e.g. to disable
                          the RTO callback:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><em class="replaceable"><code>bpf_sock_ops_cb_flags_set(bpf_sock,</code></em></span></dt>
                                  <dd>
                                    <p><span class="emphasis"><em>bpf_sock−&gt;bpf_sock_ops_cb_flags
                                    &amp;
                                    ~BPF_SOCK_OPS_RTO_CB_FLAG)</em></span></p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>Here are some examples of where one
                          could call such eBPF program:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p>When RTO fires.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>When a packet is
                                    retransmitted.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>When the connection
                                    terminates.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>When a packet is sent.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>When a packet is
                                    received.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Code <code class="option">−EINVAL</code> if the
                          socket is not a full TCP socket;
                          otherwise, a positive number containing
                          the bits that could not be set is
                          returned (which comes down to 0 if all
                          bits were set as required).</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_msg_redirect_map(struct sk_msg_buff
              *</em></span><em class="replaceable"><code>msg</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper is used in programs
                          implementing policies at the socket
                          level. If the message <em class="replaceable"><code>msg</code></em> is
                          allowed to pass (i.e. if the verdict eBPF
                          program returns <code class="constant">SK_PASS</code>), redirect it
                          to the socket referenced by <em class="replaceable"><code>map</code></em> (of
                          type <code class="constant">BPF_MAP_TYPE_SOCKMAP</code>)
                          at index <em class="replaceable"><code>key</code></em>. Both
                          ingress and egress interfaces can be used
                          for redirection. The <code class="constant">BPF_F_INGRESS</code> value in
                          <em class="replaceable"><code>flags</code></em> is
                          used to make the distinction (ingress
                          path is selected if the flag is present,
                          egress path otherwise). This is the only
                          flag supported for now.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><code class="constant">SK_PASS</code>
                          on success, or <code class="constant">SK_DROP</code> on error.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_msg_apply_bytes(struct sk_msg_buff
              *</em></span><em class="replaceable"><code>msg</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>bytes</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>For socket policies, apply the verdict
                          of the eBPF program to the next
                          <em class="replaceable"><code>bytes</code></em>
                          (number of bytes) of message <em class="replaceable"><code>msg</code></em>.</p>
                          <p>For example, this helper can be used
                          in the following cases:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p>A single <code class="function">sendmsg</code>() or
                                    <code class="function">sendfile</code>()
                                    system call contains multiple
                                    logical messages that the eBPF
                                    program is supposed to read and
                                    for which it should apply a
                                    verdict.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>An eBPF program only cares
                                    to read the first <em class="replaceable"><code>bytes</code></em>
                                    of a <em class="replaceable"><code>msg</code></em>.
                                    If the message has a large
                                    payload, then setting up and
                                    calling the eBPF program
                                    repeatedly for all bytes, even
                                    though the verdict is already
                                    known, would create unnecessary
                                    overhead.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>When called from within an eBPF
                          program, the helper sets a counter
                          internal to the BPF infrastructure, that
                          is used to apply the last verdict to the
                          next <em class="replaceable"><code>bytes</code></em>. If
                          <em class="replaceable"><code>bytes</code></em> is
                          smaller than the current data being
                          processed from a <code class="function">sendmsg</code>() or
                          <code class="function">sendfile</code>()
                          system call, the first <em class="replaceable"><code>bytes</code></em>
                          will be sent and the eBPF program will be
                          re−run with the pointer for start
                          of data pointing to byte number
                          <em class="replaceable"><code>bytes</code></em>
                          <span class="emphasis"><em>+
                          1</em></span>. If <em class="replaceable"><code>bytes</code></em> is
                          larger than the current data being
                          processed, then the eBPF verdict will be
                          applied to multiple <code class="function">sendmsg</code>() or
                          <code class="function">sendfile</code>()
                          calls until <em class="replaceable"><code>bytes</code></em> are
                          consumed.</p>
                          <p>Note that if a socket closes with the
                          internal counter holding a non−zero
                          value, this is not a problem because data
                          is not being buffered for <em class="replaceable"><code>bytes</code></em> and
                          is sent as it is received.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_msg_cork_bytes(struct sk_msg_buff
              *</em></span><em class="replaceable"><code>msg</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>bytes</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>For socket policies, prevent the
                          execution of the verdict eBPF program for
                          message <em class="replaceable"><code>msg</code></em> until
                          <em class="replaceable"><code>bytes</code></em>
                          (byte number) have been accumulated.</p>
                          <p>This can be used when one needs a
                          specific number of bytes before a verdict
                          can be assigned, even if the data spans
                          multiple <code class="function">sendmsg</code>() or
                          <code class="function">sendfile</code>()
                          calls. The extreme case would be a user
                          calling <code class="function">sendmsg</code>() repeatedly
                          with 1−byte long message segments.
                          Obviously, this is bad for performance,
                          but it is still valid. If the eBPF
                          program needs <em class="replaceable"><code>bytes</code></em>
                          bytes to validate a header, this helper
                          can be used to prevent the eBPF program
                          to be called again until <em class="replaceable"><code>bytes</code></em>
                          have been accumulated.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_msg_pull_data(struct sk_msg_buff
              *</em></span><em class="replaceable"><code>msg</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>start</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>end</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>For socket policies, pull in
                          non−linear data from user space for
                          <em class="replaceable"><code>msg</code></em> and
                          set pointers <em class="replaceable"><code>msg</code></em><code class="option">−&gt;data</code>
                          and <em class="replaceable"><code>msg</code></em><code class="option">−&gt;data_end</code>
                          to <em class="replaceable"><code>start</code></em> and
                          <em class="replaceable"><code>end</code></em> bytes
                          offsets into <em class="replaceable"><code>msg</code></em>,
                          respectively.</p>
                          <p>If a program of type <code class="constant">BPF_PROG_TYPE_SK_MSG</code> is
                          run on a <em class="replaceable"><code>msg</code></em> it
                          can only parse data that the (<em class="replaceable"><code>data</code></em>,
                          <em class="replaceable"><code>data_end</code></em>)
                          pointers have already consumed. For
                          <code class="function">sendmsg</code>()
                          hooks this is likely the first
                          scatterlist element. But for calls
                          relying on the <em class="replaceable"><code>sendpage</code></em>
                          handler (e.g. <code class="function">sendfile</code>()) this will
                          be the range (<code class="constant">0</code>, <code class="constant">0</code>) because the data is
                          shared with user space and by default the
                          objective is to avoid allowing user space
                          to modify data while (or after) eBPF
                          verdict is being decided. This helper can
                          be used to pull in data and to set the
                          start and end pointer to given values.
                          Data will be copied if necessary (i.e. if
                          data was not linear and if start and end
                          pointers do not point to the same
                          chunk).</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                          <p>All values for <em class="replaceable"><code>flags</code></em> are
                          reserved for future usage, and must be
                          left at zero.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_bind(struct bpf_sock_addr *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct sockaddr
              *</em></span><em class="replaceable"><code>addr</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>addr_len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Bind the socket associated to
                          <em class="replaceable"><code>ctx</code></em> to
                          the address pointed by <em class="replaceable"><code>addr</code></em>, of
                          length <em class="replaceable"><code>addr_len</code></em>.
                          This allows for making outgoing
                          connection from the desired IP address,
                          which can be useful for example when all
                          processes inside a cgroup should use one
                          single IP address on a host that has
                          multiple IP configured.</p>
                          <p>This helper works for IPv4 and IPv6,
                          TCP and UDP sockets. The domain
                          (<em class="replaceable"><code>addr</code></em><code class="option">−&gt;sa_family</code>)
                          must be <code class="constant">AF_INET</code> (or
                          <code class="constant">AF_INET6</code>).
                          It's advised to pass zero port
                          (<em class="replaceable"><code>sin_port</code></em>
                          or <em class="replaceable"><code>sin6_port</code></em>)
                          which triggers
                          IP_BIND_ADDRESS_NO_PORT−like
                          behavior and lets the kernel efficiently
                          pick up an unused port as long as
                          4−tuple is unique. Passing
                          non−zero port might lead to
                          degraded performance.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_xdp_adjust_tail(struct xdp_buff
              *</em></span><em class="replaceable"><code>xdp_md</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>delta</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Adjust (move) <em class="replaceable"><code>xdp_md</code></em><code class="option">−&gt;data_end</code>
                          by <em class="replaceable"><code>delta</code></em>
                          bytes. It is possible to both shrink and
                          grow the packet tail. Shrink done via
                          <em class="replaceable"><code>delta</code></em>
                          being a negative integer.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_get_xfrm_state(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>index</code></em><span class="emphasis"><em>, struct bpf_xfrm_state
              *</em></span><em class="replaceable"><code>xfrm_state</code></em><span class="emphasis"><em>,
              u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Retrieve the XFRM state (IP transform
                          framework, see also <em class="replaceable"><code>ip−xfrm(8)</code></em>)
                          at <em class="replaceable"><code>index</code></em> in
                          XFRM "security path" for <em class="replaceable"><code>skb</code></em>.</p>
                          <p>The retrieved value is stored in the
                          <span class="emphasis"><em>struct
                          bpf_xfrm_state</em></span> pointed by
                          <em class="replaceable"><code>xfrm_state</code></em>
                          and of length <em class="replaceable"><code>size</code></em>.</p>
                          <p>All values for <em class="replaceable"><code>flags</code></em> are
                          reserved for future usage, and must be
                          left at zero.</p>
                          <p>This helper is available only if the
                          kernel was compiled with <code class="constant">CONFIG_XFRM</code>
                          configuration option.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_get_stack(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return a user or a kernel stack in bpf
                          program provided buffer. To achieve this,
                          the helper needs <em class="replaceable"><code>ctx</code></em>,
                          which is a pointer to the context on
                          which the tracing program is executed. To
                          store the stacktrace, the bpf program
                          provides <em class="replaceable"><code>buf</code></em> with
                          a nonnegative <em class="replaceable"><code>size</code></em>.</p>
                          <p>The last argument, <em class="replaceable"><code>flags</code></em>,
                          holds the number of stack frames to skip
                          (from 0 to 255), masked with <code class="constant">BPF_F_SKIP_FIELD_MASK</code>.
                          The next bits can be used to set the
                          following flags:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_F_USER_STACK</code></span></dt>
                                  <dd>
                                    <p>Collect a user space stack
                                    instead of a kernel stack.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_F_USER_BUILD_ID</code></span></dt>
                                  <dd>
                                    <p>Collect buildid+offset
                                    instead of ips for user stack,
                                    only valid if <code class="constant">BPF_F_USER_STACK</code>
                                    is also specified.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p><code class="function">bpf_get_stack</code>() can
                          collect up to <code class="constant">PERF_MAX_STACK_DEPTH</code>
                          both kernel and user frames, subject to
                          sufficient large buffer size. Note that
                          this limit can be controlled with the
                          <em class="replaceable"><code>sysctl</code></em>
                          program, and that it should be manually
                          increased in order to profile long user
                          stacks (such as stacks for Java
                          programs). To do so, use:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="informalexample">
                                    <pre class="programlisting" xml:space="preserve">
# sysctl kernel.perf_event_max_stack=&lt;new value&gt;
</pre>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A non−negative value equal to or
                          less than <em class="replaceable"><code>size</code></em> on
                          success, or a negative error in case of
                          failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_load_bytes_relative(const void
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>offset</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>to</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>start_header</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper is similar to <code class="function">bpf_skb_load_bytes</code>() in
                          that it provides an easy way to load
                          <em class="replaceable"><code>len</code></em> bytes
                          from <em class="replaceable"><code>offset</code></em>
                          from the packet associated to <em class="replaceable"><code>skb</code></em>, into
                          the buffer pointed by <em class="replaceable"><code>to</code></em>. The
                          difference to <code class="function">bpf_skb_load_bytes</code>() is
                          that a fifth argument <em class="replaceable"><code>start_header</code></em>
                          exists in order to select a base offset
                          to start from. <em class="replaceable"><code>start_header</code></em>
                          can be one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_HDR_START_MAC</code></span></dt>
                                  <dd>
                                    <p>Base offset to load data
                                    from is <em class="replaceable"><code>skb</code></em>'s
                                    mac header.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_HDR_START_NET</code></span></dt>
                                  <dd>
                                    <p>Base offset to load data
                                    from is <em class="replaceable"><code>skb</code></em>'s
                                    network header.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>In general, "direct packet access" is
                          the preferred method to access packet
                          data, however, this helper is in
                          particular useful in socket filters where
                          <em class="replaceable"><code>skb</code></em><code class="option">−&gt;data</code>
                          does not always point to the start of the
                          mac header and where "direct packet
                          access" is not available.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_fib_lookup(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_fib_lookup
              *</em></span><em class="replaceable"><code>params</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>plen</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Do FIB lookup in kernel tables using
                          parameters in <em class="replaceable"><code>params</code></em>.
                          If lookup is successful and result shows
                          packet is to be forwarded, the neighbor
                          tables are searched for the nexthop. If
                          successful (ie., FIB lookup shows
                          forwarding and nexthop is resolved), the
                          nexthop address is returned in ipv4_dst
                          or ipv6_dst based on family, smac is set
                          to mac address of egress device, dmac is
                          set to nexthop mac address, rt_metric is
                          set to metric from route (IPv4/IPv6
                          only), and ifindex is set to the device
                          index of the nexthop from the FIB
                          lookup.</p>
                          <p><em class="replaceable"><code>plen</code></em>
                          argument is the size of the passed in
                          struct. <em class="replaceable"><code>flags</code></em>
                          argument can be a combination of one or
                          more of the following values:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_FIB_LOOKUP_DIRECT</code></span></dt>
                                  <dd>
                                    <p>Do a direct table lookup vs
                                    full lookup using FIB
                                    rules.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_FIB_LOOKUP_OUTPUT</code></span></dt>
                                  <dd>
                                    <p>Perform lookup from an
                                    egress perspective (default is
                                    ingress).</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p><em class="replaceable"><code>ctx</code></em> is
                          either <span class="emphasis"><em>struct
                          xdp_md</em></span> for XDP programs or
                          <span class="emphasis"><em>struct
                          sk_buff</em></span> tc cls_act
                          programs.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p>&lt; 0 if any input argument
                                    is invalid</p>
                                  </li>
                                  <li class="listitem">
                                    <p>0 on success (packet is
                                    forwarded, nexthop neighbor
                                    exists)</p>
                                  </li>
                                  <li class="listitem">
                                    <p>&gt; 0 one of <code class="constant">BPF_FIB_LKUP_RET_</code>
                                    codes explaining why the packet
                                    is not forwarded or needs
                                    assist from full stack</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sock_hash_update(struct bpf_sock_ops
              *</em></span><em class="replaceable"><code>skops</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Add an entry to, or update a sockhash
                          <em class="replaceable"><code>map</code></em>
                          referencing sockets. The <em class="replaceable"><code>skops</code></em> is
                          used as a new value for the entry
                          associated to <em class="replaceable"><code>key</code></em>.
                          <em class="replaceable"><code>flags</code></em> is
                          one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_NOEXIST</code></span></dt>
                                  <dd>
                                    <p>The entry for <em class="replaceable"><code>key</code></em>
                                    must not exist in the map.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_EXIST</code></span></dt>
                                  <dd>
                                    <p>The entry for <em class="replaceable"><code>key</code></em>
                                    must already exist in the
                                    map.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_ANY</code></span></dt>
                                  <dd>
                                    <p>No condition on the
                                    existence of the entry for
                                    <em class="replaceable"><code>key</code></em>.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>If the <em class="replaceable"><code>map</code></em> has
                          eBPF programs (parser and verdict), those
                          will be inherited by the socket being
                          added. If the socket is already attached
                          to eBPF programs, this results in an
                          error.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_msg_redirect_hash(struct sk_msg_buff
              *</em></span><em class="replaceable"><code>msg</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper is used in programs
                          implementing policies at the socket
                          level. If the message <em class="replaceable"><code>msg</code></em> is
                          allowed to pass (i.e. if the verdict eBPF
                          program returns <code class="constant">SK_PASS</code>), redirect it
                          to the socket referenced by <em class="replaceable"><code>map</code></em> (of
                          type <code class="constant">BPF_MAP_TYPE_SOCKHASH</code>)
                          using hash <em class="replaceable"><code>key</code></em>. Both
                          ingress and egress interfaces can be used
                          for redirection. The <code class="constant">BPF_F_INGRESS</code> value in
                          <em class="replaceable"><code>flags</code></em> is
                          used to make the distinction (ingress
                          path is selected if the flag is present,
                          egress path otherwise). This is the only
                          flag supported for now.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><code class="constant">SK_PASS</code>
                          on success, or <code class="constant">SK_DROP</code> on error.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sk_redirect_hash(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper is used in programs
                          implementing policies at the skb socket
                          level. If the sk_buff <em class="replaceable"><code>skb</code></em> is
                          allowed to pass (i.e. if the verdict eBPF
                          program returns <code class="constant">SK_PASS</code>), redirect it
                          to the socket referenced by <em class="replaceable"><code>map</code></em> (of
                          type <code class="constant">BPF_MAP_TYPE_SOCKHASH</code>)
                          using hash <em class="replaceable"><code>key</code></em>. Both
                          ingress and egress interfaces can be used
                          for redirection. The <code class="constant">BPF_F_INGRESS</code> value in
                          <em class="replaceable"><code>flags</code></em> is
                          used to make the distinction (ingress
                          path is selected if the flag is present,
                          egress otherwise). This is the only flag
                          supported for now.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><code class="constant">SK_PASS</code>
                          on success, or <code class="constant">SK_DROP</code> on error.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_lwt_push_encap(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>type</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>hdr</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Encapsulate the packet associated to
                          <em class="replaceable"><code>skb</code></em>
                          within a Layer 3 protocol header. This
                          header is provided in the buffer at
                          address <em class="replaceable"><code>hdr</code></em>, with
                          <em class="replaceable"><code>len</code></em> its
                          size in bytes. <em class="replaceable"><code>type</code></em>
                          indicates the protocol of the header and
                          can be one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_LWT_ENCAP_SEG6</code></span></dt>
                                  <dd>
                                    <p>IPv6 encapsulation with
                                    Segment Routing Header
                                    (<span class="emphasis"><em>struct
                                    ipv6_sr_hdr</em></span>).
                                    <em class="replaceable"><code>hdr</code></em>
                                    only contains the SRH, the IPv6
                                    header is computed by the
                                    kernel.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_LWT_ENCAP_SEG6_INLINE</code></span></dt>
                                  <dd>
                                    <p>Only works if <em class="replaceable"><code>skb</code></em>
                                    contains an IPv6 packet. Insert
                                    a Segment Routing Header
                                    (<span class="emphasis"><em>struct
                                    ipv6_sr_hdr</em></span>) inside
                                    the IPv6 header.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_LWT_ENCAP_IP</code></span></dt>
                                  <dd>
                                    <p>IP encapsulation
                                    (GRE/GUE/IPIP/etc). The outer
                                    header must be IPv4 or IPv6,
                                    followed by zero or more
                                    additional headers, up to
                                    <code class="constant">LWT_BPF_MAX_HEADROOM</code>
                                    total bytes in all prepended
                                    headers. Please note that if
                                    <code class="function">skb_is_gso</code>(<em class="replaceable"><code>skb</code></em>)
                                    is true, no more than two
                                    headers can be prepended, and
                                    the inner header, if present,
                                    should be either GRE or
                                    UDP/GUE.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p><code class="constant">BPF_LWT_ENCAP_SEG6</code>*
                          types can be called by BPF programs of
                          type <code class="constant">BPF_PROG_TYPE_LWT_IN</code>;
                          <code class="constant">BPF_LWT_ENCAP_IP</code> type
                          can be called by bpf programs of types
                          <code class="constant">BPF_PROG_TYPE_LWT_IN</code>
                          and <code class="constant">BPF_PROG_TYPE_LWT_XMIT</code>.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_lwt_seg6_store_bytes(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>offset</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>from</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Store <em class="replaceable"><code>len</code></em> bytes
                          from address <em class="replaceable"><code>from</code></em> into
                          the packet associated to <em class="replaceable"><code>skb</code></em>, at
                          <em class="replaceable"><code>offset</code></em>.
                          Only the flags, tag and TLVs inside the
                          outermost IPv6 Segment Routing Header can
                          be modified through this helper.</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_lwt_seg6_adjust_srh(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>offset</code></em><span class="emphasis"><em>, s32</em></span> <em class="replaceable"><code>delta</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Adjust the size allocated to TLVs in
                          the outermost IPv6 Segment Routing Header
                          contained in the packet associated to
                          <em class="replaceable"><code>skb</code></em>, at
                          position <em class="replaceable"><code>offset</code></em> by
                          <em class="replaceable"><code>delta</code></em>
                          bytes. Only offsets after the segments
                          are accepted. <em class="replaceable"><code>delta</code></em> can
                          be as well positive (growing) as negative
                          (shrinking).</p>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_lwt_seg6_action(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>action</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>param</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>param_len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Apply an IPv6 Segment Routing action
                          of type <em class="replaceable"><code>action</code></em> to
                          the packet associated to <em class="replaceable"><code>skb</code></em>. Each
                          action takes a parameter contained at
                          address <em class="replaceable"><code>param</code></em>,
                          and of length <em class="replaceable"><code>param_len</code></em>
                          bytes. <em class="replaceable"><code>action</code></em>
                          can be one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">SEG6_LOCAL_ACTION_END_X</code></span></dt>
                                  <dd>
                                    <p>End.X action: Endpoint with
                                    Layer−3
                                    cross−connect. Type of
                                    <em class="replaceable"><code>param</code></em>:
                                    <span class="emphasis"><em>struct
                                    in6_addr</em></span>.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">SEG6_LOCAL_ACTION_END_T</code></span></dt>
                                  <dd>
                                    <p>End.T action: Endpoint with
                                    specific IPv6 table lookup.
                                    Type of <em class="replaceable"><code>param</code></em>:
                                    <em class="replaceable"><code>int</code></em>.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">SEG6_LOCAL_ACTION_END_B6</code></span></dt>
                                  <dd>
                                    <p>End.B6 action: Endpoint
                                    bound to an SRv6 policy. Type
                                    of <em class="replaceable"><code>param</code></em>:
                                    <span class="emphasis"><em>struct
                                    ipv6_sr_hdr</em></span>.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">SEG6_LOCAL_ACTION_END_B6_ENCAP</code></span></dt>
                                  <dd>
                                    <p>End.B6.Encap action:
                                    Endpoint bound to an SRv6
                                    encapsulation policy. Type of
                                    <em class="replaceable"><code>param</code></em>:
                                    <span class="emphasis"><em>struct
                                    ipv6_sr_hdr</em></span>.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>A call to this helper is susceptible
                          to change the underlying packet buffer.
                          Therefore, at load time, all checks on
                          pointers previously done by the verifier
                          are invalidated and must be performed
                          again, if the helper is used in
                          combination with direct packet
                          access.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_rc_repeat(void *</em></span><em class="replaceable"><code>ctx</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper is used in programs
                          implementing IR decoding, to report a
                          successfully decoded repeat key message.
                          This delays the generation of a key up
                          event for previously generated key down
                          event.</p>
                          <p>Some IR protocols like NEC have a
                          special IR message for repeating last
                          button, for when a button is held
                          down.</p>
                          <p>The <em class="replaceable"><code>ctx</code></em>
                          should point to the lirc sample as passed
                          into the program.</p>
                          <p>This helper is only available is the
                          kernel was compiled with the <code class="constant">CONFIG_BPF_LIRC_MODE2</code>
                          configuration option set to "<em class="replaceable"><code>y</code></em>".</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_rc_keydown(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>protocol</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>scancode</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>toggle</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper is used in programs
                          implementing IR decoding, to report a
                          successfully decoded key press with
                          <em class="replaceable"><code>scancode</code></em>,
                          <em class="replaceable"><code>toggle</code></em>
                          value in the given <em class="replaceable"><code>protocol</code></em>.
                          The scancode will be translated to a
                          keycode using the rc keymap, and reported
                          as an input key down event. After a
                          period a key up event is generated. This
                          period can be extended by calling either
                          <code class="function">bpf_rc_keydown</code>() again
                          with the same values, or calling
                          <code class="function">bpf_rc_repeat</code>().</p>
                          <p>Some protocols include a toggle bit,
                          in case the button was released and
                          pressed again between consecutive
                          scancodes.</p>
                          <p>The <em class="replaceable"><code>ctx</code></em>
                          should point to the lirc sample as passed
                          into the program.</p>
                          <p>The <em class="replaceable"><code>protocol</code></em>
                          is the decoded protocol number (see
                          <span class="emphasis"><em>enum
                          rc_proto</em></span> for some predefined
                          values).</p>
                          <p>This helper is only available is the
                          kernel was compiled with the <code class="constant">CONFIG_BPF_LIRC_MODE2</code>
                          configuration option set to "<em class="replaceable"><code>y</code></em>".</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_skb_cgroup_id(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return the cgroup v2 id of the socket
                          associated with the <em class="replaceable"><code>skb</code></em>. This
                          is roughly similar to the <code class="function">bpf_get_cgroup_classid</code>()
                          helper for cgroup v1 by providing a tag
                          resp. identifier that can be matched on
                          or used for map lookups e.g. to implement
                          policy. The cgroup v2 id of a given path
                          in the hierarchy is exposed in user space
                          through the f_handle API in order to get
                          to the same 64−bit id.</p>
                          <p>This helper can be used on TC egress
                          path, but not on ingress, and is
                          available only if the kernel was compiled
                          with the <code class="constant">CONFIG_SOCK_CGROUP_DATA</code>
                          configuration option.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The id is returned or 0 in case the id
                          could not be retrieved.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_current_cgroup_id(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A 64−bit integer containing the
                          current cgroup id based on the cgroup
                          within which the current task is
                          running.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>void
              *bpf_get_local_storage(void *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get the pointer to the local storage
                          area. The type and the size of the local
                          storage is defined by the <em class="replaceable"><code>map</code></em>
                          argument. The <em class="replaceable"><code>flags</code></em>
                          meaning is specific for each map type,
                          and has to be 0 for cgroup local
                          storage.</p>
                          <p>Depending on the BPF program type, a
                          local storage area can be shared between
                          multiple instances of the BPF program,
                          running simultaneously.</p>
                          <p>A user should care about the
                          synchronization by himself. For example,
                          by using the <code class="constant">BPF_STX_XADD</code>
                          instruction to alter the shared data.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A pointer to the local storage
                          area.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sk_select_reuseport(struct sk_reuseport_md
              *</em></span><em class="replaceable"><code>reuse</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>key</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Select a <code class="constant">SO_REUSEPORT</code> socket
                          from a <code class="constant">BPF_MAP_TYPE_REUSEPORT_ARRAY</code>
                          <em class="replaceable"><code>map</code></em>. It
                          checks the selected socket is matching
                          the incoming request in the socket
                          buffer.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_skb_ancestor_cgroup_id(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>ancestor_level</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return id of cgroup v2 that is
                          ancestor of cgroup associated with the
                          <em class="replaceable"><code>skb</code></em> at
                          the <em class="replaceable"><code>ancestor_level</code></em>.
                          The root cgroup is at <em class="replaceable"><code>ancestor_level</code></em>
                          zero and each step down the hierarchy
                          increments the level. If <em class="replaceable"><code>ancestor_level</code></em>
                          == level of cgroup associated with
                          <em class="replaceable"><code>skb</code></em>, then
                          return value will be same as that of
                          <code class="function">bpf_skb_cgroup_id</code>().</p>
                          <p>The helper is useful to implement
                          policies based on cgroups that are upper
                          in hierarchy than immediate cgroup
                          associated with <em class="replaceable"><code>skb</code></em>.</p>
                          <p>The format of returned id and helper
                          limitations are same as in <code class="function">bpf_skb_cgroup_id</code>().</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The id is returned or 0 in case the id
                          could not be retrieved.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              bpf_sock *bpf_sk_lookup_tcp(void
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_sock_tuple
              *</em></span><em class="replaceable"><code>tuple</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>tuple_size</code></em><span class="emphasis"><em>,
              u64</em></span> <em class="replaceable"><code>netns</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Look for TCP socket matching
                          <em class="replaceable"><code>tuple</code></em>,
                          optionally in a child network namespace
                          <em class="replaceable"><code>netns</code></em>.
                          The return value must be checked, and if
                          non−<code class="constant">NULL</code>, released via
                          <code class="function">bpf_sk_release</code>().</p>
                          <p>The <em class="replaceable"><code>ctx</code></em>
                          should point to the context of the
                          program, such as the skb or socket
                          (depending on the hook in use). This is
                          used to determine the base network
                          namespace for the lookup.</p>
                          <p><em class="replaceable"><code>tuple_size</code></em>
                          must be one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="function">sizeof</code>(<em class="replaceable"><code>tuple</code></em><code class="option">−&gt;ipv4</code>)</span></dt>
                                  <dd>
                                    <p>Look for an IPv4 socket.</p>
                                  </dd>
                                  <dt><span class="term"><code class="function">sizeof</code>(<em class="replaceable"><code>tuple</code></em><code class="option">−&gt;ipv6</code>)</span></dt>
                                  <dd>
                                    <p>Look for an IPv6 socket.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>If the <em class="replaceable"><code>netns</code></em> is
                          a negative signed 32−bit integer,
                          then the socket lookup table in the netns
                          associated with the <em class="replaceable"><code>ctx</code></em> will
                          be used. For the TC hooks, this is the
                          netns of the device in the skb. For
                          socket hooks, this is the netns of the
                          socket. If <em class="replaceable"><code>netns</code></em> is
                          any other signed 32−bit value
                          greater than or equal to zero then it
                          specifies the ID of the netns relative to
                          the netns associated with the <em class="replaceable"><code>ctx</code></em>.
                          <em class="replaceable"><code>netns</code></em>
                          values beyond the range of 32−bit
                          integers are reserved for future use.</p>
                          <p>All values for <em class="replaceable"><code>flags</code></em> are
                          reserved for future usage, and must be
                          left at zero.</p>
                          <p>This helper is available only if the
                          kernel was compiled with <code class="constant">CONFIG_NET</code>
                          configuration option.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Pointer to <span class="emphasis"><em>struct
                          bpf_sock</em></span>, or <code class="constant">NULL</code> in case of
                          failure. For sockets with reuseport
                          option, the <span class="emphasis"><em>struct
                          bpf_sock</em></span> result is from
                          <em class="replaceable"><code>reuse</code></em><code class="option">−&gt;socks</code>[]
                          using the hash of the tuple.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              bpf_sock *bpf_sk_lookup_udp(void
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_sock_tuple
              *</em></span><em class="replaceable"><code>tuple</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>tuple_size</code></em><span class="emphasis"><em>,
              u64</em></span> <em class="replaceable"><code>netns</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Look for UDP socket matching
                          <em class="replaceable"><code>tuple</code></em>,
                          optionally in a child network namespace
                          <em class="replaceable"><code>netns</code></em>.
                          The return value must be checked, and if
                          non−<code class="constant">NULL</code>, released via
                          <code class="function">bpf_sk_release</code>().</p>
                          <p>The <em class="replaceable"><code>ctx</code></em>
                          should point to the context of the
                          program, such as the skb or socket
                          (depending on the hook in use). This is
                          used to determine the base network
                          namespace for the lookup.</p>
                          <p><em class="replaceable"><code>tuple_size</code></em>
                          must be one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="function">sizeof</code>(<em class="replaceable"><code>tuple</code></em><code class="option">−&gt;ipv4</code>)</span></dt>
                                  <dd>
                                    <p>Look for an IPv4 socket.</p>
                                  </dd>
                                  <dt><span class="term"><code class="function">sizeof</code>(<em class="replaceable"><code>tuple</code></em><code class="option">−&gt;ipv6</code>)</span></dt>
                                  <dd>
                                    <p>Look for an IPv6 socket.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p>If the <em class="replaceable"><code>netns</code></em> is
                          a negative signed 32−bit integer,
                          then the socket lookup table in the netns
                          associated with the <em class="replaceable"><code>ctx</code></em> will
                          be used. For the TC hooks, this is the
                          netns of the device in the skb. For
                          socket hooks, this is the netns of the
                          socket. If <em class="replaceable"><code>netns</code></em> is
                          any other signed 32−bit value
                          greater than or equal to zero then it
                          specifies the ID of the netns relative to
                          the netns associated with the <em class="replaceable"><code>ctx</code></em>.
                          <em class="replaceable"><code>netns</code></em>
                          values beyond the range of 32−bit
                          integers are reserved for future use.</p>
                          <p>All values for <em class="replaceable"><code>flags</code></em> are
                          reserved for future usage, and must be
                          left at zero.</p>
                          <p>This helper is available only if the
                          kernel was compiled with <code class="constant">CONFIG_NET</code>
                          configuration option.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Pointer to <span class="emphasis"><em>struct
                          bpf_sock</em></span>, or <code class="constant">NULL</code> in case of
                          failure. For sockets with reuseport
                          option, the <span class="emphasis"><em>struct
                          bpf_sock</em></span> result is from
                          <em class="replaceable"><code>reuse</code></em><code class="option">−&gt;socks</code>[]
                          using the hash of the tuple.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sk_release(struct bpf_sock
              *</em></span><em class="replaceable"><code>sock</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Release the reference held by
                          <em class="replaceable"><code>sock</code></em>.
                          <em class="replaceable"><code>sock</code></em> must
                          be a non−<code class="constant">NULL</code> pointer that was
                          returned from <code class="function">bpf_sk_lookup_xxx</code>().</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_map_push_elem(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>value</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Push an element <em class="replaceable"><code>value</code></em> in
                          <em class="replaceable"><code>map</code></em>.
                          <em class="replaceable"><code>flags</code></em> is
                          one of:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_EXIST</code></span></dt>
                                  <dd>
                                    <p>If the queue/stack is full,
                                    the oldest element is removed
                                    to make room for this.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_map_pop_elem(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>value</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Pop an element from <em class="replaceable"><code>map</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_map_peek_elem(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>value</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get an element from <em class="replaceable"><code>map</code></em>
                          without removing it.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_msg_push_data(struct sk_msg_buff
              *</em></span><em class="replaceable"><code>msg</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>start</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>For socket policies, insert <em class="replaceable"><code>len</code></em> bytes
                          into <em class="replaceable"><code>msg</code></em> at
                          offset <em class="replaceable"><code>start</code></em>.</p>
                          <p>If a program of type <code class="constant">BPF_PROG_TYPE_SK_MSG</code> is
                          run on a <em class="replaceable"><code>msg</code></em> it
                          may want to insert metadata or options
                          into the <em class="replaceable"><code>msg</code></em>. This
                          can later be read and used by any of the
                          lower layer BPF hooks.</p>
                          <p>This helper may fail if under memory
                          pressure (a malloc fails) in these cases
                          BPF programs will get an appropriate
                          error and BPF programs will need to
                          handle them.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_msg_pop_data(struct sk_msg_buff
              *</em></span><em class="replaceable"><code>msg</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>start</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Will remove <em class="replaceable"><code>len</code></em> bytes
                          from a <em class="replaceable"><code>msg</code></em>
                          starting at byte <em class="replaceable"><code>start</code></em>.
                          This may result in <span class="errorname">ENOMEM</span> errors under
                          certain situations if an allocation and
                          copy are required due to a full ring
                          buffer. However, the helper will try to
                          avoid doing the allocation if possible.
                          Other errors can occur if input
                          parameters are invalid either due to
                          <em class="replaceable"><code>start</code></em>
                          byte not being valid part of <em class="replaceable"><code>msg</code></em>
                          payload and/or <em class="replaceable"><code>pop</code></em> value
                          being to large.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_rc_pointer_rel(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, s32</em></span> <em class="replaceable"><code>rel_x</code></em><span class="emphasis"><em>, s32</em></span> <em class="replaceable"><code>rel_y</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper is used in programs
                          implementing IR decoding, to report a
                          successfully decoded pointer
                          movement.</p>
                          <p>The <em class="replaceable"><code>ctx</code></em>
                          should point to the lirc sample as passed
                          into the program.</p>
                          <p>This helper is only available is the
                          kernel was compiled with the <code class="constant">CONFIG_BPF_LIRC_MODE2</code>
                          configuration option set to "<em class="replaceable"><code>y</code></em>".</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_spin_lock(struct bpf_spin_lock
              *</em></span><em class="replaceable"><code>lock</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Acquire a spinlock represented by the
                          pointer <em class="replaceable"><code>lock</code></em>,
                          which is stored as part of a value of a
                          map. Taking the lock allows to safely
                          update the rest of the fields in that
                          value. The spinlock can (and must) later
                          be released with a call to <code class="function">bpf_spin_unlock</code>(<em class="replaceable"><code>lock</code></em>).</p>
                          <p>Spinlocks in BPF programs come with a
                          number of restrictions and
                          constraints:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><em class="replaceable"><code>bpf_spin_lock</code></em>
                                    objects are only allowed inside
                                    maps of types <code class="constant">BPF_MAP_TYPE_HASH</code>
                                    and <code class="constant">BPF_MAP_TYPE_ARRAY</code>
                                    (this list could be extended in
                                    the future).</p>
                                  </li>
                                  <li class="listitem">
                                    <p>BTF description of the map
                                    is mandatory.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>The BPF program can take ONE
                                    lock at a time, since taking
                                    two or more could cause dead
                                    locks.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>Only one <span class="emphasis"><em>struct
                                    bpf_spin_lock</em></span> is
                                    allowed per map element.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>When the lock is taken,
                                    calls (either BPF to BPF or
                                    helpers) are not allowed.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>The <code class="constant">BPF_LD_ABS</code>
                                    and <code class="constant">BPF_LD_IND</code>
                                    instructions are not allowed
                                    inside a spinlock−ed
                                    region.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>The BPF program MUST call
                                    <code class="function">bpf_spin_unlock</code>()
                                    to release the lock, on all
                                    execution paths, before it
                                    returns.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>The BPF program can access
                                    <span class="emphasis"><em>struct
                                    bpf_spin_lock</em></span> only
                                    via the <code class="function">bpf_spin_lock</code>()
                                    and <code class="function">bpf_spin_unlock</code>()
                                    helpers. Loading or storing
                                    data into the <em class="replaceable"><code>structbpf_spin_lock</code></em>
                                    <em class="replaceable"><code>lock</code></em><code class="literal">;</code>
                                    field of a map is not
                                    allowed.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>To use the <code class="function">bpf_spin_lock</code>()
                                    helper, the BTF description of
                                    the map value must be a struct
                                    and have <em class="replaceable"><code>structbpf_spin_lock</code></em>
                                    <em class="replaceable"><code>anyname</code></em><code class="literal">;</code>
                                    field at the top level. Nested
                                    lock inside another struct is
                                    not allowed.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>The <span class="emphasis"><em>struct
                                    bpf_spin_lock</em></span>
                                    <em class="replaceable"><code>lock</code></em>
                                    field in a map value must be
                                    aligned on a multiple of 4
                                    bytes in that value.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>Syscall with command
                                    <code class="constant">BPF_MAP_LOOKUP_ELEM</code>
                                    does not copy the <em class="replaceable"><code>bpf_spin_lock</code></em>
                                    field to user space.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>Syscall with command
                                    <code class="constant">BPF_MAP_UPDATE_ELEM</code>,
                                    or update from a BPF program,
                                    do not update the <em class="replaceable"><code>bpf_spin_lock</code></em>
                                    field.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><em class="replaceable"><code>bpf_spin_lock</code></em>
                                    cannot be on the stack or
                                    inside a networking packet (it
                                    can only be inside of a map
                                    values).</p>
                                  </li>
                                  <li class="listitem">
                                    <p><em class="replaceable"><code>bpf_spin_lock</code></em>
                                    is available to root only.</p>
                                  </li>
                                  <li class="listitem">
                                    <p>Tracing programs and socket
                                    filter programs cannot use
                                    <code class="function">bpf_spin_lock</code>()
                                    due to insufficient preemption
                                    checks (but this may change in
                                    the future).</p>
                                  </li>
                                  <li class="listitem">
                                    <p><em class="replaceable"><code>bpf_spin_lock</code></em>
                                    is not allowed in inner maps of
                                    map−in−map.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_spin_unlock(struct bpf_spin_lock
              *</em></span><em class="replaceable"><code>lock</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Release the <em class="replaceable"><code>lock</code></em>
                          previously locked by a call to
                          <code class="function">bpf_spin_lock</code>(<em class="replaceable"><code>lock</code></em>).</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              bpf_sock *bpf_sk_fullsock(struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper gets a <span class="emphasis"><em>struct
                          bpf_sock</em></span> pointer such that
                          all the fields in this <em class="replaceable"><code>bpf_sock</code></em>
                          can be accessed.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A <span class="emphasis"><em>struct
                          bpf_sock</em></span> pointer on success,
                          or <code class="constant">NULL</code> in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              bpf_tcp_sock *bpf_tcp_sock(struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>This helper gets a <span class="emphasis"><em>struct
                          bpf_tcp_sock</em></span> pointer from a
                          <span class="emphasis"><em>struct
                          bpf_sock</em></span> pointer.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A <span class="emphasis"><em>struct
                          bpf_tcp_sock</em></span> pointer on
                          success, or <code class="constant">NULL</code> in case of
                          failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_ecn_set_ce(struct sk_buff
              *</em></span><em class="replaceable"><code>skb</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Set ECN (Explicit Congestion
                          Notification) field of IP header to
                          <code class="constant">CE</code>
                          (Congestion Encountered) if current value
                          is <code class="constant">ECT</code> (ECN
                          Capable Transport). Otherwise, do
                          nothing. Works with IPv6 and IPv4.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>1 if the <code class="constant">CE</code> flag is set (either
                          by the current helper call or because it
                          was already present), 0 if it is not
                          set.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              bpf_sock *bpf_get_listener_sock(struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return a <span class="emphasis"><em>struct
                          bpf_sock</em></span> pointer in
                          <code class="constant">TCP_LISTEN</code>
                          state. <code class="function">bpf_sk_release</code>() is
                          unnecessary and not allowed.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A <span class="emphasis"><em>struct
                          bpf_sock</em></span> pointer on success,
                          or <code class="constant">NULL</code> in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              bpf_sock *bpf_skc_lookup_tcp(void
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_sock_tuple
              *</em></span><em class="replaceable"><code>tuple</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>tuple_size</code></em><span class="emphasis"><em>,
              u64</em></span> <em class="replaceable"><code>netns</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Look for TCP socket matching
                          <em class="replaceable"><code>tuple</code></em>,
                          optionally in a child network namespace
                          <em class="replaceable"><code>netns</code></em>.
                          The return value must be checked, and if
                          non−<code class="constant">NULL</code>, released via
                          <code class="function">bpf_sk_release</code>().</p>
                          <p>This function is identical to
                          <code class="function">bpf_sk_lookup_tcp</code>(),
                          except that it also returns timewait or
                          request sockets. Use <code class="function">bpf_sk_fullsock</code>() or
                          <code class="function">bpf_tcp_sock</code>() to
                          access the full structure.</p>
                          <p>This helper is available only if the
                          kernel was compiled with <code class="constant">CONFIG_NET</code>
                          configuration option.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Pointer to <span class="emphasis"><em>struct
                          bpf_sock</em></span>, or <code class="constant">NULL</code> in case of
                          failure. For sockets with reuseport
                          option, the <span class="emphasis"><em>struct
                          bpf_sock</em></span> result is from
                          <em class="replaceable"><code>reuse</code></em><code class="option">−&gt;socks</code>[]
                          using the hash of the tuple.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_tcp_check_syncookie(struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>iph</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>iph_len</code></em><span class="emphasis"><em>, struct tcphdr
              *</em></span><em class="replaceable"><code>th</code></em><span class="emphasis"><em>,
              u32</em></span> <em class="replaceable"><code>th_len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Check whether <em class="replaceable"><code>iph</code></em> and
                          <em class="replaceable"><code>th</code></em>
                          contain a valid SYN cookie ACK for the
                          listening socket in <em class="replaceable"><code>sk</code></em>.</p>
                          <p><em class="replaceable"><code>iph</code></em>
                          points to the start of the IPv4 or IPv6
                          header, while <em class="replaceable"><code>iph_len</code></em>
                          contains <code class="function">sizeof</code>(<span class="emphasis"><em>struct iphdr</em></span>)
                          or <code class="function">sizeof</code>(<span class="emphasis"><em>struct
                          ip6hdr</em></span>).</p>
                          <p><em class="replaceable"><code>th</code></em> points
                          to the start of the TCP header, while
                          <em class="replaceable"><code>th_len</code></em>
                          contains <code class="function">sizeof</code>(<span class="emphasis"><em>struct
                          tcphdr</em></span>).</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 if <em class="replaceable"><code>iph</code></em> and
                          <em class="replaceable"><code>th</code></em> are a
                          valid SYN cookie ACK, or a negative error
                          otherwise.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sysctl_get_name(struct bpf_sysctl
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, char *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, size_t</em></span> <em class="replaceable"><code>buf_len</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get name of sysctl in /proc/sys/ and
                          copy it into provided by program buffer
                          <em class="replaceable"><code>buf</code></em> of
                          size <em class="replaceable"><code>buf_len</code></em>.</p>
                          <p>The buffer is always NUL terminated,
                          unless it's zero−sized.</p>
                          <p>If <em class="replaceable"><code>flags</code></em> is
                          zero, full name (e.g. "net/ipv4/tcp_mem")
                          is copied. Use <code class="constant">BPF_F_SYSCTL_BASE_NAME</code>
                          flag to copy base name only (e.g.
                          "tcp_mem").</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Number of character copied (not
                          including the trailing NUL).</p>
                          <p><code class="option">−E2BIG</code> if the
                          buffer wasn't big enough (<em class="replaceable"><code>buf</code></em> will
                          contain truncated name in this case).</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sysctl_get_current_value(struct bpf_sysctl
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, char *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, size_t</em></span> <em class="replaceable"><code>buf_len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get current value of sysctl as it is
                          presented in /proc/sys (incl. newline,
                          etc), and copy it as a string into
                          provided by program buffer <em class="replaceable"><code>buf</code></em> of
                          size <em class="replaceable"><code>buf_len</code></em>.</p>
                          <p>The whole value is copied, no matter
                          what file position user space issued e.g.
                          sys_read at.</p>
                          <p>The buffer is always NUL terminated,
                          unless it's zero−sized.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Number of character copied (not
                          including the trailing NUL).</p>
                          <p><code class="option">−E2BIG</code> if the
                          buffer wasn't big enough (<em class="replaceable"><code>buf</code></em> will
                          contain truncated name in this case).</p>
                          <p><code class="option">−EINVAL</code> if current
                          value was unavailable, e.g. because
                          sysctl is uninitialized and read returns
                          −EIO for it.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sysctl_get_new_value(struct bpf_sysctl
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, char *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, size_t</em></span> <em class="replaceable"><code>buf_len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get new value being written by user
                          space to sysctl (before the actual write
                          happens) and copy it as a string into
                          provided by program buffer <em class="replaceable"><code>buf</code></em> of
                          size <em class="replaceable"><code>buf_len</code></em>.</p>
                          <p>User space may write new value at file
                          position &gt; 0.</p>
                          <p>The buffer is always NUL terminated,
                          unless it's zero−sized.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Number of character copied (not
                          including the trailing NUL).</p>
                          <p><code class="option">−E2BIG</code> if the
                          buffer wasn't big enough (<em class="replaceable"><code>buf</code></em> will
                          contain truncated name in this case).</p>
                          <p><code class="option">−EINVAL</code> if sysctl
                          is being read.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sysctl_set_new_value(struct bpf_sysctl
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, const char *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, size_t</em></span> <em class="replaceable"><code>buf_len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Override new value being written by
                          user space to sysctl with value provided
                          by program in buffer <em class="replaceable"><code>buf</code></em> of
                          size <em class="replaceable"><code>buf_len</code></em>.</p>
                          <p><em class="replaceable"><code>buf</code></em>
                          should contain a string in same form as
                          provided by user space on sysctl
                          write.</p>
                          <p>User space may write new value at file
                          position &gt; 0. To override the whole
                          sysctl value file position should be set
                          to zero.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success.</p>
                          <p><code class="option">−E2BIG</code> if the
                          <em class="replaceable"><code>buf_len</code></em>
                          is too big.</p>
                          <p><code class="option">−EINVAL</code> if sysctl
                          is being read.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_strtol(const char *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, size_t</em></span> <em class="replaceable"><code>buf_len</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><span class="emphasis"><em>, long *</em></span><em class="replaceable"><code>res</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Convert the initial part of the string
                          from buffer <em class="replaceable"><code>buf</code></em> of
                          size <em class="replaceable"><code>buf_len</code></em>
                          to a long integer according to the given
                          base and save the result in <em class="replaceable"><code>res</code></em>.</p>
                          <p>The string may begin with an arbitrary
                          amount of white space (as determined by
                          <a class="link" href="../htmlman3/isalpha.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">isspace</span>(3)</span></a>)
                          followed by a single optional
                          '<span class="emphasis"><em>−</em></span>'
                          sign.</p>
                          <p>Five least significant bits of
                          <em class="replaceable"><code>flags</code></em>
                          encode base, other bits are currently
                          unused.</p>
                          <p>Base must be either 8, 10, 16, or 0 to
                          detect it automatically similar to user
                          space <a class="link" href="../htmlman3/strtol.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">strtol</span>(3)</span></a>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Number of characters consumed on
                          success. Must be positive but no more
                          than <em class="replaceable"><code>buf_len</code></em>.</p>
                          <p><code class="option">−EINVAL</code> if no valid
                          digits were found or unsupported base was
                          provided.</p>
                          <p><code class="option">−ERANGE</code> if
                          resulting value was out of range.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_strtoul(const char *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, size_t</em></span> <em class="replaceable"><code>buf_len</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><span class="emphasis"><em>, unsigned long
              *</em></span><em class="replaceable"><code>res</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Convert the initial part of the string
                          from buffer <em class="replaceable"><code>buf</code></em> of
                          size <em class="replaceable"><code>buf_len</code></em>
                          to an unsigned long integer according to
                          the given base and save the result in
                          <em class="replaceable"><code>res</code></em>.</p>
                          <p>The string may begin with an arbitrary
                          amount of white space (as determined by
                          <a class="link" href="../htmlman3/isalpha.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">isspace</span>(3)</span></a>).</p>
                          <p>Five least significant bits of
                          <em class="replaceable"><code>flags</code></em>
                          encode base, other bits are currently
                          unused.</p>
                          <p>Base must be either 8, 10, 16, or 0 to
                          detect it automatically similar to user
                          space <a class="link" href="../htmlman3/strtoul.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">strtoul</span>(3)</span></a>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Number of characters consumed on
                          success. Must be positive but no more
                          than <em class="replaceable"><code>buf_len</code></em>.</p>
                          <p><code class="option">−EINVAL</code> if no valid
                          digits were found or unsupported base was
                          provided.</p>
                          <p><code class="option">−ERANGE</code> if
                          resulting value was out of range.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>void
              *bpf_sk_storage_get(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>value</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Get a bpf−local−storage
                          from a <em class="replaceable"><code>sk</code></em>.</p>
                          <p>Logically, it could be thought of
                          getting the value from a <em class="replaceable"><code>map</code></em> with
                          <em class="replaceable"><code>sk</code></em> as the
                          <em class="replaceable"><code>key</code></em>. From
                          this perspective, the usage is not much
                          different from <code class="function">bpf_map_lookup_elem</code>(<em class="replaceable"><code>map</code></em>,
                          <em class="replaceable"><code>&amp;</code></em><em class="replaceable"><code>sk</code></em>)
                          except this helper enforces the key must
                          be a full socket and the map must be a
                          <code class="constant">BPF_MAP_TYPE_SK_STORAGE</code>
                          also.</p>
                          <p>Underneath, the value is stored
                          locally at <em class="replaceable"><code>sk</code></em>
                          instead of the <em class="replaceable"><code>map</code></em>. The
                          <em class="replaceable"><code>map</code></em> is
                          used as the bpf−local−storage
                          "type". The bpf−local−storage
                          "type" (i.e. the <em class="replaceable"><code>map</code></em>) is
                          searched against all
                          bpf−local−storages residing
                          at <em class="replaceable"><code>sk</code></em>.</p>
                          <p>An optional <em class="replaceable"><code>flags</code></em>
                          (<code class="constant">BPF_SK_STORAGE_GET_F_CREATE</code>)
                          can be used such that a new
                          bpf−local−storage will be
                          created if one does not exist. <em class="replaceable"><code>value</code></em> can
                          be used together with <code class="constant">BPF_SK_STORAGE_GET_F_CREATE</code>
                          to specify the initial value of a
                          bpf−local−storage. If
                          <em class="replaceable"><code>value</code></em> is
                          <code class="constant">NULL</code>, the
                          new bpf−local−storage will be
                          zero initialized.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A bpf−local−storage
                          pointer is returned on success.</p>
                          <p><code class="constant">NULL</code> if
                          not found or there was an error in adding
                          a new bpf−local−storage.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sk_storage_delete(struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Delete a bpf−local−storage
                          from a <em class="replaceable"><code>sk</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success.</p>
                          <p><code class="option">−ENOENT</code> if the
                          bpf−local−storage cannot be
                          found.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_send_signal(u32</em></span> <em class="replaceable"><code>sig</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Send signal <em class="replaceable"><code>sig</code></em> to
                          the process of the current task. The
                          signal may be delivered to any of this
                          process's threads.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success or successfully
                          queued.</p>
                          <p><code class="option">−EBUSY</code> if work
                          queue under nmi is full.</p>
                          <p><code class="option">−EINVAL</code> if
                          <em class="replaceable"><code>sig</code></em> is
                          invalid.</p>
                          <p><code class="option">−EPERM</code> if no
                          permission to send the <em class="replaceable"><code>sig</code></em>.</p>
                          <p><code class="option">−EAGAIN</code> if bpf
                          program can try again.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>s64
              bpf_tcp_gen_syncookie(struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>iph</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>iph_len</code></em><span class="emphasis"><em>, struct tcphdr
              *</em></span><em class="replaceable"><code>th</code></em><span class="emphasis"><em>,
              u32</em></span> <em class="replaceable"><code>th_len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Try to issue a SYN cookie for the
                          packet with corresponding IP/TCP headers,
                          <em class="replaceable"><code>iph</code></em> and
                          <em class="replaceable"><code>th</code></em>, on
                          the listening socket in <em class="replaceable"><code>sk</code></em>.</p>
                          <p><em class="replaceable"><code>iph</code></em>
                          points to the start of the IPv4 or IPv6
                          header, while <em class="replaceable"><code>iph_len</code></em>
                          contains <code class="function">sizeof</code>(<span class="emphasis"><em>struct iphdr</em></span>)
                          or <code class="function">sizeof</code>(<span class="emphasis"><em>struct
                          ip6hdr</em></span>).</p>
                          <p><em class="replaceable"><code>th</code></em> points
                          to the start of the TCP header, while
                          <em class="replaceable"><code>th_len</code></em>
                          contains the length of the TCP
                          header.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>On success, lower 32 bits hold the
                          generated SYN cookie in followed by 16
                          bits which hold the MSS value for that
                          cookie, and the top 16 bits are
                          unused.</p>
                          <p>On failure, the returned value is one
                          of the following:</p>
                          <p><code class="option">−EINVAL</code> SYN cookie
                          cannot be issued due to error</p>
                          <p><code class="option">−ENOENT</code> SYN cookie
                          should not be issued (no SYN flood)</p>
                          <p><code class="option">−EOPNOTSUPP</code> kernel
                          configuration does not enable SYN
                          cookies</p>
                          <p><code class="option">−EPROTONOSUPPORT</code> IP
                          packet version is not 4 or 6</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_skb_output(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>data</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Write raw <em class="replaceable"><code>data</code></em> blob
                          into a special BPF perf event held by
                          <em class="replaceable"><code>map</code></em> of
                          type <code class="constant">BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>.
                          This perf event must have the following
                          attributes: <code class="constant">PERF_SAMPLE_RAW</code> as
                          <em class="replaceable"><code>sample_type</code></em>,
                          <code class="constant">PERF_TYPE_SOFTWARE</code> as
                          <em class="replaceable"><code>type</code></em>, and
                          <code class="constant">PERF_COUNT_SW_BPF_OUTPUT</code>
                          as <em class="replaceable"><code>config</code></em>.</p>
                          <p>The <em class="replaceable"><code>flags</code></em> are
                          used to indicate the index in <em class="replaceable"><code>map</code></em> for
                          which the value must be put, masked with
                          <code class="constant">BPF_F_INDEX_MASK</code>.
                          Alternatively, <em class="replaceable"><code>flags</code></em> can
                          be set to <code class="constant">BPF_F_CURRENT_CPU</code> to
                          indicate that the index of the current
                          CPU core should be used.</p>
                          <p>The value to write, of <em class="replaceable"><code>size</code></em>, is
                          passed through eBPF stack and pointed by
                          <em class="replaceable"><code>data</code></em>.</p>
                          <p><em class="replaceable"><code>ctx</code></em> is a
                          pointer to in−kernel struct
                          sk_buff.</p>
                          <p>This helper is similar to <code class="function">bpf_perf_event_output</code>()
                          but restricted to raw_tracepoint bpf
                          programs.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_probe_read_user(void *</em></span><em class="replaceable"><code>dst</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>unsafe_ptr</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Safely attempt to read <em class="replaceable"><code>size</code></em>
                          bytes from user space address <em class="replaceable"><code>unsafe_ptr</code></em>
                          and store the data in <em class="replaceable"><code>dst</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_probe_read_kernel(void *</em></span><em class="replaceable"><code>dst</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>unsafe_ptr</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Safely attempt to read <em class="replaceable"><code>size</code></em>
                          bytes from kernel space address
                          <em class="replaceable"><code>unsafe_ptr</code></em>
                          and store the data in <em class="replaceable"><code>dst</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_probe_read_user_str(void *</em></span><em class="replaceable"><code>dst</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>unsafe_ptr</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Copy a NUL terminated string from an
                          unsafe user address <em class="replaceable"><code>unsafe_ptr</code></em>
                          to <em class="replaceable"><code>dst</code></em>. The
                          <em class="replaceable"><code>size</code></em>
                          should include the terminating NUL byte.
                          In case the string length is smaller than
                          <em class="replaceable"><code>size</code></em>, the
                          target is not padded with further NUL
                          bytes. If the string length is larger
                          than <em class="replaceable"><code>size</code></em>,
                          just <em class="replaceable"><code>size</code></em>−1
                          bytes are copied and the last byte is set
                          to NUL.</p>
                          <p>On success, the length of the copied
                          string is returned. This makes this
                          helper useful in tracing programs for
                          reading strings, and more importantly to
                          get its length at runtime. See the
                          following snippet:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="informalexample">
                                    <pre class="programlisting" xml:space="preserve">
SEC("kprobe/sys_open")
void bpf_sys_open(struct pt_regs *ctx)
{
        char buf[PATHLEN]; // PATHLEN is defined to 256
        int res = bpf_probe_read_user_str(buf, sizeof(buf),
                                          ctx−&gt;di);

        // Consume buf, for example push it to
        // user space via bpf_perf_event_output(); we
        // can use res (the string length) as event
        // size, after checking its boundaries.
}
</pre>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                          <p>In comparison, using <code class="function">bpf_probe_read_user</code>()
                          helper here instead to read the string
                          would require to estimate the length at
                          compile time, and would often result in
                          copying more memory than necessary.</p>
                          <p>Another useful use case is when
                          parsing individual process arguments or
                          individual environment variables
                          navigating <em class="replaceable"><code>current</code></em><code class="option">−&gt;mm−&gt;arg_start</code>
                          and <em class="replaceable"><code>current</code></em><code class="option">−&gt;mm−&gt;env_start</code>:
                          using this helper and the return value,
                          one can quickly iterate at the right
                          offset of the memory area.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>On success, the strictly positive
                          length of the string, including the
                          trailing NUL character. On error, a
                          negative value.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_probe_read_kernel_str(void
              *</em></span><em class="replaceable"><code>dst</code></em><span class="emphasis"><em>,
              u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>unsafe_ptr</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Copy a NUL terminated string from an
                          unsafe kernel address <em class="replaceable"><code>unsafe_ptr</code></em>
                          to <em class="replaceable"><code>dst</code></em>. Same
                          semantics as with <code class="function">bpf_probe_read_user_str</code>()
                          apply.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>On success, the strictly positive
                          length of the string, including the
                          trailing NUL character. On error, a
                          negative value.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_tcp_send_ack(void *</em></span><em class="replaceable"><code>tp</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>rcv_nxt</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Send out a tcp−ack. <em class="replaceable"><code>tp</code></em> is the
                          in−kernel struct <em class="replaceable"><code>tcp_sock</code></em>.
                          <em class="replaceable"><code>rcv_nxt</code></em>
                          is the ack_seq to be sent out.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_send_signal_thread(u32</em></span> <em class="replaceable"><code>sig</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Send signal <em class="replaceable"><code>sig</code></em> to
                          the thread corresponding to the current
                          task.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success or successfully
                          queued.</p>
                          <p><code class="option">−EBUSY</code> if work
                          queue under nmi is full.</p>
                          <p><code class="option">−EINVAL</code> if
                          <em class="replaceable"><code>sig</code></em> is
                          invalid.</p>
                          <p><code class="option">−EPERM</code> if no
                          permission to send the <em class="replaceable"><code>sig</code></em>.</p>
                          <p><code class="option">−EAGAIN</code> if bpf
                          program can try again.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_jiffies64(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Obtain the 64bit jiffies</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The 64 bit jiffies</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_read_branch_records(struct bpf_perf_event_data
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>For an eBPF program attached to a perf
                          event, retrieve the branch records
                          (<span class="emphasis"><em>struct
                          perf_branch_entry</em></span>) associated
                          to <em class="replaceable"><code>ctx</code></em> and
                          store it in the buffer pointed by
                          <em class="replaceable"><code>buf</code></em> up to
                          size <em class="replaceable"><code>size</code></em>
                          bytes.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>On success, number of bytes written to
                          <em class="replaceable"><code>buf</code></em>. On
                          error, a negative value.</p>
                          <p>The <em class="replaceable"><code>flags</code></em> can
                          be set to <code class="constant">BPF_F_GET_BRANCH_RECORDS_SIZE</code>
                          to instead return the number of bytes
                          required to store all the branch entries.
                          If this flag is set, <em class="replaceable"><code>buf</code></em> may
                          be NULL.</p>
                          <p><code class="option">−EINVAL</code> if
                          arguments invalid or <em class="replaceable"><code>size</code></em> not
                          a multiple of <code class="function">sizeof</code>(<span class="emphasis"><em>struct
                          perf_branch_entry</em></span>).</p>
                          <p><code class="option">−ENOENT</code> if
                          architecture does not support branch
                          records.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_get_ns_current_pid_tgid(u64</em></span>
              <em class="replaceable"><code>dev</code></em><span class="emphasis"><em>,
              u64</em></span> <em class="replaceable"><code>ino</code></em><span class="emphasis"><em>, struct bpf_pidns_info
              *</em></span><em class="replaceable"><code>nsdata</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Returns 0 on success, values for
                          <em class="replaceable"><code>pid</code></em> and
                          <em class="replaceable"><code>tgid</code></em> as
                          seen from the current <em class="replaceable"><code>namespace</code></em>
                          will be returned in <em class="replaceable"><code>nsdata</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or one of the following
                          in case of failure:</p>
                          <p><code class="option">−EINVAL</code> if dev and
                          inum supplied don't match dev_t and inode
                          number with nsfs of current task, or if
                          dev conversion to dev_t lost high
                          bits.</p>
                          <p><code class="option">−ENOENT</code> if pidns
                          does not exists for the current task.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_xdp_output(void *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_map
              *</em></span><em class="replaceable"><code>map</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>data</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>size</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Write raw <em class="replaceable"><code>data</code></em> blob
                          into a special BPF perf event held by
                          <em class="replaceable"><code>map</code></em> of
                          type <code class="constant">BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>.
                          This perf event must have the following
                          attributes: <code class="constant">PERF_SAMPLE_RAW</code> as
                          <em class="replaceable"><code>sample_type</code></em>,
                          <code class="constant">PERF_TYPE_SOFTWARE</code> as
                          <em class="replaceable"><code>type</code></em>, and
                          <code class="constant">PERF_COUNT_SW_BPF_OUTPUT</code>
                          as <em class="replaceable"><code>config</code></em>.</p>
                          <p>The <em class="replaceable"><code>flags</code></em> are
                          used to indicate the index in <em class="replaceable"><code>map</code></em> for
                          which the value must be put, masked with
                          <code class="constant">BPF_F_INDEX_MASK</code>.
                          Alternatively, <em class="replaceable"><code>flags</code></em> can
                          be set to <code class="constant">BPF_F_CURRENT_CPU</code> to
                          indicate that the index of the current
                          CPU core should be used.</p>
                          <p>The value to write, of <em class="replaceable"><code>size</code></em>, is
                          passed through eBPF stack and pointed by
                          <em class="replaceable"><code>data</code></em>.</p>
                          <p><em class="replaceable"><code>ctx</code></em> is a
                          pointer to in−kernel struct
                          xdp_buff.</p>
                          <p>This helper is similar to <code class="function">bpf_perf_eventoutput</code>()
                          but restricted to raw_tracepoint bpf
                          programs.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_netns_cookie(void *</em></span><em class="replaceable"><code>ctx</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Retrieve the cookie (generated by the
                          kernel) of the network namespace the
                          input <em class="replaceable"><code>ctx</code></em> is
                          associated with. The network namespace
                          cookie remains stable for its lifetime
                          and provides a global identifier that can
                          be assumed unique. If <em class="replaceable"><code>ctx</code></em> is
                          NULL, then the helper returns the cookie
                          for the initial network namespace. The
                          cookie itself is very similar to that of
                          <code class="function">bpf_get_socket_cookie</code>()
                          helper, but for network namespaces
                          instead of sockets.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A 8−byte long opaque number.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_get_current_ancestor_cgroup_id(int</em></span>
              <em class="replaceable"><code>ancestor_level</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return id of cgroup v2 that is
                          ancestor of the cgroup associated with
                          the current task at the <em class="replaceable"><code>ancestor_level</code></em>.
                          The root cgroup is at <em class="replaceable"><code>ancestor_level</code></em>
                          zero and each step down the hierarchy
                          increments the level. If <em class="replaceable"><code>ancestor_level</code></em>
                          == level of cgroup associated with the
                          current task, then return value will be
                          the same as that of <code class="function">bpf_get_current_cgroup_id</code>().</p>
                          <p>The helper is useful to implement
                          policies based on cgroups that are upper
                          in hierarchy than immediate cgroup
                          associated with the current task.</p>
                          <p>The format of returned id and helper
                          limitations are same as in <code class="function">bpf_get_current_cgroup_id</code>().</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The id is returned or 0 in case the id
                          could not be retrieved.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sk_assign(struct sk_buff *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Helper is overloaded depending on BPF
                          program type. This description applies to
                          <code class="constant">BPF_PROG_TYPE_SCHED_CLS</code>
                          and <code class="constant">BPF_PROG_TYPE_SCHED_ACT</code>
                          programs.</p>
                          <p>Assign the <em class="replaceable"><code>sk</code></em> to the
                          <em class="replaceable"><code>skb</code></em>. When
                          combined with appropriate routing
                          configuration to receive the packet
                          towards the socket, will cause <em class="replaceable"><code>skb</code></em> to be
                          delivered to the specified socket.
                          Subsequent redirection of <em class="replaceable"><code>skb</code></em> via
                          <code class="function">bpf_redirect</code>(),
                          <code class="function">bpf_clone_redirect</code>() or
                          other methods outside of BPF may
                          interfere with successful delivery to the
                          socket.</p>
                          <p>This operation is only valid from TC
                          ingress path.</p>
                          <p>The <em class="replaceable"><code>flags</code></em>
                          argument must be zero.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure:</p>
                          <p><code class="option">−EINVAL</code> if
                          specified <em class="replaceable"><code>flags</code></em> are
                          not supported.</p>
                          <p><code class="option">−ENOENT</code> if the
                          socket is unavailable for assignment.</p>
                          <p><code class="option">−ENETUNREACH</code> if the
                          socket is unreachable (wrong netns).</p>
                          <p><code class="option">−EOPNOTSUPP</code> if the
                          operation is not supported, for example a
                          call from outside of TC ingress.</p>
                          <p><code class="option">−ESOCKTNOSUPPORT</code> if
                          the socket type is not supported
                          (reuseport).</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_sk_assign(struct bpf_sk_lookup
              *</em></span><em class="replaceable"><code>ctx</code></em><span class="emphasis"><em>, struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Helper is overloaded depending on BPF
                          program type. This description applies to
                          <code class="constant">BPF_PROG_TYPE_SK_LOOKUP</code>
                          programs.</p>
                          <p>Select the <em class="replaceable"><code>sk</code></em> as a
                          result of a socket lookup.</p>
                          <p>For the operation to succeed passed
                          socket must be compatible with the packet
                          description provided by the <em class="replaceable"><code>ctx</code></em>
                          object.</p>
                          <p>L4 protocol (<code class="constant">IPPROTO_TCP</code> or
                          <code class="constant">IPPROTO_UDP</code>) must be an
                          exact match. While IP family
                          (<code class="constant">AF_INET</code> or
                          <code class="constant">AF_INET6</code>)
                          must be compatible, that is IPv6 sockets
                          that are not v6−only can be
                          selected for IPv4 packets.</p>
                          <p>Only TCP listeners and UDP unconnected
                          sockets can be selected. <em class="replaceable"><code>sk</code></em> can
                          also be NULL to reset any previous
                          selection.</p>
                          <p><em class="replaceable"><code>flags</code></em>
                          argument can combination of following
                          values:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">BPF_SK_LOOKUP_F_REPLACE</code>
                                    to override the previous socket
                                    selection, potentially done by
                                    a BPF program that ran before
                                    us.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_SK_LOOKUP_F_NO_REUSEPORT</code>
                                    to skip load−balancing
                                    within reuseport group for the
                                    socket being selected.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>On success <em class="replaceable"><code>ctx−&gt;sk</code></em>
                          will point to the selected socket.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative errno in
                          case of failure.</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="option">−EAFNOSUPPORT</code>
                                    if socket family (<em class="replaceable"><code>sk−&gt;family</code></em>)
                                    is not compatible with packet
                                    family (<em class="replaceable"><code>ctx−&gt;family</code></em>).</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="option">−EEXIST</code>
                                    if socket has been already
                                    selected, potentially by
                                    another program, and
                                    <code class="constant">BPF_SK_LOOKUP_F_REPLACE</code>
                                    flag was not specified.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="option">−EINVAL</code>
                                    if unsupported flags were
                                    specified.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="option">−EPROTOTYPE</code>
                                    if socket L4 protocol
                                    (<em class="replaceable"><code>sk−&gt;protocol</code></em>)
                                    doesn't match packet protocol
                                    (<em class="replaceable"><code>ctx−&gt;protocol</code></em>).</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="option">−ESOCKTNOSUPPORT</code>
                                    if socket is not in allowed
                                    state (TCP listening or UDP
                                    unconnected).</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_ktime_get_boot_ns(void)</em></span></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return the time elapsed since system
                          boot, in nanoseconds. Does include the
                          time the system was suspended. See:
                          <code class="function">clock_gettime</code>(<code class="constant">CLOCK_BOOTTIME</code>)</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Current <em class="replaceable"><code>ktime</code></em>.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_seq_printf(struct seq_file
              *</em></span><em class="replaceable"><code>m</code></em><span class="emphasis"><em>,
              const char *</em></span><em class="replaceable"><code>fmt</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>fmt_size</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>data</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>data_len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p><code class="function">bpf_seq_printf</code>() uses
                          seq_file <code class="function">seq_printf</code>() to print
                          out the format string. The <em class="replaceable"><code>m</code></em>
                          represents the seq_file. The <em class="replaceable"><code>fmt</code></em> and
                          <em class="replaceable"><code>fmt_size</code></em>
                          are for the format string itself. The
                          <em class="replaceable"><code>data</code></em> and
                          <em class="replaceable"><code>data_len</code></em>
                          are format string arguments. The
                          <em class="replaceable"><code>data</code></em> are
                          a <em class="replaceable"><code>u64</code></em> array
                          and corresponding format string values
                          are stored in the array. For strings and
                          pointers where pointees are accessed,
                          only the pointer values are stored in the
                          <em class="replaceable"><code>data</code></em>
                          array. The <em class="replaceable"><code>data_len</code></em>
                          is the size of <em class="replaceable"><code>data</code></em> in
                          bytes.</p>
                          <p>Formats <em class="replaceable"><code>%s</code></em>,
                          <em class="replaceable"><code>%p{i,I}{4,6}</code></em>
                          requires to read kernel memory. Reading
                          kernel memory may fail due to either
                          invalid address or valid address but
                          requiring a major memory fault. If
                          reading kernel memory fails, the string
                          for <em class="replaceable"><code>%s</code></em> will
                          be an empty string, and the ip address
                          for <em class="replaceable"><code>%p{i,I}{4,6}</code></em>
                          will be 0. Not returning error to bpf
                          program is consistent with what
                          <code class="function">bpf_trace_printk</code>() does
                          for now.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure:</p>
                          <p><code class="option">−EBUSY</code> if
                          per−CPU memory copy buffer is busy,
                          can try again by returning 1 from bpf
                          program.</p>
                          <p><code class="option">−EINVAL</code> if
                          arguments are invalid, or if <em class="replaceable"><code>fmt</code></em> is
                          invalid/unsupported.</p>
                          <p><code class="option">−E2BIG</code> if
                          <em class="replaceable"><code>fmt</code></em>
                          contains too many format specifiers.</p>
                          <p><code class="option">−EOVERFLOW</code> if an
                          overflow happened: The same object will
                          be tried again.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_seq_write(struct seq_file *</em></span><em class="replaceable"><code>m</code></em><span class="emphasis"><em>, const void *</em></span><em class="replaceable"><code>data</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>len</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p><code class="function">bpf_seq_write</code>() uses
                          seq_file <code class="function">seq_write</code>() to write
                          the data. The <em class="replaceable"><code>m</code></em>
                          represents the seq_file. The <em class="replaceable"><code>data</code></em> and
                          <em class="replaceable"><code>len</code></em>
                          represent the data to write in bytes.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure:</p>
                          <p><code class="option">−EOVERFLOW</code> if an
                          overflow happened: The same object will
                          be tried again.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_sk_cgroup_id(struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return the cgroup v2 id of the socket
                          <em class="replaceable"><code>sk</code></em>.</p>
                          <p><em class="replaceable"><code>sk</code></em> must
                          be a non−<code class="constant">NULL</code> pointer to a full
                          socket, e.g. one returned from
                          <code class="function">bpf_sk_lookup_xxx</code>(),
                          <code class="function">bpf_sk_fullsock</code>(), etc.
                          The format of returned id is same as in
                          <code class="function">bpf_skb_cgroup_id</code>().</p>
                          <p>This helper is available only if the
                          kernel was compiled with the <code class="constant">CONFIG_SOCK_CGROUP_DATA</code>
                          configuration option.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The id is returned or 0 in case the id
                          could not be retrieved.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_sk_ancestor_cgroup_id(struct bpf_sock
              *</em></span><em class="replaceable"><code>sk</code></em><span class="emphasis"><em>, int</em></span> <em class="replaceable"><code>ancestor_level</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return id of cgroup v2 that is
                          ancestor of cgroup associated with the
                          <em class="replaceable"><code>sk</code></em> at the
                          <em class="replaceable"><code>ancestor_level</code></em>.
                          The root cgroup is at <em class="replaceable"><code>ancestor_level</code></em>
                          zero and each step down the hierarchy
                          increments the level. If <em class="replaceable"><code>ancestor_level</code></em>
                          == level of cgroup associated with
                          <em class="replaceable"><code>sk</code></em>, then
                          return value will be same as that of
                          <code class="function">bpf_sk_cgroup_id</code>().</p>
                          <p>The helper is useful to implement
                          policies based on cgroups that are upper
                          in hierarchy than immediate cgroup
                          associated with <em class="replaceable"><code>sk</code></em>.</p>
                          <p>The format of returned id and helper
                          limitations are same as in <code class="function">bpf_sk_cgroup_id</code>().</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>The id is returned or 0 in case the id
                          could not be retrieved.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_ringbuf_output(void *</em></span><em class="replaceable"><code>ringbuf</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>data</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Copy <em class="replaceable"><code>size</code></em>
                          bytes from <em class="replaceable"><code>data</code></em> into
                          a ring buffer <em class="replaceable"><code>ringbuf</code></em>.
                          If <code class="constant">BPF_RB_NO_WAKEUP</code> is
                          specified in <em class="replaceable"><code>flags</code></em>, no
                          notification of new data availability is
                          sent. If <code class="constant">BPF_RB_FORCE_WAKEUP</code> is
                          specified in <em class="replaceable"><code>flags</code></em>,
                          notification of new data availability is
                          sent unconditionally.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>void
              *bpf_ringbuf_reserve(void *</em></span><em class="replaceable"><code>ringbuf</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Reserve <em class="replaceable"><code>size</code></em>
                          bytes of payload in a ring buffer
                          <em class="replaceable"><code>ringbuf</code></em>.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Valid pointer with <em class="replaceable"><code>size</code></em>
                          bytes of memory available; NULL,
                          otherwise.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>void
              bpf_ringbuf_submit(void *</em></span><em class="replaceable"><code>data</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Submit reserved ring buffer sample,
                          pointed to by <em class="replaceable"><code>data</code></em>. If
                          <code class="constant">BPF_RB_NO_WAKEUP</code> is
                          specified in <em class="replaceable"><code>flags</code></em>, no
                          notification of new data availability is
                          sent. If <code class="constant">BPF_RB_FORCE_WAKEUP</code> is
                          specified in <em class="replaceable"><code>flags</code></em>,
                          notification of new data availability is
                          sent unconditionally.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Nothing. Always succeeds.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>void
              bpf_ringbuf_discard(void *</em></span><em class="replaceable"><code>data</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Discard reserved ring buffer sample,
                          pointed to by <em class="replaceable"><code>data</code></em>. If
                          <code class="constant">BPF_RB_NO_WAKEUP</code> is
                          specified in <em class="replaceable"><code>flags</code></em>, no
                          notification of new data availability is
                          sent. If <code class="constant">BPF_RB_FORCE_WAKEUP</code> is
                          specified in <em class="replaceable"><code>flags</code></em>,
                          notification of new data availability is
                          sent unconditionally.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Nothing. Always succeeds.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>u64
              bpf_ringbuf_query(void *</em></span><em class="replaceable"><code>ringbuf</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Query various characteristics of
                          provided ring buffer. What exactly is
                          queries is determined by <em class="replaceable"><code>flags</code></em>:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">BPF_RB_AVAIL_DATA</code>:
                                    Amount of data not yet
                                    consumed.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_RB_RING_SIZE</code>:
                                    The size of ring buffer.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_RB_CONS_POS</code>:
                                    Consumer position (can wrap
                                    around).</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_RB_PROD_POS</code>:
                                    Producer(s) position (can wrap
                                    around).</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                          <p>Data returned is just a momentary
                          snapshot of actual values and could be
                          inaccurate, so this facility should be
                          used to power heuristics and for
                          reporting, not to make 100% correct
                          calculation.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>Requested value, or 0, if <em class="replaceable"><code>flags</code></em> are
                          not recognized.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_csum_level(struct sk_buff *</em></span><em class="replaceable"><code>skb</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>level</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Change the skbs checksum level by one
                          layer up or down, or reset it entirely to
                          none in order to have the stack perform
                          checksum validation. The level is
                          applicable to the following protocols:
                          TCP, UDP, GRE, SCTP, FCOE. For example, a
                          decap of | ETH | IP | UDP | GUE | IP |
                          TCP | into | ETH | IP | TCP | through
                          <code class="function">bpf_skb_adjust_room</code>()
                          helper with passing in <code class="constant">BPF_F_ADJ_ROOM_NO_CSUM_RESET</code>
                          flag would require one call to
                          <code class="function">bpf_csum_level</code>() with
                          <code class="constant">BPF_CSUM_LEVEL_DEC</code>
                          since the UDP header is removed.
                          Similarly, an encap of the latter into
                          the former could be accompanied by a
                          helper call to <code class="function">bpf_csum_level</code>() with
                          <code class="constant">BPF_CSUM_LEVEL_INC</code> if
                          the skb is still intended to be processed
                          in higher layers of the stack instead of
                          just egressing at tc.</p>
                          <p>There are three supported level
                          settings at this time:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="itemizedlist">
                                <ul class="itemizedlist" style="list-style-type: disc;">
                                  <li class="listitem">
                                    <p><code class="constant">BPF_CSUM_LEVEL_INC</code>:
                                    Increases
                                    skb−&gt;csum_level for
                                    skbs with
                                    CHECKSUM_UNNECESSARY.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_CSUM_LEVEL_DEC</code>:
                                    Decreases
                                    skb−&gt;csum_level for
                                    skbs with
                                    CHECKSUM_UNNECESSARY.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_CSUM_LEVEL_RESET</code>:
                                    Resets skb−&gt;csum_level
                                    to 0 and sets CHECKSUM_NONE to
                                    force checksum validation by
                                    the stack.</p>
                                  </li>
                                  <li class="listitem">
                                    <p><code class="constant">BPF_CSUM_LEVEL_QUERY</code>:
                                    No−op, returns the
                                    current
                                    skb−&gt;csum_level.</p>
                                  </li>
                                </ul>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>0 on success, or a negative error in
                          case of failure. In the case of
                          <code class="constant">BPF_CSUM_LEVEL_QUERY</code>,
                          the current skb−&gt;csum_level is
                          returned or the error code −EACCES
                          in case the skb is not subject to
                          CHECKSUM_UNNECESSARY.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              tcp6_sock *bpf_skc_to_tcp6_sock(void
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Dynamically cast a <em class="replaceable"><code>sk</code></em>
                          pointer to a <em class="replaceable"><code>tcp6_sock</code></em>
                          pointer.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><em class="replaceable"><code>sk</code></em> if
                          casting is valid, or NULL otherwise.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              tcp_sock *bpf_skc_to_tcp_sock(void
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Dynamically cast a <em class="replaceable"><code>sk</code></em>
                          pointer to a <em class="replaceable"><code>tcp_sock</code></em>
                          pointer.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><em class="replaceable"><code>sk</code></em> if
                          casting is valid, or NULL otherwise.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              tcp_timewait_sock *bpf_skc_to_tcp_timewait_sock(void
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Dynamically cast a <em class="replaceable"><code>sk</code></em>
                          pointer to a <em class="replaceable"><code>tcp_timewait_sock</code></em>
                          pointer.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><em class="replaceable"><code>sk</code></em> if
                          casting is valid, or NULL otherwise.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              tcp_request_sock *bpf_skc_to_tcp_request_sock(void
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Dynamically cast a <em class="replaceable"><code>sk</code></em>
                          pointer to a <em class="replaceable"><code>tcp_request_sock</code></em>
                          pointer.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><em class="replaceable"><code>sk</code></em> if
                          casting is valid, or NULL otherwise.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>struct
              udp6_sock *bpf_skc_to_udp6_sock(void
              *</em></span><em class="replaceable"><code>sk</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Dynamically cast a <em class="replaceable"><code>sk</code></em>
                          pointer to a <em class="replaceable"><code>udp6_sock</code></em>
                          pointer.</p>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p><em class="replaceable"><code>sk</code></em> if
                          casting is valid, or NULL otherwise.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
              <dt><span class="term"><span class="emphasis"><em><span class="emphasis"><em>long
              bpf_get_task_stack(struct task_struct
              *</em></span><em class="replaceable"><code>task</code></em><span class="emphasis"><em>, void *</em></span><em class="replaceable"><code>buf</code></em><span class="emphasis"><em>, u32</em></span> <em class="replaceable"><code>size</code></em><span class="emphasis"><em>, u64</em></span> <em class="replaceable"><code>flags</code></em><code class="literal">)</code></em></span></span></dt>
              <dd>
                <div class="blockquote">
                  <blockquote class="blockquote">
                    <div class="variablelist">
                      <dl class="variablelist">
                        <dt><span class="term">Description</span></dt>
                        <dd>
                          <p>Return a user or a kernel stack in bpf
                          program provided buffer. To achieve this,
                          the helper needs <em class="replaceable"><code>task</code></em>,
                          which is a valid pointer to struct
                          task_struct. To store the stacktrace, the
                          bpf program provides <em class="replaceable"><code>buf</code></em> with
                          a nonnegative <em class="replaceable"><code>size</code></em>.</p>
                          <p>The last argument, <em class="replaceable"><code>flags</code></em>,
                          holds the number of stack frames to skip
                          (from 0 to 255), masked with <code class="constant">BPF_F_SKIP_FIELD_MASK</code>.
                          The next bits can be used to set the
                          following flags:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="variablelist">
                                <dl class="variablelist">
                                  <dt><span class="term"><code class="constant">BPF_F_USER_STACK</code></span></dt>
                                  <dd>
                                    <p>Collect a user space stack
                                    instead of a kernel stack.</p>
                                  </dd>
                                  <dt><span class="term"><code class="constant">BPF_F_USER_BUILD_ID</code></span></dt>
                                  <dd>
                                    <p>Collect buildid+offset
                                    instead of ips for user stack,
                                    only valid if <code class="constant">BPF_F_USER_STACK</code>
                                    is also specified.</p>
                                  </dd>
                                </dl>
                              </div>
                            </blockquote>
                          </div>
                          <p><code class="function">bpf_get_task_stack</code>()
                          can collect up to <code class="constant">PERF_MAX_STACK_DEPTH</code>
                          both kernel and user frames, subject to
                          sufficient large buffer size. Note that
                          this limit can be controlled with the
                          <em class="replaceable"><code>sysctl</code></em>
                          program, and that it should be manually
                          increased in order to profile long user
                          stacks (such as stacks for Java
                          programs). To do so, use:</p>
                          <div class="blockquote">
                            <blockquote class="blockquote">
                              <div class="blockquote">
                                <blockquote class="blockquote">
                                  <div class="informalexample">
                                    <pre class="programlisting" xml:space="preserve">
# sysctl kernel.perf_event_max_stack=&lt;new value&gt;
</pre>
                                  </div>
                                </blockquote>
                              </div>
                            </blockquote>
                          </div>
                        </dd>
                        <dt><span class="term">Return</span></dt>
                        <dd>
                          <p>A non−negative value equal to or
                          less than <em class="replaceable"><code>size</code></em> on
                          success, or a negative error in case of
                          failure.</p>
                        </dd>
                      </dl>
                    </div>
                  </blockquote>
                </div>
              </dd>
            </dl>
          </div>
        </blockquote>
      </div>
    </div>
    <div class="refsect1">
      <a id="bpf-helpers-7_sect3" name="bpf-helpers-7_sect3" shape="rect"> </a>
      <h2>EXAMPLES</h2>
      <p>Example usage for most of the eBPF helpers listed in this
      manual page are available within the Linux kernel sources, at
      the following locations:</p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc;">
              <li class="listitem">
                <p><em class="replaceable"><code>samples/bpf/</code></em></p>
              </li>
              <li class="listitem">
                <p><em class="replaceable"><code>tools/testing/selftests/bpf/</code></em></p>
              </li>
            </ul>
          </div>
        </blockquote>
      </div>
    </div>
    <div class="refsect1">
      <a id="bpf-helpers-7_sect4" name="bpf-helpers-7_sect4" shape="rect"> </a>
      <h2>LICENSE</h2>
      <p>eBPF programs can have an associated license, passed along
      with the bytecode instructions to the kernel when the
      programs are loaded. The format for that string is identical
      to the one in use for kernel modules (Dual licenses, such as
      "Dual BSD/GPL", may be used). Some helper functions are only
      accessible to programs that are compatible with the GNU
      Privacy License (GPL).</p>
      <p>In order to use such helpers, the eBPF program must be
      loaded with the correct license string passed (via <em class="replaceable"><code>attr</code></em>) to the <code class="function">bpf</code>() system call, and this generally
      translates into the C source code of the program containing a
      line similar to the following:</p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <div class="blockquote">
            <blockquote class="blockquote">
              <div class="informalexample">
                <pre class="programlisting" xml:space="preserve">
char ____license[] __attribute__((section("license"), used)) = "GPL";
</pre>
              </div>
            </blockquote>
          </div>
        </blockquote>
      </div>
    </div>
    <div class="refsect1">
      <a id="bpf-helpers-7_sect5" name="bpf-helpers-7_sect5" shape="rect"> </a>
      <h2>IMPLEMENTATION</h2>
      <p>This manual page is an effort to document the existing
      eBPF helper functions. But as of this writing, the BPF
      sub−system is under heavy development. New eBPF program
      or map types are added, along with new helper functions. Some
      helpers are occasionally made available for additional
      program types. So in spite of the efforts of the community,
      this page might not be up−to−date. If you want to
      check by yourself what helper functions exist in your kernel,
      or what types of programs they can support, here are some
      files among the kernel tree that you may be interested
      in:</p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc;">
              <li class="listitem">
                <p><code class="filename">include/uapi/linux/bpf.h</code> is the
                main BPF header. It contains the full list of all
                helper functions, as well as many other BPF
                definitions including most of the flags, structs or
                constants used by the helpers.</p>
              </li>
              <li class="listitem">
                <p><code class="filename">net/core/filter.c</code>
                contains the definition of most
                network−related helper functions, and the
                list of program types from which they can be
                used.</p>
              </li>
              <li class="listitem">
                <p><code class="filename">kernel/trace/bpf_trace.c</code> is the
                equivalent for most tracing program−related
                helpers.</p>
              </li>
              <li class="listitem">
                <p><code class="filename">kernel/bpf/verifier.c</code> contains
                the functions used to check that valid types of
                eBPF maps are used with a given helper
                function.</p>
              </li>
              <li class="listitem">
                <p><em class="replaceable"><code>kernel/bpf/</code></em>
                directory contains other files in which additional
                helpers are defined (for cgroups, sockmaps,
                etc.).</p>
              </li>
              <li class="listitem">
                <p>The bpftool utility can be used to probe the
                availability of helper functions on the system (as
                well as supported program and map types, and a
                number of other parameters). To do so, run
                <span class="emphasis"><em>bpftool feature
                probe</em></span> (see <span class="citerefentry"><span class="refentrytitle">bpftool-feature</span>(8)</span>
                for details). Add the <em class="replaceable"><code>unprivileged</code></em>
                keyword to list features available to unprivileged
                users.</p>
              </li>
            </ul>
          </div>
        </blockquote>
      </div>
      <p>Compatibility between helper functions and program types
      can generally be found in the files where helper functions
      are defined. Look for the <em class="replaceable"><code>structbpf_func_proto</code></em> objects
      and for functions returning them: these functions contain a
      list of helpers that a given program type can call. Note that
      the <em class="replaceable"><code>default:</code></em> label
      of the <span class="emphasis"><em>switch ... case</em></span>
      used to filter helpers can call other functions, themselves
      allowing access to additional helpers. The requirement for
      GPL license is also in those <span class="emphasis"><em>struct bpf_func_proto</em></span>.</p>
      <p>Compatibility between helper functions and map types can
      be found in the <code class="function">check_map_func_compatibility</code>() function in
      file <code class="filename">kernel/bpf/verifier.c</code>.</p>
      <p>Helper functions that invalidate the checks on <em class="replaceable"><code>data</code></em> and <em class="replaceable"><code>data_end</code></em> pointers for network
      processing are listed in function <code class="function">bpf_helper_changes_pkt_data</code>() in file
      <code class="filename">net/core/filter.c</code>.</p>
    </div>
    <div class="refsect1">
      <a id="bpf-helpers-7_sect6" name="bpf-helpers-7_sect6" shape="rect"> </a>
      <h2>SEE ALSO</h2>
      <p><a class="link" href="../htmlman2/bpf.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">bpf</span>(2)</span></a>, <span class="citerefentry"><span class="refentrytitle">bpftool</span>(8)</span>, <a class="link" href="../htmlman7/cgroups.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">cgroups</span>(7)</span></a>, <span class="citerefentry"><span class="refentrytitle">ip</span>(8)</span>, <a class="link" href="../htmlman2/perf_event_open.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">perf_event_open</span>(2)</span></a>,
      <a class="link" href="../htmlman2/send.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sendmsg</span>(2)</span></a>, <a class="link" href="../htmlman7/socket.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">socket</span>(7)</span></a>, <span class="citerefentry"><span class="refentrytitle">tc-bpf</span>(8)</span></p>
    </div>
    <div class="colophon">
      <a id="bpf-helpers-7_sect7" name="bpf-helpers-7_sect7" shape="rect"> </a>
      <h2>COLOPHON</h2>
      <p>This page is part of release 5.11 of the Linux <em class="replaceable"><code>man-pages</code></em> project. A
      description of the project, information about reporting bugs,
      and the latest version of this page, can be found at
      https://www.kernel.org/doc/man−pages/.</p>
      <div class="license">
        <table class="license" style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>
          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <div class="literallayout">
                  <br />
                    %%%LICENSE_START(VERBATIM)<br />
                  Permission is granted to make and distribute verbatim copies of this<br />

                  manual provided the copyright notice and this permission notice are<br />

                  preserved on all copies.<br />
                  <br />
                  Permission is granted to copy and distribute modified versions of this<br />

                  manual under the conditions for verbatim copying, provided that the<br />

                  entire resulting derived work is distributed under the terms of a<br />

                  permission notice identical to this one.<br />

                  <br />
                  Since the Linux kernel and libraries are constantly changing, this<br />

                  manual page may be incorrect or out-of-date.  The author(s) assume no<br />

                  responsibility for errors or omissions, or for damages resulting from<br />

                  the use of the information contained herein.  The author(s) may not<br />

                  have taken the same level of care in the production of this manual,<br />

                  which is licensed free of charge, as they might when working<br />

                  professionally.<br />
                  <br />
                  Formatted or processed versions of this manual, if unaccompanied by<br />

                  the source, must acknowledge the copyright and authors of this work.<br />

                  %%%LICENSE_END<br />
                  <br />
                  Please do not edit this file. It was generated from the documentation<br />

                  located in file include/uapi/linux/bpf.h of the Linux kernel sources<br />

                  (helpers description), and from scripts/bpf_helpers_doc.py in the same<br />

                  repository (header and footer).<br />
                  
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>
